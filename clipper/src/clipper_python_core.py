# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_clipper_python_core')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_clipper_python_core')
    _clipper_python_core = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_clipper_python_core', [dirname(__file__)])
        except ImportError:
            import _clipper_python_core
            return _clipper_python_core
        try:
            _mod = imp.load_module('_clipper_python_core', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _clipper_python_core = swig_import_helper()
    del swig_import_helper
else:
    import _clipper_python_core
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _clipper_python_core.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _clipper_python_core.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _clipper_python_core.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _clipper_python_core.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _clipper_python_core.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _clipper_python_core.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _clipper_python_core.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _clipper_python_core.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _clipper_python_core.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _clipper_python_core.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _clipper_python_core.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _clipper_python_core.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _clipper_python_core.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _clipper_python_core.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _clipper_python_core.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _clipper_python_core.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _clipper_python_core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)



def safesplat_int(func):
  '''
  C or C++ functions of the form func(int, int, ...) wrapped into Python
  are problematic when (as is quite common) one wants to call them using
  the splat (*) operator - i.e. func(*array). Specifically, this is
  prone to failure for numpy.int32 and numpy.float32 types due to
  incorrect typemapping of the scalars. The safesplat_int and
  safesplat_float decorators are designed to provide a simple workaround
  for these cases. Used as follows:
  @safesplat_int
  def func(arg1, arg2, arg3):
    do stuff
  ... it will try to do the straightforward splat first. If that fails,
  it will assume the argument is a numpy array, and attempt to convert
  that to something that will work. If *that* fails, it will raise a
  TypeError.
  '''
  def func_wrapper(arg_array):
    try:
      return func(*arg_array)
    except:
      try:
        return func(*(arg_array.tolist()))
      except:
        raise NotImplementedError('Input is not a valid array of integers or is the wrong length!')
  return func_wrapper

def safesplat_float(func):
  '''
  C or C++ functions of the form func(int, int, ...) wrapped into Python
  are problematic when (as is quite common) one wants to call them using
  the splat (*) operator - i.e. func(*array). Specifically, this is
  prone to failure for numpy.int32 and numpy.float32 types due to
  incorrect typemapping of the scalars. The safesplat_int and
  safesplat_float decorators are designed to provide a simple workaround
  for these cases. Used as follows:
  @safesplat_float
  def func(arg1, arg2, arg3):
    do stuff
  ... it will try to do the straightforward splat first. If that fails,
  it will assume the argument is a numpy array, and attempt to convert
  that to something that will work. If *that* fails, it will raise a
  TypeError.
  '''
  def func_wrapper(arg_array):
    try:
      return func(*arg_array)
    except:
      try:
        return func(*(arg_array.astype(float)))
      except:
        raise NotImplementedError('Input is not a valid numeric array or is the wrong length!')
  return func_wrapper



class IntVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _clipper_python_core.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _clipper_python_core.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _clipper_python_core.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _clipper_python_core.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _clipper_python_core.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _clipper_python_core.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _clipper_python_core.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _clipper_python_core.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _clipper_python_core.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _clipper_python_core.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _clipper_python_core.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _clipper_python_core.IntVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _clipper_python_core.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _clipper_python_core.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _clipper_python_core.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _clipper_python_core.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _clipper_python_core.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _clipper_python_core.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _clipper_python_core.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _clipper_python_core.IntVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _clipper_python_core.IntVector_swigregister
IntVector_swigregister(IntVector)

class FloatVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _clipper_python_core.FloatVector___len__(self)

    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        return _clipper_python_core.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        return _clipper_python_core.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _clipper_python_core.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _clipper_python_core.FloatVector_pop(self)

    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _clipper_python_core.FloatVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _clipper_python_core.FloatVector_size(self)

    def swap(self, v: 'FloatVector') -> "void":
        return _clipper_python_core.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _clipper_python_core.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _clipper_python_core.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _clipper_python_core.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _clipper_python_core.FloatVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _clipper_python_core.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _clipper_python_core.FloatVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_FloatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _clipper_python_core.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _clipper_python_core.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _clipper_python_core.FloatVector_back(self)

    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        return _clipper_python_core.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.FloatVector_insert(self, *args)

    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        return _clipper_python_core.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _clipper_python_core.FloatVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _clipper_python_core.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class DoubleVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _clipper_python_core.DoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _clipper_python_core.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _clipper_python_core.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _clipper_python_core.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _clipper_python_core.DoubleVector_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _clipper_python_core.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _clipper_python_core.DoubleVector_size(self)

    def swap(self, v: 'DoubleVector') -> "void":
        return _clipper_python_core.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _clipper_python_core.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _clipper_python_core.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _clipper_python_core.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _clipper_python_core.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _clipper_python_core.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _clipper_python_core.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _clipper_python_core.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _clipper_python_core.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _clipper_python_core.DoubleVector_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _clipper_python_core.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.DoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _clipper_python_core.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _clipper_python_core.DoubleVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _clipper_python_core.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class IntIntVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.IntIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.IntIntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.IntIntVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< int > >::size_type":
        return _clipper_python_core.IntIntVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::vector< int > >::difference_type', j: 'std::vector< std::vector< int > >::difference_type') -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *":
        return _clipper_python_core.IntIntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.IntIntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::vector< int > >::difference_type', j: 'std::vector< std::vector< int > >::difference_type') -> "void":
        return _clipper_python_core.IntIntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.IntIntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< int > >::value_type const &":
        return _clipper_python_core.IntIntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.IntIntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< int > >::value_type":
        return _clipper_python_core.IntIntVector_pop(self)

    def append(self, x: 'IntVector') -> "void":
        return _clipper_python_core.IntIntVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.IntIntVector_empty(self)

    def size(self) -> "std::vector< std::vector< int > >::size_type":
        return _clipper_python_core.IntIntVector_size(self)

    def swap(self, v: 'IntIntVector') -> "void":
        return _clipper_python_core.IntIntVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< int > >::iterator":
        return _clipper_python_core.IntIntVector_begin(self)

    def end(self) -> "std::vector< std::vector< int > >::iterator":
        return _clipper_python_core.IntIntVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _clipper_python_core.IntIntVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _clipper_python_core.IntIntVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.IntIntVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< int > >::allocator_type":
        return _clipper_python_core.IntIntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.IntIntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< int > >::iterator":
        return _clipper_python_core.IntIntVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_IntIntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'IntVector') -> "void":
        return _clipper_python_core.IntIntVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _clipper_python_core.IntIntVector_front(self)

    def back(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _clipper_python_core.IntIntVector_back(self)

    def assign(self, n: 'std::vector< std::vector< int > >::size_type', x: 'IntVector') -> "void":
        return _clipper_python_core.IntIntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.IntIntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.IntIntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::vector< int > >::size_type') -> "void":
        return _clipper_python_core.IntIntVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< int > >::size_type":
        return _clipper_python_core.IntIntVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_IntIntVector
    __del__ = lambda self: None
IntIntVector_swigregister = _clipper_python_core.IntIntVector_swigregister
IntIntVector_swigregister(IntIntVector)

class FloatFloatVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.FloatFloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.FloatFloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.FloatFloatVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< float > >::size_type":
        return _clipper_python_core.FloatFloatVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > *":
        return _clipper_python_core.FloatFloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.FloatFloatVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "void":
        return _clipper_python_core.FloatFloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.FloatFloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< float > >::value_type const &":
        return _clipper_python_core.FloatFloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.FloatFloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< float > >::value_type":
        return _clipper_python_core.FloatFloatVector_pop(self)

    def append(self, x: 'FloatVector') -> "void":
        return _clipper_python_core.FloatFloatVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.FloatFloatVector_empty(self)

    def size(self) -> "std::vector< std::vector< float > >::size_type":
        return _clipper_python_core.FloatFloatVector_size(self)

    def swap(self, v: 'FloatFloatVector') -> "void":
        return _clipper_python_core.FloatFloatVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< float > >::iterator":
        return _clipper_python_core.FloatFloatVector_begin(self)

    def end(self) -> "std::vector< std::vector< float > >::iterator":
        return _clipper_python_core.FloatFloatVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        return _clipper_python_core.FloatFloatVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        return _clipper_python_core.FloatFloatVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.FloatFloatVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< float > >::allocator_type":
        return _clipper_python_core.FloatFloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.FloatFloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< float > >::iterator":
        return _clipper_python_core.FloatFloatVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_FloatFloatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'FloatVector') -> "void":
        return _clipper_python_core.FloatFloatVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< float > >::value_type const &":
        return _clipper_python_core.FloatFloatVector_front(self)

    def back(self) -> "std::vector< std::vector< float > >::value_type const &":
        return _clipper_python_core.FloatFloatVector_back(self)

    def assign(self, n: 'std::vector< std::vector< float > >::size_type', x: 'FloatVector') -> "void":
        return _clipper_python_core.FloatFloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.FloatFloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.FloatFloatVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::vector< float > >::size_type') -> "void":
        return _clipper_python_core.FloatFloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< float > >::size_type":
        return _clipper_python_core.FloatFloatVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_FloatFloatVector
    __del__ = lambda self: None
FloatFloatVector_swigregister = _clipper_python_core.FloatFloatVector_swigregister
FloatFloatVector_swigregister(FloatFloatVector)

class DoubleDoubleVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.DoubleDoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.DoubleDoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.DoubleDoubleVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< double > >::size_type":
        return _clipper_python_core.DoubleDoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::vector< double > >::difference_type', j: 'std::vector< std::vector< double > >::difference_type') -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *":
        return _clipper_python_core.DoubleDoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.DoubleDoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::vector< double > >::difference_type', j: 'std::vector< std::vector< double > >::difference_type') -> "void":
        return _clipper_python_core.DoubleDoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.DoubleDoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< double > >::value_type const &":
        return _clipper_python_core.DoubleDoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.DoubleDoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< double > >::value_type":
        return _clipper_python_core.DoubleDoubleVector_pop(self)

    def append(self, x: 'DoubleVector') -> "void":
        return _clipper_python_core.DoubleDoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.DoubleDoubleVector_empty(self)

    def size(self) -> "std::vector< std::vector< double > >::size_type":
        return _clipper_python_core.DoubleDoubleVector_size(self)

    def swap(self, v: 'DoubleDoubleVector') -> "void":
        return _clipper_python_core.DoubleDoubleVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< double > >::iterator":
        return _clipper_python_core.DoubleDoubleVector_begin(self)

    def end(self) -> "std::vector< std::vector< double > >::iterator":
        return _clipper_python_core.DoubleDoubleVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _clipper_python_core.DoubleDoubleVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _clipper_python_core.DoubleDoubleVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.DoubleDoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< double > >::allocator_type":
        return _clipper_python_core.DoubleDoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.DoubleDoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< double > >::iterator":
        return _clipper_python_core.DoubleDoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_DoubleDoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'DoubleVector') -> "void":
        return _clipper_python_core.DoubleDoubleVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _clipper_python_core.DoubleDoubleVector_front(self)

    def back(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _clipper_python_core.DoubleDoubleVector_back(self)

    def assign(self, n: 'std::vector< std::vector< double > >::size_type', x: 'DoubleVector') -> "void":
        return _clipper_python_core.DoubleDoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.DoubleDoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.DoubleDoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::vector< double > >::size_type') -> "void":
        return _clipper_python_core.DoubleDoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< double > >::size_type":
        return _clipper_python_core.DoubleDoubleVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_DoubleDoubleVector
    __del__ = lambda self: None
DoubleDoubleVector_swigregister = _clipper_python_core.DoubleDoubleVector_swigregister
DoubleDoubleVector_swigregister(DoubleDoubleVector)

class ClipperMessageStream(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_ClipperMessageStream()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_ClipperMessageStream
    __del__ = lambda self: None

    def get_stream(self) -> "std::ostringstream &":
        return _clipper_python_core.ClipperMessageStream_get_stream(self)

    def redirect_clipper_messages(self) -> "std::ostringstream &":
        return _clipper_python_core.ClipperMessageStream_redirect_clipper_messages(self)

    def read_and_clear(self) -> "std::string":
        return _clipper_python_core.ClipperMessageStream_read_and_clear(self)

    def clear(self) -> "void":
        return _clipper_python_core.ClipperMessageStream_clear(self)
ClipperMessageStream_swigregister = _clipper_python_core.ClipperMessageStream_swigregister
ClipperMessageStream_swigregister(ClipperMessageStream)


class MessageStreamSingleton:
  '''
  Creates and maintains a singleton object designed to intercept
  Clipper messages and redirect them from stderr to a string that
  can be used in Python.
  '''
  class __Get_MessageStream:
      def __init__(self):
          self.clipper_messages = ClipperMessageStream()
  instance = None
  def __init__(self):
      if not MessageStreamSingleton.instance:
          MessageStreamSingleton.instance = MessageStreamSingleton.__Get_MessageStream()
  def __getattr__(self, name):
      return getattr(self.instance, name)

_clipper_messages = MessageStreamSingleton().clipper_messages

def log_clipper(func):
  '''
  Acts as a decorator to direct Clipper messages to the Python console.
  Any messages coming from Clipper are accumulated in _clipper_messages.
  For any core Clipper function which has the potential to generate a
  warning message, simply add the @log_clipper decorator to the Python
  method. Override this function if you want the messages to go somewhere
  else (e.g. to a log file).
  '''
  def func_wrapper(*args, **kwargs):
    _clipper_messages.clear()
    ret = func(*args, **kwargs)
    message_string = _clipper_messages.read_and_clear()
    if message_string:
      print("CLIPPER WARNING:")
      print(message_string)
    return ret
  return func_wrapper




def warn_test() -> "void":
    return _clipper_python_core.warn_test()
warn_test = _clipper_python_core.warn_test

def except_test() -> "void":
    return _clipper_python_core.except_test()
except_test = _clipper_python_core.except_test

def ClipperStringAsString(a: 'String') -> "std::string":
    return _clipper_python_core.ClipperStringAsString(a)
ClipperStringAsString = _clipper_python_core.ClipperStringAsString

warn_test = log_clipper(warn_test)

class UnsignedIntVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.UnsignedIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.UnsignedIntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.UnsignedIntVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _clipper_python_core.UnsignedIntVector___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _clipper_python_core.UnsignedIntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.UnsignedIntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        return _clipper_python_core.UnsignedIntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.UnsignedIntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _clipper_python_core.UnsignedIntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.UnsignedIntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _clipper_python_core.UnsignedIntVector_pop(self)

    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _clipper_python_core.UnsignedIntVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.UnsignedIntVector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _clipper_python_core.UnsignedIntVector_size(self)

    def swap(self, v: 'UnsignedIntVector') -> "void":
        return _clipper_python_core.UnsignedIntVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _clipper_python_core.UnsignedIntVector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _clipper_python_core.UnsignedIntVector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _clipper_python_core.UnsignedIntVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _clipper_python_core.UnsignedIntVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.UnsignedIntVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _clipper_python_core.UnsignedIntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.UnsignedIntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _clipper_python_core.UnsignedIntVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_UnsignedIntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _clipper_python_core.UnsignedIntVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _clipper_python_core.UnsignedIntVector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _clipper_python_core.UnsignedIntVector_back(self)

    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _clipper_python_core.UnsignedIntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.UnsignedIntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.UnsignedIntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        return _clipper_python_core.UnsignedIntVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _clipper_python_core.UnsignedIntVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_UnsignedIntVector
    __del__ = lambda self: None
UnsignedIntVector_swigregister = _clipper_python_core.UnsignedIntVector_swigregister
UnsignedIntVector_swigregister(UnsignedIntVector)

class ClipperStringVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.ClipperStringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.ClipperStringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.ClipperStringVector___bool__(self)

    def __len__(self) -> "std::vector< clipper::String >::size_type":
        return _clipper_python_core.ClipperStringVector___len__(self)

    def __getslice__(self, i: 'std::vector< clipper::String >::difference_type', j: 'std::vector< clipper::String >::difference_type') -> "std::vector< clipper::String,std::allocator< clipper::String > > *":
        return _clipper_python_core.ClipperStringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.ClipperStringVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< clipper::String >::difference_type', j: 'std::vector< clipper::String >::difference_type') -> "void":
        return _clipper_python_core.ClipperStringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.ClipperStringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< clipper::String >::value_type const &":
        return _clipper_python_core.ClipperStringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.ClipperStringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< clipper::String >::value_type":
        return _clipper_python_core.ClipperStringVector_pop(self)

    def append(self, x: 'String') -> "void":
        return _clipper_python_core.ClipperStringVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.ClipperStringVector_empty(self)

    def size(self) -> "std::vector< clipper::String >::size_type":
        return _clipper_python_core.ClipperStringVector_size(self)

    def swap(self, v: 'ClipperStringVector') -> "void":
        return _clipper_python_core.ClipperStringVector_swap(self, v)

    def begin(self) -> "std::vector< clipper::String >::iterator":
        return _clipper_python_core.ClipperStringVector_begin(self)

    def end(self) -> "std::vector< clipper::String >::iterator":
        return _clipper_python_core.ClipperStringVector_end(self)

    def rbegin(self) -> "std::vector< clipper::String >::reverse_iterator":
        return _clipper_python_core.ClipperStringVector_rbegin(self)

    def rend(self) -> "std::vector< clipper::String >::reverse_iterator":
        return _clipper_python_core.ClipperStringVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.ClipperStringVector_clear(self)

    def get_allocator(self) -> "std::vector< clipper::String >::allocator_type":
        return _clipper_python_core.ClipperStringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.ClipperStringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< clipper::String >::iterator":
        return _clipper_python_core.ClipperStringVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_ClipperStringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'String') -> "void":
        return _clipper_python_core.ClipperStringVector_push_back(self, x)

    def front(self) -> "std::vector< clipper::String >::value_type const &":
        return _clipper_python_core.ClipperStringVector_front(self)

    def back(self) -> "std::vector< clipper::String >::value_type const &":
        return _clipper_python_core.ClipperStringVector_back(self)

    def assign(self, n: 'std::vector< clipper::String >::size_type', x: 'String') -> "void":
        return _clipper_python_core.ClipperStringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.ClipperStringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.ClipperStringVector_insert(self, *args)

    def reserve(self, n: 'std::vector< clipper::String >::size_type') -> "void":
        return _clipper_python_core.ClipperStringVector_reserve(self, n)

    def capacity(self) -> "std::vector< clipper::String >::size_type":
        return _clipper_python_core.ClipperStringVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_ClipperStringVector
    __del__ = lambda self: None
ClipperStringVector_swigregister = _clipper_python_core.ClipperStringVector_swigregister
ClipperStringVector_swigregister(ClipperStringVector)

class HKLVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.HKLVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.HKLVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.HKLVector___bool__(self)

    def __len__(self) -> "std::vector< clipper::HKL >::size_type":
        return _clipper_python_core.HKLVector___len__(self)

    def __getslice__(self, i: 'std::vector< clipper::HKL >::difference_type', j: 'std::vector< clipper::HKL >::difference_type') -> "std::vector< clipper::HKL,std::allocator< clipper::HKL > > *":
        return _clipper_python_core.HKLVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.HKLVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< clipper::HKL >::difference_type', j: 'std::vector< clipper::HKL >::difference_type') -> "void":
        return _clipper_python_core.HKLVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.HKLVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< clipper::HKL >::value_type const &":
        return _clipper_python_core.HKLVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.HKLVector___setitem__(self, *args)

    def pop(self) -> "std::vector< clipper::HKL >::value_type":
        return _clipper_python_core.HKLVector_pop(self)

    def append(self, x: 'HKL') -> "void":
        return _clipper_python_core.HKLVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.HKLVector_empty(self)

    def size(self) -> "std::vector< clipper::HKL >::size_type":
        return _clipper_python_core.HKLVector_size(self)

    def swap(self, v: 'HKLVector') -> "void":
        return _clipper_python_core.HKLVector_swap(self, v)

    def begin(self) -> "std::vector< clipper::HKL >::iterator":
        return _clipper_python_core.HKLVector_begin(self)

    def end(self) -> "std::vector< clipper::HKL >::iterator":
        return _clipper_python_core.HKLVector_end(self)

    def rbegin(self) -> "std::vector< clipper::HKL >::reverse_iterator":
        return _clipper_python_core.HKLVector_rbegin(self)

    def rend(self) -> "std::vector< clipper::HKL >::reverse_iterator":
        return _clipper_python_core.HKLVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.HKLVector_clear(self)

    def get_allocator(self) -> "std::vector< clipper::HKL >::allocator_type":
        return _clipper_python_core.HKLVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.HKLVector_pop_back(self)

    def erase(self, *args) -> "std::vector< clipper::HKL >::iterator":
        return _clipper_python_core.HKLVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_HKLVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'HKL') -> "void":
        return _clipper_python_core.HKLVector_push_back(self, x)

    def front(self) -> "std::vector< clipper::HKL >::value_type const &":
        return _clipper_python_core.HKLVector_front(self)

    def back(self) -> "std::vector< clipper::HKL >::value_type const &":
        return _clipper_python_core.HKLVector_back(self)

    def assign(self, n: 'std::vector< clipper::HKL >::size_type', x: 'HKL') -> "void":
        return _clipper_python_core.HKLVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.HKLVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.HKLVector_insert(self, *args)

    def reserve(self, n: 'std::vector< clipper::HKL >::size_type') -> "void":
        return _clipper_python_core.HKLVector_reserve(self, n)

    def capacity(self) -> "std::vector< clipper::HKL >::size_type":
        return _clipper_python_core.HKLVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_HKLVector
    __del__ = lambda self: None
HKLVector_swigregister = _clipper_python_core.HKLVector_swigregister
HKLVector_swigregister(HKLVector)

class StringVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _clipper_python_core.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _clipper_python_core.StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _clipper_python_core.StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _clipper_python_core.StringVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _clipper_python_core.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _clipper_python_core.StringVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _clipper_python_core.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _clipper_python_core.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _clipper_python_core.StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _clipper_python_core.StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _clipper_python_core.StringVector_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _clipper_python_core.StringVector_append(self, x)

    def empty(self) -> "bool":
        return _clipper_python_core.StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _clipper_python_core.StringVector_size(self)

    def swap(self, v: 'StringVector') -> "void":
        return _clipper_python_core.StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _clipper_python_core.StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _clipper_python_core.StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _clipper_python_core.StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _clipper_python_core.StringVector_rend(self)

    def clear(self) -> "void":
        return _clipper_python_core.StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _clipper_python_core.StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _clipper_python_core.StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _clipper_python_core.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _clipper_python_core.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _clipper_python_core.StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _clipper_python_core.StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _clipper_python_core.StringVector_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _clipper_python_core.StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _clipper_python_core.StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _clipper_python_core.StringVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _clipper_python_core.StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _clipper_python_core.StringVector_capacity(self)
    __swig_destroy__ = _clipper_python_core.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _clipper_python_core.StringVector_swigregister
StringVector_swigregister(StringVector)

class Util(object):
    """


    Utility class.  

    This class holds a set of useful static functions and values. You should never
    need to instantiate this class: Refer to members using Util::  

    C++ includes: clipper_util.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        null constructor  

        """
        this = _clipper_python_core.new_Util()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nan() -> "clipper::ftype const &":
        """


        fast Util::nan() value  

        """
        return _clipper_python_core.Util_nan()

    nan = staticmethod(nan)

    def nanf() -> "float const &":
        """


        fast Util::nan() value  

        """
        return _clipper_python_core.Util_nanf()

    nanf = staticmethod(nanf)

    def nand() -> "double const &":
        """


        fast Util::nan() value  

        """
        return _clipper_python_core.Util_nand()

    nand = staticmethod(nand)

    def set_null(*args) -> "void":
        """


        set null floating value - a specific value of NaN used for missings  

        """
        return _clipper_python_core.Util_set_null(*args)

    set_null = staticmethod(set_null)

    def is_null(*args) -> "bool":
        """


        fast test for null floating value - only works if set from Util::null()  

        """
        return _clipper_python_core.Util_is_null(*args)

    is_null = staticmethod(is_null)

    def is_nan_float(f: 'clipper::ftype32 const') -> "bool":
        """


        fast Util::nan() test  

        Used for missing entries: THIS DOES NOT DISTINGUISH BETWEEN NAN & INF  

        """
        return _clipper_python_core.Util_is_nan_float(f)

    is_nan_float = staticmethod(is_nan_float)

    def is_nan_double(f: 'clipper::ftype64 const') -> "bool":
        """


        fast Util::nan() test  

        Used for missing entries: THIS DOES NOT DISTINGUISH BETWEEN NAN & INF  

        """
        return _clipper_python_core.Util_is_nan_double(f)

    is_nan_double = staticmethod(is_nan_double)

    def isnan(*args) -> "bool":
        """


        slow general NaN test for compatibility  

        Works for all architectures with IEEE arithmetic only  

        """
        return _clipper_python_core.Util_isnan(*args)

    isnan = staticmethod(isnan)

    def sim(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Sim function: I1(X)/I0(X)  

        Parameters
        ----------
        * `x` :  
            The argument  

        Returns
        -------
        I1(x)/I0(x)  

        """
        return _clipper_python_core.Util_sim(x)

    sim = staticmethod(sim)

    def invsim(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Inverse Sim function: I1(X)/I0(X)  

        Parameters
        ----------
        * `x` :  
            I1(y)/I0(y)  

        Returns
        -------
        y  

        """
        return _clipper_python_core.Util_invsim(x)

    invsim = staticmethod(invsim)

    def sim_integ(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Integral of Sim function: log(I0(X))  

        """
        return _clipper_python_core.Util_sim_integ(x)

    sim_integ = staticmethod(sim_integ)

    def sim_deriv(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Derivative of Sim function: d/dx( I1(X)/I0(x) )  

        """
        return _clipper_python_core.Util_sim_deriv(x)

    sim_deriv = staticmethod(sim_deriv)

    def sim_deriv_recur(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Derivative of Sim function using recurrance: -sim(x)/x + (1 - sim(x)^2)  

        """
        return _clipper_python_core.Util_sim_deriv_recur(x)

    sim_deriv_recur = staticmethod(sim_deriv_recur)

    def atanh(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Arc hyperbolic tangent.  

        """
        return _clipper_python_core.Util_atanh(x)

    atanh = staticmethod(atanh)

    def bessel_i0(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Modified Bessel function of the first kind.  

        """
        return _clipper_python_core.Util_bessel_i0(x)

    bessel_i0 = staticmethod(bessel_i0)

    def u2b(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Convert isotropic U-value to B-factor.  

        """
        return _clipper_python_core.Util_u2b(x)

    u2b = staticmethod(u2b)

    def b2u(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        Convert isotropic B-factor to U-value.  

        """
        return _clipper_python_core.Util_b2u(x)

    b2u = staticmethod(b2u)

    def intf(a: 'clipper::ftype const &') -> "int":
        """


        Truncate-to-integer: int(floor(a))  

        """
        return _clipper_python_core.Util_intf(a)

    intf = staticmethod(intf)

    def intc(a: 'clipper::ftype const &') -> "int":
        """


        Truncate-to-integer above: int(ceil(a))  

        """
        return _clipper_python_core.Util_intc(a)

    intc = staticmethod(intc)

    def intr(a: 'clipper::ftype const &') -> "int":
        """


        Round-to-integer: int(round(a))  

        """
        return _clipper_python_core.Util_intr(a)

    intr = staticmethod(intr)

    def mod(*args) -> "int":
        """


        Corrected mod.  

        """
        return _clipper_python_core.Util_mod(*args)

    mod = staticmethod(mod)

    def pi() -> "clipper::ftype const &":
        """


        pi  

        """
        return _clipper_python_core.Util_pi()

    pi = staticmethod(pi)

    def twopi() -> "clipper::ftype const &":
        """


        2 pi  

        """
        return _clipper_python_core.Util_twopi()

    twopi = staticmethod(twopi)

    def twopi2() -> "clipper::ftype const &":
        """


        2 pi squared  

        """
        return _clipper_python_core.Util_twopi2()

    twopi2 = staticmethod(twopi2)

    def eightpi2() -> "clipper::ftype const &":
        """


        8 pi squared  

        """
        return _clipper_python_core.Util_eightpi2()

    eightpi2 = staticmethod(eightpi2)

    def d2rad(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        degree-to-radian conversion  

        Parameters
        ----------
        * `x` :  
            Angle in degrees  

        Returns
        -------
        Angle in radians  

        """
        return _clipper_python_core.Util_d2rad(x)

    d2rad = staticmethod(d2rad)

    def rad2d(x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        degree-to-radian conversion  

        Parameters
        ----------
        * `x` :  
            Angle in radians  

        Returns
        -------
        Angle in degrees  

        """
        return _clipper_python_core.Util_rad2d(x)

    rad2d = staticmethod(rad2d)

    def get_minmax_grid(numpy_2d_in: 'double *', cell: 'Cell', grid: 'Grid_sampling') -> "int [ANY][ANY]":
        """

        Find the minimum and maximum grid coordinates of a box encompassing the
        coordinates in numpy_2d_in given the cell and grid sampling, and return a
        numpy array [min, max].
        """
        return _clipper_python_core.Util_get_minmax_grid(numpy_2d_in, cell, grid)

    get_minmax_grid = staticmethod(get_minmax_grid)
    __swig_destroy__ = _clipper_python_core.delete_Util
    __del__ = lambda self: None
Util_swigregister = _clipper_python_core.Util_swigregister
Util_swigregister(Util)

def Util_nan() -> "clipper::ftype const &":
    """


    fast Util::nan() value  

    """
    return _clipper_python_core.Util_nan()

def Util_nanf() -> "float const &":
    """


    fast Util::nan() value  

    """
    return _clipper_python_core.Util_nanf()

def Util_nand() -> "double const &":
    """


    fast Util::nan() value  

    """
    return _clipper_python_core.Util_nand()

def Util_set_null(*args) -> "void":
    """


    set null floating value - a specific value of NaN used for missings  

    """
    return _clipper_python_core.Util_set_null(*args)

def Util_is_null(*args) -> "bool":
    """


    fast test for null floating value - only works if set from Util::null()  

    """
    return _clipper_python_core.Util_is_null(*args)

def Util_is_nan_float(f: 'clipper::ftype32 const') -> "bool":
    """


    fast Util::nan() test  

    Used for missing entries: THIS DOES NOT DISTINGUISH BETWEEN NAN & INF  

    """
    return _clipper_python_core.Util_is_nan_float(f)

def Util_is_nan_double(f: 'clipper::ftype64 const') -> "bool":
    """


    fast Util::nan() test  

    Used for missing entries: THIS DOES NOT DISTINGUISH BETWEEN NAN & INF  

    """
    return _clipper_python_core.Util_is_nan_double(f)

def Util_isnan(*args) -> "bool":
    """


    slow general NaN test for compatibility  

    Works for all architectures with IEEE arithmetic only  

    """
    return _clipper_python_core.Util_isnan(*args)

def Util_sim(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Sim function: I1(X)/I0(X)  

    Parameters
    ----------
    * `x` :  
        The argument  

    Returns
    -------
    I1(x)/I0(x)  

    """
    return _clipper_python_core.Util_sim(x)

def Util_invsim(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Inverse Sim function: I1(X)/I0(X)  

    Parameters
    ----------
    * `x` :  
        I1(y)/I0(y)  

    Returns
    -------
    y  

    """
    return _clipper_python_core.Util_invsim(x)

def Util_sim_integ(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Integral of Sim function: log(I0(X))  

    """
    return _clipper_python_core.Util_sim_integ(x)

def Util_sim_deriv(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Derivative of Sim function: d/dx( I1(X)/I0(x) )  

    """
    return _clipper_python_core.Util_sim_deriv(x)

def Util_sim_deriv_recur(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Derivative of Sim function using recurrance: -sim(x)/x + (1 - sim(x)^2)  

    """
    return _clipper_python_core.Util_sim_deriv_recur(x)

def Util_atanh(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Arc hyperbolic tangent.  

    """
    return _clipper_python_core.Util_atanh(x)

def Util_bessel_i0(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Modified Bessel function of the first kind.  

    """
    return _clipper_python_core.Util_bessel_i0(x)

def Util_u2b(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Convert isotropic U-value to B-factor.  

    """
    return _clipper_python_core.Util_u2b(x)

def Util_b2u(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    Convert isotropic B-factor to U-value.  

    """
    return _clipper_python_core.Util_b2u(x)

def Util_intf(a: 'clipper::ftype const &') -> "int":
    """


    Truncate-to-integer: int(floor(a))  

    """
    return _clipper_python_core.Util_intf(a)

def Util_intc(a: 'clipper::ftype const &') -> "int":
    """


    Truncate-to-integer above: int(ceil(a))  

    """
    return _clipper_python_core.Util_intc(a)

def Util_intr(a: 'clipper::ftype const &') -> "int":
    """


    Round-to-integer: int(round(a))  

    """
    return _clipper_python_core.Util_intr(a)

def Util_mod(*args) -> "int":
    """


    Corrected mod.  

    """
    return _clipper_python_core.Util_mod(*args)

def Util_pi() -> "clipper::ftype const &":
    """


    pi  

    """
    return _clipper_python_core.Util_pi()

def Util_twopi() -> "clipper::ftype const &":
    """


    2 pi  

    """
    return _clipper_python_core.Util_twopi()

def Util_twopi2() -> "clipper::ftype const &":
    """


    2 pi squared  

    """
    return _clipper_python_core.Util_twopi2()

def Util_eightpi2() -> "clipper::ftype const &":
    """


    8 pi squared  

    """
    return _clipper_python_core.Util_eightpi2()

def Util_d2rad(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    degree-to-radian conversion  

    Parameters
    ----------
    * `x` :  
        Angle in degrees  

    Returns
    -------
    Angle in radians  

    """
    return _clipper_python_core.Util_d2rad(x)

def Util_rad2d(x: 'clipper::ftype const &') -> "clipper::ftype":
    """


    degree-to-radian conversion  

    Parameters
    ----------
    * `x` :  
        Angle in radians  

    Returns
    -------
    Angle in degrees  

    """
    return _clipper_python_core.Util_rad2d(x)

def Util_get_minmax_grid(numpy_2d_in: 'double *', cell: 'Cell', grid: 'Grid_sampling') -> "int [ANY][ANY]":
    """

    Find the minimum and maximum grid coordinates of a box encompassing the
    coordinates in numpy_2d_in given the cell and grid sampling, and return a
    numpy array [min, max].
    """
    return _clipper_python_core.Util_get_minmax_grid(numpy_2d_in, cell, grid)

class String(object):
    """


    String extension with simple parsing methods.  

    String extension with primitive 'split' operation for parsing and pathname
    processing operations.  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        """


        constructor: from double  

        """
        this = _clipper_python_core.new_String(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def split(self, sep: 'String') -> "std::vector< clipper::String,std::allocator< clipper::String > >":
        """


        String splitter - a very simple parser component.  

        """
        return _clipper_python_core.String_split(self, sep)


    def trim(self) -> "clipper::String":
        """


        Return copy of string without leading and trailing blanks.  

        """
        return _clipper_python_core.String_trim(self)


    def tail(self) -> "clipper::String":
        """


        get trailing path element  

        """
        return _clipper_python_core.String_tail(self)


    def head(self) -> "clipper::String":
        """


        remove trailing path element  

        """
        return _clipper_python_core.String_head(self)


    def nohead(self) -> "clipper::String":
        """


        get leading path element  

        """
        return _clipper_python_core.String_nohead(self)


    def notail(self) -> "clipper::String":
        """


        remove leading path element  

        """
        return _clipper_python_core.String_notail(self)


    def i(self) -> "int":
        """


        convert to int  

        """
        return _clipper_python_core.String_i(self)


    def l(self) -> "long":
        """


        convert to long  

        """
        return _clipper_python_core.String_l(self)


    def f32(self) -> "clipper::ftype32":
        """


        convert to float  

        """
        return _clipper_python_core.String_f32(self)


    def f64(self) -> "clipper::ftype64":
        """


        convert to double  

        """
        return _clipper_python_core.String_f64(self)


    def f(self) -> "clipper::ftype":
        """


        convert to ftype  

        """
        return _clipper_python_core.String_f(self)


    def rational(self, *args) -> "clipper::ftype":
        """


        construct string from rational f using base b  

        """
        return _clipper_python_core.String_rational(self, *args)


    def __str__(self) -> "std::string":
        return _clipper_python_core.String___str__(self)

    def __repr__(self) -> "std::string":
        return _clipper_python_core.String___repr__(self)
    __swig_destroy__ = _clipper_python_core.delete_String
    __del__ = lambda self: None
String_swigregister = _clipper_python_core.String_swigregister
String_swigregister(String)

class RTop_frac(object):
    """


    Fractional operator class.  

    This class is used for any RT-operator which operates on fractional coordinates.
    For a full list of methods, see clipper::RTop  

    C++ includes: symop.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from rotation and translation  

        """
        this = _clipper_python_core.new_RTop_frac(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rtop_orth(self, cell: 'Cell') -> "clipper::RTop_orth":
        """


        fractional-orthogonal conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.RTop_frac_rtop_orth(self, cell)


    def inverse(self) -> "clipper::RTop_frac":
        """


        inverse operator  

        Returns
        -------
        The inverse of the operator.  

        """
        return _clipper_python_core.RTop_frac_inverse(self)


    def identity() -> "clipper::RTop_frac":
        """


        return identity operator  

        Returns
        -------
        The identity operator.  

        """
        return _clipper_python_core.RTop_frac_identity()

    identity = staticmethod(identity)

    def null() -> "clipper::RTop_frac":
        """


        return null (uninitialised) operator  

        Returns
        -------
        The null (uninitialised) operator.  

        """
        return _clipper_python_core.RTop_frac_null()

    null = staticmethod(null)

    def __mul__(self, c: 'Coord_frac') -> "Coord_frac":
        return _clipper_python_core.RTop_frac___mul__(self, c)

    def mat44(self) -> "void":
        return _clipper_python_core.RTop_frac_mat44(self)

    def mat34(self) -> "void":
        return _clipper_python_core.RTop_frac_mat34(self)

    def rotation(self) -> "void":
        return _clipper_python_core.RTop_frac_rotation(self)

    def translation(self) -> "void":
        return _clipper_python_core.RTop_frac_translation(self)

    def format(self) -> "clipper::String":
        return _clipper_python_core.RTop_frac_format(self)

    def format_as_symop(self) -> "clipper::String":
        return _clipper_python_core.RTop_frac_format_as_symop(self)

    def __str__(self):
#ifdef PYTHON_PROPERTIES
      return self.format_as_symop
#else
      return self.format_as_symop()
#endif
    def __hash__(self):
      return hash(self.__str__())

    def __eq__(self, other):
      return type(other) == RTop_frac and hash(self) == hash(other)


    mat44 = property(mat44)
    mat34 = property(mat34)
    rotation = property(rotation)
    translation = property(translation)
    format = property(format)
    format_as_symop = property(format_as_symop)

    __swig_destroy__ = _clipper_python_core.delete_RTop_frac
    __del__ = lambda self: None
RTop_frac_swigregister = _clipper_python_core.RTop_frac_swigregister
RTop_frac_swigregister(RTop_frac)

def RTop_frac_identity() -> "clipper::RTop_frac":
    """


    return identity operator  

    Returns
    -------
    The identity operator.  

    """
    return _clipper_python_core.RTop_frac_identity()

def RTop_frac_null() -> "clipper::RTop_frac":
    """


    return null (uninitialised) operator  

    Returns
    -------
    The null (uninitialised) operator.  

    """
    return _clipper_python_core.RTop_frac_null()

class Symop(RTop_frac):
    """


    Crystallographic symmetry operator.  

    This is identical to a fractional RTop, but has its own class since not all
    fractional RTops are symops. For a full list of methods, see clipper::RTop and
    clipper::RTop_frac  

    C++ includes: symop.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from 4x4 matrix  

        Construct a symmetry operator and initialise it to the supplied matrix.
        Translations are rounded to a basis of 48, and put on the range 0..1  

        Parameters
        ----------
        * `mat` :  
            The 4x4 matrix to use. The [i][3] elements contain the translation.  

        """
        this = _clipper_python_core.new_Symop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Return formatted representation of the symmetry operator.  

        Returns
        -------
        The formatted text string, e.g. -x, -y+1/2, z.  

        """
        return _clipper_python_core.Symop_format(self)


    def __mul__(self, c: 'Coord_frac') -> "Coord_frac":
        return _clipper_python_core.Symop___mul__(self, c)

    def __str__(self) -> "std::string":
        return _clipper_python_core.Symop___str__(self)

    def mat44(self) -> "void":
        return _clipper_python_core.Symop_mat44(self)

    def mat34(self) -> "void":
        return _clipper_python_core.Symop_mat34(self)

    def rotation(self) -> "void":
        return _clipper_python_core.Symop_rotation(self)

    def translation(self) -> "void":
        return _clipper_python_core.Symop_translation(self)

    mat44 = property(mat44)
    mat34 = property(mat34)
    rotation = property(rotation)
    translation = property(translation)
    format = property(format)

    __swig_destroy__ = _clipper_python_core.delete_Symop
    __del__ = lambda self: None
Symop_swigregister = _clipper_python_core.Symop_swigregister
Symop_swigregister(Symop)

class Isymop(object):
    """


    Integerised symmetry matrix.  

    This is used for optimised calculations in real and reciprocal space  

    C++ includes: symop.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor  

        Integerised symops are more efficient when handling integer coordinate types,
        e.g. HKL, Coord_grid. The rotation parts of the integerised symop are general
        and can be used for any recirpocal space data. The translation part is specific
        to an individual grid.  

        Parameters
        ----------
        * `symop` :  
            The conventional symop.  
        * `grid` :  
            The specific grid.  

        """
        this = _clipper_python_core.new_Isymop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __mul__(self, *args) -> "clipper::HKL":
        return _clipper_python_core.Isymop___mul__(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_Isymop
    __del__ = lambda self: None
Isymop_swigregister = _clipper_python_core.Isymop_swigregister
Isymop_swigregister(Isymop)

class Symop_code(object):
    """


    Compressed encoded symmetry operator.  

    This is a compresses representation of a crystallographic symmetry operator,
    stored as a single 32-bit integer. It may be converted to or from a symop or an
    int and compared, sorted, etc. The following guarantees are made concerning the
    code:  

    *   The identity operator has a code of zero.  
    *   Operators with non-identity rotations will have higher codes than operators
        with identity rotations, for the same translation.  
    *   Operators with non-zero translations will have higher codes than operators
        with zero translations, for the same rotation.  

    C++ includes: symop.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from Isymop  

        """
        this = _clipper_python_core.new_Symop_code(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, op: 'Isymop') -> "void":
        """


        initialiser: from Isymop  

        """
        return _clipper_python_core.Symop_code_init(self, op)


    def code_rot(self) -> "clipper::Symop_code":
        """


        return code for rotation part  

        """
        return _clipper_python_core.Symop_code_code_rot(self)


    def code_trn(self) -> "clipper::Symop_code":
        """


        return code for translation part  

        """
        return _clipper_python_core.Symop_code_code_trn(self)


    def symop(self) -> "clipper::Symop":
        """


        convert to symop  

        Construct a symmetry operator and initialise it to the matrix encoded in the
        given int.  

        Parameters
        ----------
        * `code` :  
            The integer code.  

        """
        return _clipper_python_core.Symop_code_symop(self)


    def isymop(self) -> "clipper::Isymop":
        """


        convert to integerised symop  

        Construct an integerised symmetry operator and initialise it to the matrix
        encoded in the given int, with a grid (base) of (24,24,24).  

        Parameters
        ----------
        * `code` :  
            The integer code.  

        """
        return _clipper_python_core.Symop_code_isymop(self)


    def identity() -> "clipper::Symop_code":
        """


        identity code  

        """
        return _clipper_python_core.Symop_code_identity()

    identity = staticmethod(identity)
    __swig_destroy__ = _clipper_python_core.delete_Symop_code
    __del__ = lambda self: None
Symop_code_swigregister = _clipper_python_core.Symop_code_swigregister
Symop_code_swigregister(Symop_code)

def Symop_code_identity() -> "clipper::Symop_code":
    """


    identity code  

    """
    return _clipper_python_core.Symop_code_identity()

class SGdata(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    sghash = _swig_property(_clipper_python_core.SGdata_sghash_get, _clipper_python_core.SGdata_sghash_set)
    hall = _swig_property(_clipper_python_core.SGdata_hall_get)
    hm = _swig_property(_clipper_python_core.SGdata_hm_get)
    ext = _swig_property(_clipper_python_core.SGdata_ext_get, _clipper_python_core.SGdata_ext_set)
    num = _swig_property(_clipper_python_core.SGdata_num_get, _clipper_python_core.SGdata_num_set)

    def __init__(self):
        this = _clipper_python_core.new_SGdata()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_SGdata
    __del__ = lambda self: None
SGdata_swigregister = _clipper_python_core.SGdata_swigregister
SGdata_swigregister(SGdata)

class LGdata(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lghash = _swig_property(_clipper_python_core.LGdata_lghash_get, _clipper_python_core.LGdata_lghash_set)
    asufn = _swig_property(_clipper_python_core.LGdata_asufn_get, _clipper_python_core.LGdata_asufn_set)
    lgname = _swig_property(_clipper_python_core.LGdata_lgname_get)

    def __init__(self):
        this = _clipper_python_core.new_LGdata()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_LGdata
    __del__ = lambda self: None
LGdata_swigregister = _clipper_python_core.LGdata_swigregister
LGdata_swigregister(LGdata)

class Spgr_descr(object):
    """


    spacegroup description  

    The spacegroup description is a compact description of a spacegroup. It may be
    initialised from Hall or H-M symbols, a string of symops or a number. Internally
    a hash code is used to refer to the spacegroup, so this object is only 32 bits
    in size.  

    For more details of spacegroup symbols, see Sydney R. Hall & Ralf W. Grosse-
    Kunstleve 'Concise Space-Group Symbols',
    http://www.kristall.ethz.ch/LFK/software/sginfo/hall_symbols.html  

    C++ includes: spacegroup.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Hall = _clipper_python_core.Spgr_descr_Hall
    HM = _clipper_python_core.Spgr_descr_HM
    XHM = _clipper_python_core.Spgr_descr_XHM
    Symops = _clipper_python_core.Spgr_descr_Symops
    Number = _clipper_python_core.Spgr_descr_Number
    Unknown = _clipper_python_core.Spgr_descr_Unknown

    def spacegroup_number(self) -> "int":
        """


        return the spacegroup number  

        The spacegroup number is only available if the spacegroup exists in the internal
        table, see Hall & Grosse-Kunstleve.  

        Returns
        -------
        The spacegroup number, or 0 if unavailable.  

        """
        return _clipper_python_core.Spgr_descr_spacegroup_number(self)


    def symbol_hall(self) -> "clipper::String":
        """


        return the Hall symbol  

        The Hall symbol is only available if the spacegroup exists in the internal
        table, see Hall & Grosse-Kunstleve.  

        Returns
        -------
        The Hall symbol, or "Unknown" if unavailable.  

        """
        return _clipper_python_core.Spgr_descr_symbol_hall(self)


    def symbol_hm(self) -> "clipper::String":
        """


        return the H-M symbol  

        The H-M symbol is only available if the spacegroup exists in the internal table,
        see Hall & Grosse-Kunstleve.  

        Returns
        -------
        The H-M symbol, or "Unknown" if unavailable.  

        """
        return _clipper_python_core.Spgr_descr_symbol_hm(self)


    def symbol_xhm(self) -> "clipper::String":
        """


        return the extended H-M symbol  

        The extended H-M symbol is only available if the spacegroup exists in the
        internal table, see Hall & Grosse-Kunstleve.  

        Returns
        -------
        The extended H-M symbol, or "Unknown" if unavailable.  

        """
        return _clipper_python_core.Spgr_descr_symbol_xhm(self)


    def symbol_hm_ext(self) -> "clipper::String":
        """


        return the extension H-M symbol  

        The extension H-M symbol is only available if the spacegroup exists in the
        internal table, see Hall & Grosse-Kunstleve.  

        Returns
        -------
        The extension H-M symbol, or ""  

        """
        return _clipper_python_core.Spgr_descr_symbol_hm_ext(self)


    def set_preferred(c: 'char const &') -> "void":
        """


        set preferred default spacegroup choice  

        Sets the preferred origin or setting for initialising all Spgr_descr objects
        using H-M symbols or Spacegroup numbers. cctbx uses origin choice '1' by
        default, CCP4 uses '2'. Both packages use 'H' in preference to 'R'. Preferred
        values are stored for both. Defaults are '1' and 'H'.  

        CCP4 users may wish to add the following before using H-M codes or numbers.  

        Parameters
        ----------
        * `c` :  
            Either '1' or '2', 'H' or 'R'.  

        """
        return _clipper_python_core.Spgr_descr_set_preferred(c)

    set_preferred = staticmethod(set_preferred)

    def generator_ops(self) -> "clipper::Spgr_descr::Symop_codes const &":
        """


        return the generators for the spacegroup  

        """
        return _clipper_python_core.Spgr_descr_generator_ops(self)


    def hash(self) -> "unsigned int const &":
        """


        return the hash code for the spacegroup  

        """
        return _clipper_python_core.Spgr_descr_hash(self)


    def __init__(self, *args):
        """


        constructor: from symop list.  

        This is not normally used, except in conjunction with Spgr_desc::generator_ops()
        to derive one group from another.  

        """
        this = _clipper_python_core.new_Spgr_descr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Spgr_descr
    __del__ = lambda self: None
Spgr_descr_swigregister = _clipper_python_core.Spgr_descr_swigregister
Spgr_descr_swigregister(Spgr_descr)
cvar = _clipper_python_core.cvar

def Spgr_descr_set_preferred(c: 'char const &') -> "void":
    """


    set preferred default spacegroup choice  

    Sets the preferred origin or setting for initialising all Spgr_descr objects
    using H-M symbols or Spacegroup numbers. cctbx uses origin choice '1' by
    default, CCP4 uses '2'. Both packages use 'H' in preference to 'R'. Preferred
    values are stored for both. Defaults are '1' and 'H'.  

    CCP4 users may wish to add the following before using H-M codes or numbers.  

    Parameters
    ----------
    * `c` :  
        Either '1' or '2', 'H' or 'R'.  

    """
    return _clipper_python_core.Spgr_descr_set_preferred(c)

class Symop_codes(object):
    """


    Vector of symop codes and associated methods.  

    C++ includes: spacegroup.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init_hall(self, symb: 'String') -> "void":
        """


        initialise from Hall symbol  

        """
        return _clipper_python_core.Symop_codes_init_hall(self, symb)


    def init_symops(self, symb: 'String') -> "void":
        """


        initialise from symops  

        """
        return _clipper_python_core.Symop_codes_init_symops(self, symb)


    def expand(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        expand (incomplete) list of symops  

        """
        return _clipper_python_core.Symop_codes_expand(self)


    def primitive_noninversion_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return primitive non-inversion ops (by computation)  

        """
        return _clipper_python_core.Symop_codes_primitive_noninversion_ops(self)


    def inversion_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return inversion ops (by computation)  

        """
        return _clipper_python_core.Symop_codes_inversion_ops(self)


    def primitive_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return primitive incl inversion ops (by computation)  

        """
        return _clipper_python_core.Symop_codes_primitive_ops(self)


    def centering_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return lattice centering ops (by computation)  

        """
        return _clipper_python_core.Symop_codes_centering_ops(self)


    def laue_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return Laue ops  

        """
        return _clipper_python_core.Symop_codes_laue_ops(self)


    def pgrp_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return point group ops  

        """
        return _clipper_python_core.Symop_codes_pgrp_ops(self)


    def patterson_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return Patterson ops  

        """
        return _clipper_python_core.Symop_codes_patterson_ops(self)


    def generator_ops(self) -> "clipper::Spgr_descr::Symop_codes":
        """


        return minimal list of generator ops  

        """
        return _clipper_python_core.Symop_codes_generator_ops(self)


    def product(self, ops2: 'Symop_codes') -> "clipper::Spgr_descr::Symop_codes":
        """


        return product of this (expanded) list by another (expanded) list  

        """
        return _clipper_python_core.Symop_codes_product(self, ops2)


    def hash(self) -> "unsigned int":
        """


        return hash code of symop list  

        """
        return _clipper_python_core.Symop_codes_hash(self)


    def __init__(self):
        this = _clipper_python_core.new_Symop_codes()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Symop_codes
    __del__ = lambda self: None
Symop_codes_swigregister = _clipper_python_core.Symop_codes_swigregister
Symop_codes_swigregister(Symop_codes)

class Spgr_cacheobj(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, spgr_cachekey: 'Spgr_descr'):
        """


        construct entry  

        """
        this = _clipper_python_core.new_Spgr_cacheobj(spgr_cachekey)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def matches(self, spgr_cachekey: 'Spgr_descr') -> "bool":
        """


        compare entry  

        """
        return _clipper_python_core.Spgr_cacheobj_matches(self, spgr_cachekey)


    def format(self) -> "clipper::String":
        """


        string description  

        """
        return _clipper_python_core.Spgr_cacheobj_format(self)

    spgr_cachekey_ = _swig_property(_clipper_python_core.Spgr_cacheobj_spgr_cachekey__get, _clipper_python_core.Spgr_cacheobj_spgr_cachekey__set)
    nsym = _swig_property(_clipper_python_core.Spgr_cacheobj_nsym_get, _clipper_python_core.Spgr_cacheobj_nsym_set)
    nsymn = _swig_property(_clipper_python_core.Spgr_cacheobj_nsymn_get, _clipper_python_core.Spgr_cacheobj_nsymn_set)
    nsymi = _swig_property(_clipper_python_core.Spgr_cacheobj_nsymi_get, _clipper_python_core.Spgr_cacheobj_nsymi_set)
    nsymc = _swig_property(_clipper_python_core.Spgr_cacheobj_nsymc_get, _clipper_python_core.Spgr_cacheobj_nsymc_set)
    nsymp = _swig_property(_clipper_python_core.Spgr_cacheobj_nsymp_get, _clipper_python_core.Spgr_cacheobj_nsymp_set)
    lgrp = _swig_property(_clipper_python_core.Spgr_cacheobj_lgrp_get, _clipper_python_core.Spgr_cacheobj_lgrp_set)
    symops = _swig_property(_clipper_python_core.Spgr_cacheobj_symops_get, _clipper_python_core.Spgr_cacheobj_symops_set)
    isymops = _swig_property(_clipper_python_core.Spgr_cacheobj_isymops_get, _clipper_python_core.Spgr_cacheobj_isymops_set)
    asu_min_ = _swig_property(_clipper_python_core.Spgr_cacheobj_asu_min__get, _clipper_python_core.Spgr_cacheobj_asu_min__set)
    asu_max_ = _swig_property(_clipper_python_core.Spgr_cacheobj_asu_max__get, _clipper_python_core.Spgr_cacheobj_asu_max__set)
    mutex = _swig_property(_clipper_python_core.Spgr_cacheobj_mutex_get, _clipper_python_core.Spgr_cacheobj_mutex_set)
    __swig_destroy__ = _clipper_python_core.delete_Spgr_cacheobj
    __del__ = lambda self: None
Spgr_cacheobj_swigregister = _clipper_python_core.Spgr_cacheobj_swigregister
Spgr_cacheobj_swigregister(Spgr_cacheobj)

class Spacegroup(Spgr_descr):
    """


    Spacegroup object.  

    The spacegroup object is a full description of a spacegroup, including all the
    most regularly used information in an efficient form. It may be initialised from
    a clipper::Spgr_descr. This object.  

    For more details of spacegroup symbols, see Sydney R. Hall & Ralf W. Grosse-
    Kunstleve 'Concise Space-Group Symbols',
    http://www.kristall.ethz.ch/LFK/software/sginfo/hall_symbols.html  

    C++ includes: spacegroup.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Null = _clipper_python_core.Spacegroup_Null
    P1 = _clipper_python_core.Spacegroup_P1
    A = _clipper_python_core.Spacegroup_A
    B = _clipper_python_core.Spacegroup_B
    C = _clipper_python_core.Spacegroup_C

    def __init__(self, *args):
        """


        constructor: from spacegroup description  

        Construct a spacegroup and initialise with a spacegroup description.  

        Parameters
        ----------
        * `spgr_descr` :  
            The spacegroup description.  

        """
        this = _clipper_python_core.new_Spacegroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, spgr_descr: 'Spgr_descr') -> "void":
        """


        initialiser: from spacegroup description  

        Initialise the spacegroup.  

        Parameters
        ----------
        * `spgr_descr` :  
            The spacegroup description.  

        """
        return _clipper_python_core.Spacegroup_init(self, spgr_descr)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Spacegroup_is_null(self)


    def descr(self) -> "clipper::Spgr_descr const &":
        """


        get spacegroup description  

        """
        return _clipper_python_core.Spacegroup_descr(self)


    def num_symops(self) -> "int const &":
        """


        get number of symops  

        """
        return _clipper_python_core.Spacegroup_num_symops(self)


    def num_primops(self) -> "int const &":
        """


        get number of primitive symops (identical to num_primitive_symops())  

        """
        return _clipper_python_core.Spacegroup_num_primops(self)


    def num_primitive_symops(self) -> "int const &":
        """


        get number of primitive symops (inc identity and inversion)  

        """
        return _clipper_python_core.Spacegroup_num_primitive_symops(self)


    def num_centering_symops(self) -> "int const &":
        """


        get number of centering symops (inc identity)  

        """
        return _clipper_python_core.Spacegroup_num_centering_symops(self)


    def num_inversion_symops(self) -> "int const &":
        """


        get number of inversion symops (inc identity)  

        """
        return _clipper_python_core.Spacegroup_num_inversion_symops(self)


    def num_primitive_noninversion_symops(self) -> "int const &":
        """


        get number of primitive non-inversion symops (inc identity)  

        """
        return _clipper_python_core.Spacegroup_num_primitive_noninversion_symops(self)


    def symop(self, sym_no: 'int const &') -> "clipper::Symop const &":
        """


        get n'th symop  

        """
        return _clipper_python_core.Spacegroup_symop(self, sym_no)


    def primitive_symop(self, sym_no: 'int const &') -> "clipper::Symop const &":
        """


        get n'th primitive symop (identical to symop(sym_no))  

        """
        return _clipper_python_core.Spacegroup_primitive_symop(self, sym_no)


    def inversion_symop(self, sym_no: 'int const &') -> "clipper::Symop const &":
        """


        get n'th inversion symop (0...1 max)  

        """
        return _clipper_python_core.Spacegroup_inversion_symop(self, sym_no)


    def centering_symop(self, sym_no: 'int const &') -> "clipper::Symop const &":
        """


        get n'th centering symop (0...3 max)  

        """
        return _clipper_python_core.Spacegroup_centering_symop(self, sym_no)


    def order_of_symmetry_about_axis(self, axis: 'clipper::Spacegroup::AXIS const') -> "int":
        """


        get the order of rotational symmetry about a given axis  

        The number of rotational operators parallel to the specified axis is returned.  

        Parameters
        ----------
        * `axis` :  
            The axis, A, B or C.  

        Returns
        -------
        The order of the axis.  

        """
        return _clipper_python_core.Spacegroup_order_of_symmetry_about_axis(self, axis)


    def hkl_class(self, hkl: 'HKL') -> "clipper::HKL_class":
        """


        get 'class' of reflection: multiplicity, allowed phase, absence  

        The reflection class describes the type of a reflection in a given spacegroup,
        including centricity, systematic absence, phase restriction, and multiplicity.  

        This is a shortcut to constructing an HKL_class from the spacegroup and HKL.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL  

        """
        return _clipper_python_core.Spacegroup_hkl_class(self, hkl)


    def recip_asu(self, hkl: 'HKL') -> "bool":
        """


        test if hkl is in default reciprocal ASU  

        The reciprocal ASU is chosen from one of 47 optimised functions.  

        Parameters
        ----------
        * `hkl` :  
            The HKL to test.  

        Returns
        -------
        true if the HKL is in the ASU.  

        """
        return _clipper_python_core.Spacegroup_recip_asu(self, hkl)


    def product_op(self, s1: 'int const &', s2: 'int &') -> "int":
        """


        get symop number corresponding to the product of two symops  

        """
        return _clipper_python_core.Spacegroup_product_op(self, s1, s2)


    def inverse_op(self, s: 'int const &') -> "int":
        """


        get symop number corresponding to the inverse of a symop  

        """
        return _clipper_python_core.Spacegroup_inverse_op(self, s)


    def asu_max(self) -> "clipper::Coord_frac":
        """


        get map ASU, upper bound  

        The map ASU is an oblong which contains at least one assymetric unit. It is
        guaranteed to be contained withing the unit box. The lower limit is always
        0,0,0.  

        Returns
        -------
        Fractional coordinate of the upper bound of the ASU.  

        """
        return _clipper_python_core.Spacegroup_asu_max(self)


    def asu_min(self) -> "clipper::Coord_frac":
        """


        get map ASU, lower bound  

        The map ASU is an oblong which contains at least one assymetric unit. It is
        guaranteed to be contained withing the unit box. The lower limit is always
        0,0,0.  

        Returns
        -------
        Fractional coordinate of the lower bound of the ASU.  

        """
        return _clipper_python_core.Spacegroup_asu_min(self)


    def invariant_under_change_of_hand(self) -> "bool":
        """


        test if change of hand preserves spacegroup  

        Test if hand-change is possible.  

        Returns
        -------
        true if a change of hand preserves the spacegroup.  

        """
        return _clipper_python_core.Spacegroup_invariant_under_change_of_hand(self)


    def symbol_laue(self) -> "clipper::String":
        """


        return the Laue group symbol  

        Returns
        -------
        The Laue group symbol. i.e. one of -1, 2/m, 2/mmm, -3, -3m, 4/m, 4/mmm, 6/m,
        6/mmm, m-3, m-3m  

        """
        return _clipper_python_core.Spacegroup_symbol_laue(self)


    def p1() -> "clipper::Spacegroup":
        """


        Return P1 spacegroup.  

        """
        return _clipper_python_core.Spacegroup_p1()

    p1 = staticmethod(p1)

    def null() -> "clipper::Spacegroup":
        """


        Return null spacegroup.  

        """
        return _clipper_python_core.Spacegroup_null()

    null = staticmethod(null)

    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.Spacegroup_debug(self)

    __swig_destroy__ = _clipper_python_core.delete_Spacegroup
    __del__ = lambda self: None
Spacegroup_swigregister = _clipper_python_core.Spacegroup_swigregister
Spacegroup_swigregister(Spacegroup)

def Spacegroup_p1() -> "clipper::Spacegroup":
    """


    Return P1 spacegroup.  

    """
    return _clipper_python_core.Spacegroup_p1()

def Spacegroup_null() -> "clipper::Spacegroup":
    """


    Return null spacegroup.  

    """
    return _clipper_python_core.Spacegroup_null()

class Metric_tensor(object):
    """


    Metric tensor.  

    The metric tensor is used to determine a distance in real or reciprocal space
    using fraction coordinates or Miller indices. It is symmetrical, so only the
    upper triangle is stored with the off-diagonal elements doubled.  

    C++ includes: cell.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: takes parameters of normal or inverse cell  

        Construct and initialise a metric tensor, given a set of real or reciprocal cell
        parameters.  

        Parameters
        ----------
        * `a` :  
            Length of **a** axis in Angstroms or reciprocal Angstroms.  
        * `b` :  
            Length of **b** axis in Angstroms or reciprocal Angstroms.  
        * `c` :  
            Length of **c** axis in Angstroms or reciprocal Angstroms.  
        * `alph` :  
            Angle between **b** and **c** in radians.  
        * `beta` :  
            Angle between **a** and **c** in radians.  
        * `gamm` :  
            Angle between **a** and **b** in radians.  

        """
        this = _clipper_python_core.new_Metric_tensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def lengthsq(self, *args) -> "clipper::ftype":
        """


        apply metric to int vector  

        """
        return _clipper_python_core.Metric_tensor_lengthsq(self, *args)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.Metric_tensor_format(self)

    __swig_destroy__ = _clipper_python_core.delete_Metric_tensor
    __del__ = lambda self: None
Metric_tensor_swigregister = _clipper_python_core.Metric_tensor_swigregister
Metric_tensor_swigregister(Metric_tensor)

class Cell_descr(object):
    """


    cell description (automatically converts to radians)  

    The cell description is a compact description of a cell, containing just the
    cell parameters. It is usually used to construct a full Cell object, which
    provides the expected functionality.  

    C++ includes: cell.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from cell parameters  

        Parameters
        ----------
        * `a` :  
            A axis in Angstroms.  
        * `b` :  
            B axis in Angstroms.  
        * `c` :  
            C axis in Angstroms.  
        * `alpha` :  
            Angle between B and C axes in radians or degrees, default=90  
        * `beta` :  
            Angle between A and C axes in radians or degrees, default=90  
        * `gamma` :  
            Angle between A and C axes in radians or degrees, default=90  

        """
        this = _clipper_python_core.new_Cell_descr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        A string describing the cell  

        """
        return _clipper_python_core.Cell_descr_format(self)


    def dim(self) -> "void":
        return _clipper_python_core.Cell_descr_dim(self)

    def angles(self) -> "void":
        return _clipper_python_core.Cell_descr_angles(self)

    def angles_deg(self) -> "void":
        return _clipper_python_core.Cell_descr_angles_deg(self)

    dim = property(dim)
    angles = property(angles)
    angles_deg = property(angles_deg)

    __swig_destroy__ = _clipper_python_core.delete_Cell_descr
    __del__ = lambda self: None
Cell_descr_swigregister = _clipper_python_core.Cell_descr_swigregister
Cell_descr_swigregister(Cell_descr)

class Cell(Cell_descr):
    """


    Cell object.  

    The Cell class is the fully functional description of the unit cell. In addition
    to the cell parameters, it stores derived information including the cell volume,
    orthogonalising and fractionalising matrices, and the metric tensors.  

    C++ includes: cell.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: takes a Cell descriptor  

        """
        this = _clipper_python_core.new_Cell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, cell_: 'Cell_descr') -> "void":
        """


        initialiser  

        Initialise the Cell object from a cell description.  

        Parameters
        ----------
        * `cell_` :  
            The cell descirption.  

        """
        return _clipper_python_core.Cell_init(self, cell_)


    def volume(self) -> "clipper::ftype const &":
        """


        return cell volume  

        """
        return _clipper_python_core.Cell_volume(self)


    def matrix_orth(self) -> "clipper::Mat33< > const &":
        """


        return orthogonalisation matrix  

        """
        return _clipper_python_core.Cell_matrix_orth(self)


    def matrix_frac(self) -> "clipper::Mat33< > const &":
        """


        return fractionalisation matrix  

        """
        return _clipper_python_core.Cell_matrix_frac(self)


    def metric_real(self) -> "clipper::Metric_tensor const &":
        """


        return real space metric tensor  

        """
        return _clipper_python_core.Cell_metric_real(self)


    def metric_reci(self) -> "clipper::Metric_tensor const &":
        """


        return reciprocal space metric tensor  

        """
        return _clipper_python_core.Cell_metric_reci(self)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.Cell_debug(self)


    def dim(self) -> "void":
        return _clipper_python_core.Cell_dim(self)

    def recip_dim(self) -> "void":
        return _clipper_python_core.Cell_recip_dim(self)

    def angles(self) -> "void":
        return _clipper_python_core.Cell_angles(self)

    def angles_deg(self) -> "void":
        return _clipper_python_core.Cell_angles_deg(self)

    def recip_angles(self) -> "void":
        return _clipper_python_core.Cell_recip_angles(self)

    def recip_angles_deg(self) -> "void":
        return _clipper_python_core.Cell_recip_angles_deg(self)

    def cell_descr(self) -> "clipper::Cell_descr":
        return _clipper_python_core.Cell_cell_descr(self)

    def __eq__(self, other: 'Cell') -> "bool":
        return _clipper_python_core.Cell___eq__(self, other)

    matrix_orth = property(matrix_orth)
    matrix_frac = property(matrix_frac)
    dim = property(dim)
    recip_dim = property(recip_dim)
    angles = property(angles)
    angles_deg = property(angles_deg)
    recip_angles = property(recip_angles)
    recip_angles_deg = property(recip_angles)
    metric_real = property(metric_real)
    metric_reci = property(metric_reci)
    volume = property(volume)
    cell_descr = property(cell_descr)

    __swig_destroy__ = _clipper_python_core.delete_Cell
    __del__ = lambda self: None
Cell_swigregister = _clipper_python_core.Cell_swigregister
Cell_swigregister(Cell)


# The complete list of scatterers found in clipper/core/atomsf.cpp.
# Clipper itself doesn't check incoming atom names for legality, but
# it's easy to do so here in Python. Used by setter methods in Atom and
# Atom_list objects.
ATOM_NAMES = set(
     ['H',  'He', 'Li', 'Be', 'B',  'C',  'N',  'O',  'F',
      'Ne', 'Na', 'Mg', 'Al', 'Si', 'P',  'S',  'Cl', 'Ar',
      'K',  'Ca', 'Sc', 'Ti', 'V',  'Cr', 'Mn', 'Fe', 'Co',
      'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr',
      'Rb', 'Sr', 'Y',  'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh',
      'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I',  'Xe',
      'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu',
      'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf',
      'Ta', 'W',  'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl',
      'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',
      'Pa', 'U',  'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf',
      'H1-',  'Li1+', 'Be2+', 'Cval', 'O1-',  'O2-',  'F1-',
      'Na1+', 'Mg2+', 'Al3+', 'Siva', 'Si4+', 'Cl1-', 'K1+',
      'Ca2+', 'Sc3+', 'Ti2+', 'Ti3+', 'Ti4+', 'V2+',  'V3+',
      'V5+',  'Cr2+', 'Cr3+', 'Mn2+', 'Mn3+', 'Mn4+', 'Fe2+',
      'Fe3+', 'Co2+', 'Co3+', 'Ni2+', 'Ni3+', 'Cu1+', 'Cu2+',
      'Zn2+', 'Ga3+', 'Ge4+', 'Br1-', 'Rb1+', 'Sr2+', 'Y3+',
      'Zr4+', 'Nb3+', 'Nb5+', 'Mo3+', 'Mo5+', 'Mo6+', 'Ru3+',
      'Ru4+', 'Rh3+', 'Rh4+', 'Pd2+', 'Pd4+', 'Ag1+', 'Ag2+',
      'Cd2+', 'In3+', 'Sn2+', 'Sn4+', 'Sb3+', 'Sb5+', 'I1-',
      'Cs1+', 'Ba2+', 'La3+', 'Ce3+', 'Ce4+', 'Pr3+', 'Pr4+',
      'Nd3+', 'Pm3+', 'Sm3+', 'Eu2+', 'Eu3+', 'Gd3+', 'Tb3+',
      'Dy3+', 'Ho3+', 'Er3+', 'Tm3+', 'Yb2+', 'Yb3+', 'Lu3+',
      'Hf4+', 'Ta5+', 'W6+',  'Os4+', 'Ir3+', 'Ir4+', 'Pt2+',
      'Pt4+', 'Au1+', 'Au3+', 'Hg1+', 'Hg2+', 'Tl1+', 'Tl3+',
      'Pb2+', 'Pb4+', 'Bi3+', 'Bi5+', 'Ra2+', 'Ac3+', 'Th4+',
      'U3+',  'U4+',  'U6+',  'Np3+', 'Np4+', 'Np6+', 'Pu3+',
      'Pu4+', 'Pu6+'])




class Resolution(object):
    """


    Resolution in angstroms.  

    This object represents a resolution limit which will be used for all aspects of
    a calculation. This is a base for a donor type.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from ftype  

        Parameters
        ----------
        * `resol_` :  
            The resolution limit in Angstroms.  

        """
        this = _clipper_python_core.new_Resolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, resol_: 'clipper::ftype const &') -> "void":
        """


        initialiser: from ftype  

        Parameters
        ----------
        * `resol_` :  
            The resolution limit in Angstroms.  

        """
        return _clipper_python_core.Resolution_init(self, resol_)


    def limit(self) -> "clipper::ftype const &":
        """


        get resolution limit  

        Returns
        -------
        The resolution limit in Angstroms.  

        """
        return _clipper_python_core.Resolution_limit(self)


    def invresolsq_limit(self) -> "clipper::ftype":
        """


        get invresolsq limit  

        Returns
        -------
        The resolution limit in inverse squared Angstroms.  

        """
        return _clipper_python_core.Resolution_invresolsq_limit(self)


    def is_null(self) -> "bool":
        """


        test if value has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Resolution_is_null(self)

    __swig_destroy__ = _clipper_python_core.delete_Resolution
    __del__ = lambda self: None
Resolution_swigregister = _clipper_python_core.Resolution_swigregister
Resolution_swigregister(Resolution)

class HKL_class(object):
    """


    reflection class  

    This describes the type of a reflection in a given spacegroup, including
    centricity, systematic absence, phase restriction, and multiplicity.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor - from spacegroup and HKL  

        Determine the class of a reflection for a give spacegroup.  

        Parameters
        ----------
        * `spgr` :  
            The spacegroup.  
        * `hkl` :  
            The reflection HKL  

        """
        this = _clipper_python_core.new_HKL_class(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def epsilon(self) -> "clipper::ftype":
        """


        get epsilon  

        """
        return _clipper_python_core.HKL_class_epsilon(self)


    def epsilonc(self) -> "clipper::ftype":
        """


        get epsilon for acentric, 2x epsilon for centric  

        """
        return _clipper_python_core.HKL_class_epsilonc(self)


    def allowed(self) -> "clipper::ftype":
        """


        get allowed phase  

        """
        return _clipper_python_core.HKL_class_allowed(self)


    def centric(self) -> "bool":
        """


        is centric?  

        """
        return _clipper_python_core.HKL_class_centric(self)


    def sys_abs(self) -> "bool":
        """


        is sys abs?  

        """
        return _clipper_python_core.HKL_class_sys_abs(self)

    __swig_destroy__ = _clipper_python_core.delete_HKL_class
    __del__ = lambda self: None
HKL_class_swigregister = _clipper_python_core.HKL_class_swigregister
HKL_class_swigregister(HKL_class)

class RTop_orth(object):
    """


    Orthogonal operator class.  

    This class is used for any RT-operator which operates on orthogonal coordinates.
    For a full list of methods, see clipper::RTop  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from two atom-list type objects  

        Construct the operator which relates one atom-list like object onto another. The
        lists must be the same size, and have the following properties:  

        *   a size() method.  
        *   a [int] operator, with int ranging from 0 to size()-1.  
        *   the object returned by the [] operator must have a coord_orth() method.
            Suitable objects include a vector of Atom, or an Atom_list.  

        """
        this = _clipper_python_core.new_RTop_orth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rtop_frac(self, cell: 'Cell') -> "clipper::RTop_frac":
        """


        orthogonal-fractional conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.RTop_orth_rtop_frac(self, cell)


    def inverse(self) -> "clipper::RTop_orth":
        """


        inverse operator  

        Returns
        -------
        The inverse of the operator.  

        """
        return _clipper_python_core.RTop_orth_inverse(self)


    def axis_coordinate_near(self, centre: 'Coord_orth') -> "clipper::Coord_orth":
        """


        return point on axis near the specified coordinate  

        Parameters
        ----------
        * `centre` :  
            An arbitrary point.  

        Returns
        -------
        point on axis near the specified coordinate, 000 if rotation is zero  

        """
        return _clipper_python_core.RTop_orth_axis_coordinate_near(self, centre)


    def screw_translation(self) -> "clipper::Coord_orth":
        """


        return screw translation  

        Returns
        -------
        screw translation, 000 if rotation is zero  

        """
        return _clipper_python_core.RTop_orth_screw_translation(self)


    def identity() -> "clipper::RTop_orth":
        """


        return identity operator  

        Returns
        -------
        The identity operator.  

        """
        return _clipper_python_core.RTop_orth_identity()

    identity = staticmethod(identity)

    def null() -> "clipper::RTop_orth":
        """


        return null (uninitialised) operator  

        Returns
        -------
        The null (uninitialised) operator.  

        """
        return _clipper_python_core.RTop_orth_null()

    null = staticmethod(null)

    def __mul__(self, c: 'Coord_orth') -> "clipper::Coord_orth":
        return _clipper_python_core.RTop_orth___mul__(self, c)

    def mat44(self) -> "void":
        return _clipper_python_core.RTop_orth_mat44(self)

    def mat34(self) -> "void":
        return _clipper_python_core.RTop_orth_mat34(self)

    def rotation(self) -> "void":
        return _clipper_python_core.RTop_orth_rotation(self)

    def translation(self) -> "void":
        return _clipper_python_core.RTop_orth_translation(self)

    mat44 = property(mat44)
    mat34 = property(mat34)
    rotation = property(rotation)
    translation = property(translation)

    __swig_destroy__ = _clipper_python_core.delete_RTop_orth
    __del__ = lambda self: None
RTop_orth_swigregister = _clipper_python_core.RTop_orth_swigregister
RTop_orth_swigregister(RTop_orth)

def RTop_orth_identity() -> "clipper::RTop_orth":
    """


    return identity operator  

    Returns
    -------
    The identity operator.  

    """
    return _clipper_python_core.RTop_orth_identity()

def RTop_orth_null() -> "clipper::RTop_orth":
    """


    return null (uninitialised) operator  

    Returns
    -------
    The null (uninitialised) operator.  

    """
    return _clipper_python_core.RTop_orth_null()

class HKL(object):
    """


    reflection 'Miller' index  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from H,K,L  

        """
        this = _clipper_python_core.new_HKL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def h(self, *args) -> "int &":
        """


        set h  

        """
        return _clipper_python_core.HKL_h(self, *args)


    def k(self, *args) -> "int &":
        """


        set k  

        """
        return _clipper_python_core.HKL_k(self, *args)


    def l(self, *args) -> "int &":
        """


        set l  

        """
        return _clipper_python_core.HKL_l(self, *args)


    def invresolsq(self, cell: 'Cell') -> "clipper::ftype":
        """


        return inverse resolution squared for this reflection in given cell  

        note: Normally you would get a value through clipper::HKL_info, unless you
            specifically want a value for a different cell.  

        """
        return _clipper_python_core.HKL_invresolsq(self, cell)


    def coord_reci_frac(self) -> "clipper::Coord_reci_frac":
        """


        return fractional reciprocal coordinate (i.e. non-integer HKL)  

        Returns
        -------
        The non-integer coordinate.  

        """
        return _clipper_python_core.HKL_coord_reci_frac(self)


    def coord_reci_orth(self, cell: 'Cell') -> "clipper::Coord_reci_orth":
        """


        orthogonal-fractional reciprocal space coordinate conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.HKL_coord_reci_orth(self, cell)


    def transform(self, *args) -> "clipper::HKL":
        """


        return transformed hkl  

        Optimal version.  

        Parameters
        ----------
        * `op` :  
            The symmetry operator  

        Returns
        -------
        The transformed coordinate  

        """
        return _clipper_python_core.HKL_transform(self, *args)


    def sym_phase_shift(self, op: 'Symop') -> "clipper::ftype":
        """


        return symmetry phase shift for this HKL under op  

        Get the symmetry phase shift incurred when transforming a reflection by this
        operator.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL to transform.  

        Returns
        -------
        The phase shift.  

        """
        return _clipper_python_core.HKL_sym_phase_shift(self, op)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.HKL_format(self)


    def __add__(self, h2: 'HKL') -> "clipper::HKL":
        return _clipper_python_core.HKL___add__(self, h2)

    def __sub__(self, h2: 'HKL') -> "clipper::HKL":
        return _clipper_python_core.HKL___sub__(self, h2)

    def __neg__(self) -> "clipper::HKL":
        return _clipper_python_core.HKL___neg__(self)

    def __mul__(self, m: 'int const &') -> "clipper::HKL":
        return _clipper_python_core.HKL___mul__(self, m)

    def __rmul__(self, m: 'int const &') -> "clipper::HKL":
        return _clipper_python_core.HKL___rmul__(self, m)

    def __eq__(self, h2: 'HKL') -> "bool":
        return _clipper_python_core.HKL___eq__(self, h2)
    __swig_destroy__ = _clipper_python_core.delete_HKL
    __del__ = lambda self: None
HKL_swigregister = _clipper_python_core.HKL_swigregister
HKL_swigregister(HKL)

def neg_HKL(h1: 'HKL') -> "clipper::HKL":
    return _clipper_python_core.neg_HKL(h1)
neg_HKL = _clipper_python_core.neg_HKL

def add_HKL(h1: 'HKL', h2: 'HKL') -> "clipper::HKL":
    return _clipper_python_core.add_HKL(h1, h2)
add_HKL = _clipper_python_core.add_HKL

def subs_HKL(h1: 'HKL', h2: 'HKL') -> "clipper::HKL":
    return _clipper_python_core.subs_HKL(h1, h2)
subs_HKL = _clipper_python_core.subs_HKL

def product_HKL(s: 'int const &', h1: 'HKL') -> "clipper::HKL":
    return _clipper_python_core.product_HKL(s, h1)
product_HKL = _clipper_python_core.product_HKL

def transf_HKL(op: 'Isymop', h1: 'HKL') -> "clipper::HKL":
    return _clipper_python_core.transf_HKL(op, h1)
transf_HKL = _clipper_python_core.transf_HKL

class Coord_reci_orth(object):
    """


    orthogonal reciprocal coordinate (length of which is invresolsq)  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from x*,y*,z*  

        """
        this = _clipper_python_core.new_Coord_reci_orth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def xs(self) -> "clipper::ftype const &":
        """


        get x*  

        """
        return _clipper_python_core.Coord_reci_orth_xs(self)


    def ys(self) -> "clipper::ftype const &":
        """


        get y*  

        """
        return _clipper_python_core.Coord_reci_orth_ys(self)


    def zs(self) -> "clipper::ftype const &":
        """


        get z*  

        """
        return _clipper_python_core.Coord_reci_orth_zs(self)


    def invresolsq(self) -> "clipper::ftype":
        """


        return inverse resolution squared for this coord  

        Returns
        -------
        The inverse resolution squared.  

        """
        return _clipper_python_core.Coord_reci_orth_invresolsq(self)


    def coord_reci_frac(self, cell: 'Cell') -> "clipper::Coord_reci_frac":
        """


        orthogonal-fractional reciprocal space coordinate conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_reci_orth_coord_reci_frac(self, cell)


    def transform(self, op: 'RTop_orth') -> "clipper::Coord_reci_orth":
        """


        return transformed coordinate  

        """
        return _clipper_python_core.Coord_reci_orth_transform(self, op)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Coord_reci_orth_format(self)

    __swig_destroy__ = _clipper_python_core.delete_Coord_reci_orth
    __del__ = lambda self: None
Coord_reci_orth_swigregister = _clipper_python_core.Coord_reci_orth_swigregister
Coord_reci_orth_swigregister(Coord_reci_orth)

class Coord_reci_frac(object):
    """


    fractional reciprocal coordinate (i.e. non-integer hkl)  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from HKL  

        """
        this = _clipper_python_core.new_Coord_reci_frac(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hkl(self) -> "clipper::HKL":
        """


        round to HKL  

        """
        return _clipper_python_core.Coord_reci_frac_hkl(self)


    def invresolsq(self, cell: 'Cell') -> "clipper::ftype":
        """


        return inverse resolution squared for this reflection in given cell  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The inverse resolution squared.  

        """
        return _clipper_python_core.Coord_reci_frac_invresolsq(self, cell)


    def us(self) -> "clipper::ftype const &":
        """


        get u*  

        """
        return _clipper_python_core.Coord_reci_frac_us(self)


    def vs(self) -> "clipper::ftype const &":
        """


        get v*  

        """
        return _clipper_python_core.Coord_reci_frac_vs(self)


    def ws(self) -> "clipper::ftype const &":
        """


        get w*  

        """
        return _clipper_python_core.Coord_reci_frac_ws(self)


    def coord_reci_orth(self, cell: 'Cell') -> "clipper::Coord_reci_orth":
        """


        fractional-orthogonal reciprocal space coordinate conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_reci_frac_coord_reci_orth(self, cell)


    def transform(self, op: 'RTop_frac') -> "clipper::Coord_reci_frac":
        """


        return transformed coordinate  

        """
        return _clipper_python_core.Coord_reci_frac_transform(self, op)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Coord_reci_frac_format(self)

    __swig_destroy__ = _clipper_python_core.delete_Coord_reci_frac
    __del__ = lambda self: None
Coord_reci_frac_swigregister = _clipper_python_core.Coord_reci_frac_swigregister
Coord_reci_frac_swigregister(Coord_reci_frac)

class Coord_grid(object):
    """


    Grid coordinate.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def _u(self) -> "int const &":
        """


        set u  

        """
        return _clipper_python_core.Coord_grid__u(self)


    def _v(self) -> "int const &":
        """


        set v  

        """
        return _clipper_python_core.Coord_grid__v(self)


    def _w(self) -> "int const &":
        """


        set w  

        """
        return _clipper_python_core.Coord_grid__w(self)


    def _u_ptr(self) -> "int &":
        """


        set u  

        """
        return _clipper_python_core.Coord_grid__u_ptr(self)


    def _v_ptr(self) -> "int &":
        """


        set v  

        """
        return _clipper_python_core.Coord_grid__v_ptr(self)


    def _w_ptr(self) -> "int &":
        """


        set w  

        """
        return _clipper_python_core.Coord_grid__w_ptr(self)


    def coord_map(self) -> "clipper::Coord_map":
        """


        convert to Coord_map  

        Returns
        -------
        The non-integer coordinate.  

        """
        return _clipper_python_core.Coord_grid_coord_map(self)


    def coord_frac(self, g: 'Grid_sampling') -> "clipper::Coord_frac":
        """


        convert to Coord_frac using given Grid_sampling  

        Fractional coordinate is not normalised onto range 0..1  

        Parameters
        ----------
        * `g` :  
            The grid concerned  

        Returns
        -------
        The fractional coordinate  

        """
        return _clipper_python_core.Coord_grid_coord_frac(self, g)


    def transform(self, op: 'Isymop') -> "clipper::Coord_grid":
        """


        return transformed coordinate  

        """
        return _clipper_python_core.Coord_grid_transform(self, op)


    def unit(self, g: 'Grid_sampling') -> "clipper::Coord_grid":
        """


        reduce to unit box: (0..nu-1, 0..nv-1, 0..nw-1)  

        Parameters
        ----------
        * `g` :  
            The grid concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_grid_unit(self, g)


    def next(self, *args) -> "clipper::Coord_grid const &":
        """


        increment in storage order (see index())  

        guaranteed to increment index(g) by 1  

        The grid coordinate is incremented efficiently in a manner which is exaclty
        equivalent to increasing index() by 1 in a non-zero based grid.  

        Parameters
        ----------
        * `g` :  
            The grid with which this increment is synchronised.  

        """
        return _clipper_python_core.Coord_grid_next(self, *args)


    def last(self, *args) -> "bool":
        """


        test if done in storage order (see index())  

        Test whether this coordinate has been incremented using next() beyond the end of
        the specified non-zero based grid.  

        Parameters
        ----------
        * `g` :  
            The grid concerned.  

        """
        return _clipper_python_core.Coord_grid_last(self, *args)


    def index(self, g: 'Grid') -> "int":
        """


        grid indexing operator  

        Return the index in a 1-d array corresponding to this coordinate for a zero
        based grid.  

        Parameters
        ----------
        * `g` :  
            The grid concerned.  

        Returns
        -------
        The corresponding index.  

        """
        return _clipper_python_core.Coord_grid_index(self, g)


    def deindex(self, g: 'Grid', index: 'int const &') -> "void":
        """


        grid deindexing operator  

        Return the coordinate corresponding to a given index in a zero based grid.  

        Parameters
        ----------
        * `g` :  
            The grid concerned.  

        Returns
        -------
        The corresponding coordinate.  

        """
        return _clipper_python_core.Coord_grid_deindex(self, g, index)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Coord_grid_format(self)


    def __init__(self, *args):
        """


        constructor: from a grid and an index in that grid  

        """
        this = _clipper_python_core.new_Coord_grid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __ne__(self, g2: 'Coord_grid') -> "bool":
        return _clipper_python_core.Coord_grid___ne__(self, g2)

    def __eq__(self, g2: 'Coord_grid') -> "bool":
        return _clipper_python_core.Coord_grid___eq__(self, g2)

    def __add_base__(self, g2: 'Coord_grid') -> "clipper::Coord_grid":
        return _clipper_python_core.Coord_grid___add_base__(self, g2)

    def __neg__(self) -> "clipper::Coord_grid":
        return _clipper_python_core.Coord_grid___neg__(self)

    def __sub_base__(self, g2: 'Coord_grid') -> "clipper::Coord_grid":
        return _clipper_python_core.Coord_grid___sub_base__(self, g2)

    def __mul__(self, m: 'int const &') -> "clipper::Coord_grid":
        return _clipper_python_core.Coord_grid___mul__(self, m)

    def __rmul__(self, m: 'int const &') -> "clipper::Coord_grid":
        return _clipper_python_core.Coord_grid___rmul__(self, m)

    def __str__(self) -> "std::string":
        return _clipper_python_core.Coord_grid___str__(self)

    def __repr__(self) -> "std::string":
        return _clipper_python_core.Coord_grid___repr__(self)

    @staticmethod
    @safesplat_int
    def _new_coord_grid(u, v, w):
        return Coord_grid(u, v, w)

    def __add__(self, other):
      '''
      This __add__ function should allow you to add any iterable of three
      ints to your Coord_grid object, as long as your sum is written
            Coord_grid + other_iterable
      Note that the reverse:
            other_iterable + Coord_grid
      ... will not work if other_iterable is a Numpy array, since the
      numpy.ndarray __add__() function takes precedence and attempts to
      do:
        [other_iterable[0]+Coord_grid, other_iterable[1]+Coord_grid, ...]
      For this reason, it is probably best to leave the __radd__ function
      unimplemented.
      '''
      try:
        return self.__add_base__(other)
      except:
        return self + self._new_coord_grid(other)

    def __sub__(self, other):
      try:
        return self.__sub_base__(other)
      except:
        return self - self._new_coord_grid(other)



    def _get_uvw(self) -> "void":
        return _clipper_python_core.Coord_grid__get_uvw(self)

    def _set_uvw(self, v: 'long [3]') -> "void":
        return _clipper_python_core.Coord_grid__set_uvw(self, v)

    uvw = property(_get_uvw, _set_uvw)

    __swig_destroy__ = _clipper_python_core.delete_Coord_grid
    __del__ = lambda self: None
Coord_grid_swigregister = _clipper_python_core.Coord_grid_swigregister
Coord_grid_swigregister(Coord_grid)

def neg_Coord_grid(r1: 'Coord_grid') -> "clipper::Coord_grid":
    return _clipper_python_core.neg_Coord_grid(r1)
neg_Coord_grid = _clipper_python_core.neg_Coord_grid

def add_Coord_grid(r1: 'Coord_grid', r2: 'Coord_grid') -> "clipper::Coord_grid":
    return _clipper_python_core.add_Coord_grid(r1, r2)
add_Coord_grid = _clipper_python_core.add_Coord_grid

def subs_Coord_grid(r1: 'Coord_grid', r2: 'Coord_grid') -> "clipper::Coord_grid":
    return _clipper_python_core.subs_Coord_grid(r1, r2)
subs_Coord_grid = _clipper_python_core.subs_Coord_grid

def product_Coord_grid(s: 'int const &', r1: 'Coord_grid') -> "clipper::Coord_grid":
    return _clipper_python_core.product_Coord_grid(s, r1)
product_Coord_grid = _clipper_python_core.product_Coord_grid

def equals_Coord_grid(r1: 'Coord_grid', r2: 'Coord_grid') -> "int":
    return _clipper_python_core.equals_Coord_grid(r1, r2)
equals_Coord_grid = _clipper_python_core.equals_Coord_grid

def notequals_Coord_grid(r1: 'Coord_grid', r2: 'Coord_grid') -> "int":
    return _clipper_python_core.notequals_Coord_grid(r1, r2)
notequals_Coord_grid = _clipper_python_core.notequals_Coord_grid

def transf_Coord_grid(op: 'Isymop', r1: 'Coord_grid') -> "clipper::Coord_grid":
    return _clipper_python_core.transf_Coord_grid(op, r1)
transf_Coord_grid = _clipper_python_core.transf_Coord_grid

class Coord_orth(object):
    """


    orthogonal (Angstrom) coordinates  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        """


        constructor: from 3 coords and bond length, angle, torsion  

        The coordinate is calculated which extends the sequence of coordinates x1, x2,
        x3 with the specified distance to x3, angle to x2,x3, and torsion to x1,x2,x3.  

        Parameters
        ----------
        * `x1` :  
            First coordinate.  
        * `x2` :  
            Second coordinate.  
        * `x3` :  
            Third coordinate.  
        * `length` :  
            x3-new bond length in Angstroms.  
        * `angle` :  
            x2-x3-new opening angle in Radians.  
        * `torsion` :  
            x1-x2-x3-new torsion angle in Radians.  

        """
        this = _clipper_python_core.new_Coord_orth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _x(self) -> "clipper::ftype const &":
        """


        get x  

        """
        return _clipper_python_core.Coord_orth__x(self)


    def _y(self) -> "clipper::ftype const &":
        """


        get y  

        """
        return _clipper_python_core.Coord_orth__y(self)


    def _z(self) -> "clipper::ftype const &":
        """


        get z  

        """
        return _clipper_python_core.Coord_orth__z(self)


    def lengthsq(self) -> "clipper::ftype":
        """


        return square of length of vector in Angstroms  

        Returns
        -------
        The squared length in Angstroms squared  

        """
        return _clipper_python_core.Coord_orth_lengthsq(self)


    def coord_frac(self, cell: 'Cell') -> "clipper::Coord_frac":
        """


        orthogonal-fractional coordinate conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_orth_coord_frac(self, cell)


    def transform(self, op: 'RTop_orth') -> "clipper::Coord_orth":
        """


        return transformed coordinate  

        """
        return _clipper_python_core.Coord_orth_transform(self, op)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Coord_orth_format(self)


    def length(x1: 'Coord_orth', x2: 'Coord_orth') -> "clipper::ftype":
        """


        Return length of vector between two coord orths.  

        Returns
        -------
        The bond length x1-x2 in Angstroms.  

        """
        return _clipper_python_core.Coord_orth_length(x1, x2)

    length = staticmethod(length)

    def angle(x1: 'Coord_orth', x2: 'Coord_orth', x3: 'Coord_orth') -> "clipper::ftype":
        """


        Return angle between three coord orths.  

        Returns
        -------
        The bond angle x1-x2-x3 in Radians.  

        """
        return _clipper_python_core.Coord_orth_angle(x1, x2, x3)

    angle = staticmethod(angle)

    def torsion(x1: 'Coord_orth', x2: 'Coord_orth', x3: 'Coord_orth', x4: 'Coord_orth') -> "clipper::ftype":
        """


        Return torsion between four coord orths.  

        Returns
        -------
        The bond torsion x1-x2-x3-x4 in Radians.  

        """
        return _clipper_python_core.Coord_orth_torsion(x1, x2, x3, x4)

    torsion = staticmethod(torsion)

    def __add_base__(self, h2: 'Coord_orth') -> "clipper::Coord_orth":
        return _clipper_python_core.Coord_orth___add_base__(self, h2)

    def __sub_base__(self, h2: 'Coord_orth') -> "clipper::Coord_orth":
        return _clipper_python_core.Coord_orth___sub_base__(self, h2)

    def __neg__(self) -> "clipper::Coord_orth":
        return _clipper_python_core.Coord_orth___neg__(self)

    def __mul__(self, f: 'double const &') -> "clipper::Coord_orth":
        return _clipper_python_core.Coord_orth___mul__(self, f)

    def __rmul__(self, f: 'double const &') -> "clipper::Coord_orth":
        return _clipper_python_core.Coord_orth___rmul__(self, f)

    def __str__(self) -> "std::string":
        return _clipper_python_core.Coord_orth___str__(self)

    def __repr__(self) -> "std::string":
        return _clipper_python_core.Coord_orth___repr__(self)

    @staticmethod
    @safesplat_float
    def _new_coord_orth(x, y, z):
        return Coord_orth(x, y, z)

    def __add__(self, other):
      '''
      This __add__ function should allow you to add any iterable of three
      numbers to your Coord_orth object, as long as your sum is written
            Coord_orth + other_iterable
      Note that the reverse:
            other_iterable + Coord_orth
      ... will not work if other_iterable is a Numpy array, since the
      numpy.ndarray __add__() function takes precedence and attempts to
      do:
        [other_iterable[0]+Coord_orth, other_iterable[1]+Coord_orth, ...]
      For this reason, it is probably best to leave the __radd__ and
      __rsub__ functions unimplemented.
      '''
      try:
        return self.__add_base__(other)
      except:
        return self + self._new_coord_orth(other)

    def __sub__(self, other):
      try:
        return self.__sub_base__(other)
      except:
        return self - self._new_coord_orth(other)



    def _get_xyz(self) -> "void":
        return _clipper_python_core.Coord_orth__get_xyz(self)

    xyz = property(_get_xyz)

    __swig_destroy__ = _clipper_python_core.delete_Coord_orth
    __del__ = lambda self: None
Coord_orth_swigregister = _clipper_python_core.Coord_orth_swigregister
Coord_orth_swigregister(Coord_orth)

def Coord_orth_length(x1: 'Coord_orth', x2: 'Coord_orth') -> "clipper::ftype":
    """


    Return length of vector between two coord orths.  

    Returns
    -------
    The bond length x1-x2 in Angstroms.  

    """
    return _clipper_python_core.Coord_orth_length(x1, x2)

def Coord_orth_angle(x1: 'Coord_orth', x2: 'Coord_orth', x3: 'Coord_orth') -> "clipper::ftype":
    """


    Return angle between three coord orths.  

    Returns
    -------
    The bond angle x1-x2-x3 in Radians.  

    """
    return _clipper_python_core.Coord_orth_angle(x1, x2, x3)

def Coord_orth_torsion(x1: 'Coord_orth', x2: 'Coord_orth', x3: 'Coord_orth', x4: 'Coord_orth') -> "clipper::ftype":
    """


    Return torsion between four coord orths.  

    Returns
    -------
    The bond torsion x1-x2-x3-x4 in Radians.  

    """
    return _clipper_python_core.Coord_orth_torsion(x1, x2, x3, x4)

def neg_Coord_orth(x1: 'Coord_orth') -> "clipper::Coord_orth":
    return _clipper_python_core.neg_Coord_orth(x1)
neg_Coord_orth = _clipper_python_core.neg_Coord_orth

def add_Coord_orth(x1: 'Coord_orth', x2: 'Coord_orth') -> "clipper::Coord_orth":
    return _clipper_python_core.add_Coord_orth(x1, x2)
add_Coord_orth = _clipper_python_core.add_Coord_orth

def subs_Coord_orth(x1: 'Coord_orth', x2: 'Coord_orth') -> "clipper::Coord_orth":
    return _clipper_python_core.subs_Coord_orth(x1, x2)
subs_Coord_orth = _clipper_python_core.subs_Coord_orth

def product_Coord_orth(s: 'clipper::ftype const &', x1: 'Coord_orth') -> "clipper::Coord_orth":
    return _clipper_python_core.product_Coord_orth(s, x1)
product_Coord_orth = _clipper_python_core.product_Coord_orth

def transf_Coord_orth(op: 'RTop_orth', x1: 'Coord_orth') -> "clipper::Coord_orth":
    return _clipper_python_core.transf_Coord_orth(op, x1)
transf_Coord_orth = _clipper_python_core.transf_Coord_orth

class Coord_frac(object):
    """


    fractional (cell) coordinates  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        """


        constructor: from u,v,w  

        """
        this = _clipper_python_core.new_Coord_frac(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _u(self) -> "clipper::ftype const &":
        """


        get u  

        """
        return _clipper_python_core.Coord_frac__u(self)


    def _v(self) -> "clipper::ftype const &":
        """


        get v  

        """
        return _clipper_python_core.Coord_frac__v(self)


    def _w(self) -> "clipper::ftype const &":
        """


        get w  

        """
        return _clipper_python_core.Coord_frac__w(self)


    def lengthsq(self, cell: 'Cell') -> "clipper::ftype":
        """


        return square of length of vector in Angstroms  

        Returns
        -------
        The squared length in Angstroms squared  

        """
        return _clipper_python_core.Coord_frac_lengthsq(self, cell)


    def coord_orth(self, cell: 'Cell') -> "clipper::Coord_orth":
        """


        fractional-orthogonal coordinate conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_frac_coord_orth(self, cell)


    def coord_map(self, g: 'Grid') -> "clipper::Coord_map":
        """


        fractional-grid coordinate conversion  

        Parameters
        ----------
        * `g` :  
            The grid concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_frac_coord_map(self, g)


    def coord_grid(self, g: 'Grid') -> "clipper::Coord_grid":
        """


        fractional-grid coordinate conversion  

        Parameters
        ----------
        * `g` :  
            The grid concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_frac_coord_grid(self, g)


    def transform(self, op: 'RTop_frac') -> "clipper::Coord_frac":
        """


        return transformed coordinate  

        """
        return _clipper_python_core.Coord_frac_transform(self, op)


    def lattice_copy_zero(self) -> "clipper::Coord_frac":
        """


        return lattice copy nearest origin  

        """
        return _clipper_python_core.Coord_frac_lattice_copy_zero(self)


    def lattice_copy_unit(self) -> "clipper::Coord_frac":
        """


        return lattice copy in unit box (0...1,0...1,0...1)  

        """
        return _clipper_python_core.Coord_frac_lattice_copy_unit(self)


    def lattice_copy_near(self, n: 'Coord_frac') -> "clipper::Coord_frac":
        """


        return lattice copy near the specified coordinate  

        """
        return _clipper_python_core.Coord_frac_lattice_copy_near(self, n)


    def symmetry_copy_near(self, spgr: 'Spacegroup', cell: 'Cell', n: 'Coord_frac') -> "clipper::Coord_frac":
        """


        return symmetry copy near the specified coordinate  

        """
        return _clipper_python_core.Coord_frac_symmetry_copy_near(self, spgr, cell, n)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Coord_frac_format(self)


    def __add_base__(self, h2: 'Coord_frac') -> "clipper::Coord_frac":
        return _clipper_python_core.Coord_frac___add_base__(self, h2)

    def __sub_base__(self, h2: 'Coord_frac') -> "clipper::Coord_frac":
        return _clipper_python_core.Coord_frac___sub_base__(self, h2)

    def __neg__(self) -> "clipper::Coord_frac":
        return _clipper_python_core.Coord_frac___neg__(self)

    def __mul__(self, f: 'double const &') -> "clipper::Coord_frac":
        return _clipper_python_core.Coord_frac___mul__(self, f)

    def __rmul__(self, f: 'double const &') -> "clipper::Coord_frac":
        return _clipper_python_core.Coord_frac___rmul__(self, f)

    def __str__(self) -> "std::string":
        return _clipper_python_core.Coord_frac___str__(self)

    def __repr__(self) -> "std::string":
        return _clipper_python_core.Coord_frac___repr__(self)

    def _get_uvw(self) -> "void":
        return _clipper_python_core.Coord_frac__get_uvw(self)

    @staticmethod
    @safesplat_float
    def _new_coord_frac(u, v, w):
        return Coord_frac(u, v, w)

    def __add__(self, other):
      try:
        return self.__add_base__(other)
      except:
        return self + self._new_coord_frac(other)

    def __sub__(self, other):
      try:
        return self.__sub_base__(other)
      except:
        return self - self._new_coord_frac(other)



    uvw = property(_get_uvw)

    __swig_destroy__ = _clipper_python_core.delete_Coord_frac
    __del__ = lambda self: None
Coord_frac_swigregister = _clipper_python_core.Coord_frac_swigregister
Coord_frac_swigregister(Coord_frac)

def neg_Coord_frac(u1: 'Coord_frac') -> "clipper::Coord_frac":
    return _clipper_python_core.neg_Coord_frac(u1)
neg_Coord_frac = _clipper_python_core.neg_Coord_frac

def add_Coord_frac(u1: 'Coord_frac', u2: 'Coord_frac') -> "clipper::Coord_frac":
    return _clipper_python_core.add_Coord_frac(u1, u2)
add_Coord_frac = _clipper_python_core.add_Coord_frac

def subs_Coord_frac(u1: 'Coord_frac', u2: 'Coord_frac') -> "clipper::Coord_frac":
    return _clipper_python_core.subs_Coord_frac(u1, u2)
subs_Coord_frac = _clipper_python_core.subs_Coord_frac

def product_Coord_frac(s: 'clipper::ftype const &', u1: 'Coord_frac') -> "clipper::Coord_frac":
    return _clipper_python_core.product_Coord_frac(s, u1)
product_Coord_frac = _clipper_python_core.product_Coord_frac

def transf_Coord_frac(op: 'RTop_frac', x1: 'Coord_frac') -> "clipper::Coord_frac":
    return _clipper_python_core.transf_Coord_frac(op, x1)
transf_Coord_frac = _clipper_python_core.transf_Coord_frac

class Coord_map(object):
    """


    map coordinate: this is like Coord_grid, but non-integer  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        """


        constructor: from u,v,w  

        """
        this = _clipper_python_core.new_Coord_map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def coord_frac(self, g: 'Grid') -> "clipper::Coord_frac":
        """


        grid-fractional coordinate conversion  

        Parameters
        ----------
        * `g` :  
            The grid concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.Coord_map_coord_frac(self, g)


    def coord_grid(self) -> "clipper::Coord_grid":
        """


        return integer Coord_grid nearest this coordinate  

        """
        return _clipper_python_core.Coord_map_coord_grid(self)


    def floor(self) -> "clipper::Coord_grid":
        """


        return integer Coord_grid below this coordinate  

        """
        return _clipper_python_core.Coord_map_floor(self)


    def ceil(self) -> "clipper::Coord_grid":
        """


        return integer Coord_grid above this coordinate  

        """
        return _clipper_python_core.Coord_map_ceil(self)


    def _u(self) -> "clipper::ftype const &":
        """


        get u  

        """
        return _clipper_python_core.Coord_map__u(self)


    def _v(self) -> "clipper::ftype const &":
        """


        get v  

        """
        return _clipper_python_core.Coord_map__v(self)


    def _w(self) -> "clipper::ftype const &":
        """


        get w  

        """
        return _clipper_python_core.Coord_map__w(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Coord_map_format(self)


    def __add_base__(self, h2: 'Coord_map') -> "clipper::Coord_map":
        return _clipper_python_core.Coord_map___add_base__(self, h2)

    def __sub_base__(self, h2: 'Coord_map') -> "clipper::Coord_map":
        return _clipper_python_core.Coord_map___sub_base__(self, h2)

    def __neg__(self) -> "clipper::Coord_map":
        return _clipper_python_core.Coord_map___neg__(self)

    def __mul__(self, f: 'double const &') -> "clipper::Coord_map":
        return _clipper_python_core.Coord_map___mul__(self, f)

    def __rmul__(self, f: 'double const &') -> "clipper::Coord_map":
        return _clipper_python_core.Coord_map___rmul__(self, f)

    def __str__(self) -> "std::string":
        return _clipper_python_core.Coord_map___str__(self)

    def __repr__(self) -> "std::string":
        return _clipper_python_core.Coord_map___repr__(self)

    @staticmethod
    @safesplat_float
    def _new_coord_map(u, v, w):
        return Coord_orth(u, v, w)

    def __add__(self, other):
      try:
        return self.__add_base__(other)
      except:
        return self + self._new_coord_map(other)

    def __sub__(self, other):
      try:
        return self.__sub_base__(other)
      except:
        return self - self._new_coord_map(other)



    def _get_uvw(self) -> "void":
        return _clipper_python_core.Coord_map__get_uvw(self)

    uvw = property(_get_uvw)
    ceil = property(ceil)
    coord_grid = property(coord_grid)
    floor = property(floor)

    __swig_destroy__ = _clipper_python_core.delete_Coord_map
    __del__ = lambda self: None
Coord_map_swigregister = _clipper_python_core.Coord_map_swigregister
Coord_map_swigregister(Coord_map)

def neg_Coord_map(u1: 'Coord_map') -> "clipper::Coord_map":
    return _clipper_python_core.neg_Coord_map(u1)
neg_Coord_map = _clipper_python_core.neg_Coord_map

def add_Coord_map(u1: 'Coord_map', u2: 'Coord_map') -> "clipper::Coord_map":
    return _clipper_python_core.add_Coord_map(u1, u2)
add_Coord_map = _clipper_python_core.add_Coord_map

def subs_Coord_map(u1: 'Coord_map', u2: 'Coord_map') -> "clipper::Coord_map":
    return _clipper_python_core.subs_Coord_map(u1, u2)
subs_Coord_map = _clipper_python_core.subs_Coord_map

def product_Coord_map(s: 'clipper::ftype const &', u1: 'Coord_map') -> "clipper::Coord_map":
    return _clipper_python_core.product_Coord_map(s, u1)
product_Coord_map = _clipper_python_core.product_Coord_map

class U_aniso_orth(object):
    """


    Anisotropic orthogonal atomic displacement parameters.  

    These are defined on orthogonal atomic coordinates in A-2, i.e. they are
    anisotropic U values.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from Uij  

        """
        this = _clipper_python_core.new_U_aniso_orth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def u_iso(self) -> "clipper::ftype":
        """


        return nearest isotropic U  

        The best isotropic U is the cube root of the determinant of the matrix of
        anisotropic coefficients. NOTE: This is not the conventional definition, but the
        mathematically correct one, and gives a better approximation to the anisotropic
        U (i.e. lower R-factors).  

        Returns
        -------
        The nearest isotropic U.  

        """
        return _clipper_python_core.U_aniso_orth_u_iso(self)


    def u_aniso_frac(self, cell: 'Cell') -> "clipper::U_aniso_frac":
        """


        orthogonal-fractional conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.U_aniso_orth_u_aniso_frac(self, cell)


    def transform(self, op: 'RTop_orth') -> "clipper::U_aniso_orth":
        """


        return transformed U_aniso  

        The aniso U is transformed by the given RT op.  

        Parameters
        ----------
        * `u` :  
            The aniso U.  

        """
        return _clipper_python_core.U_aniso_orth_transform(self, op)


    def __add__(self, u2: 'U_aniso_orth') -> "clipper::U_aniso_orth":
        return _clipper_python_core.U_aniso_orth___add__(self, u2)

    def __sub__(self, u2: 'U_aniso_orth') -> "clipper::U_aniso_orth":
        return _clipper_python_core.U_aniso_orth___sub__(self, u2)

    def __neg__(self) -> "clipper::U_aniso_orth":
        return _clipper_python_core.U_aniso_orth___neg__(self)

    def __mul__(self, f: 'double const &') -> "clipper::U_aniso_orth":
        return _clipper_python_core.U_aniso_orth___mul__(self, f)

    def __rmul__(self, f: 'double const &') -> "clipper::U_aniso_orth":
        return _clipper_python_core.U_aniso_orth___rmul__(self, f)

    def _get_vals(self) -> "void":
        return _clipper_python_core.U_aniso_orth__get_vals(self)
    __swig_destroy__ = _clipper_python_core.delete_U_aniso_orth
    __del__ = lambda self: None
U_aniso_orth_swigregister = _clipper_python_core.U_aniso_orth_swigregister
U_aniso_orth_swigregister(U_aniso_orth)

def add_U_aniso_orth(u1: 'U_aniso_orth', u2: 'U_aniso_orth') -> "clipper::U_aniso_orth":
    return _clipper_python_core.add_U_aniso_orth(u1, u2)
add_U_aniso_orth = _clipper_python_core.add_U_aniso_orth

def neg_U_aniso_orth(u: 'U_aniso_orth') -> "clipper::U_aniso_orth":
    return _clipper_python_core.neg_U_aniso_orth(u)
neg_U_aniso_orth = _clipper_python_core.neg_U_aniso_orth

def product_U_aniso_orth(s: 'clipper::ftype const &', u: 'U_aniso_orth') -> "clipper::U_aniso_orth":
    return _clipper_python_core.product_U_aniso_orth(s, u)
product_U_aniso_orth = _clipper_python_core.product_U_aniso_orth

class U_aniso_frac(object):
    """


    Anisotropic fractional atomic displacement parameters.  

    These are defined on fractional atomic coordinates in A-2, i.e. they are
    anisotropic U values.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from Uij  

        """
        this = _clipper_python_core.new_U_aniso_frac(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def u_aniso_orth(self, cell: 'Cell') -> "clipper::U_aniso_orth":
        """


        fractional-orthogonal conversion  

        Parameters
        ----------
        * `cell` :  
            The cell concerned  

        Returns
        -------
        The transformed coordinate.  

        """
        return _clipper_python_core.U_aniso_frac_u_aniso_orth(self, cell)


    def transform(self, op: 'RTop_frac') -> "clipper::U_aniso_frac":
        """


        return transformed U_aniso  

        The aniso U is transformed by the given RT op.  

        Parameters
        ----------
        * `u` :  
            The aniso U.  

        """
        return _clipper_python_core.U_aniso_frac_transform(self, op)


    def __add__(self, u2: 'U_aniso_frac') -> "clipper::U_aniso_frac":
        return _clipper_python_core.U_aniso_frac___add__(self, u2)

    def __sub__(self, u2: 'U_aniso_frac') -> "clipper::U_aniso_frac":
        return _clipper_python_core.U_aniso_frac___sub__(self, u2)

    def __neg__(self) -> "clipper::U_aniso_frac":
        return _clipper_python_core.U_aniso_frac___neg__(self)

    def __mul__(self, f: 'double const &') -> "clipper::U_aniso_frac":
        return _clipper_python_core.U_aniso_frac___mul__(self, f)

    def __rmul__(self, f: 'double const &') -> "clipper::U_aniso_frac":
        return _clipper_python_core.U_aniso_frac___rmul__(self, f)

    def _get_vals(self) -> "void":
        return _clipper_python_core.U_aniso_frac__get_vals(self)
    __swig_destroy__ = _clipper_python_core.delete_U_aniso_frac
    __del__ = lambda self: None
U_aniso_frac_swigregister = _clipper_python_core.U_aniso_frac_swigregister
U_aniso_frac_swigregister(U_aniso_frac)

def add_U_aniso_frac(u1: 'U_aniso_frac', u2: 'U_aniso_frac') -> "clipper::U_aniso_frac":
    return _clipper_python_core.add_U_aniso_frac(u1, u2)
add_U_aniso_frac = _clipper_python_core.add_U_aniso_frac

def neg_U_aniso_frac(u: 'U_aniso_frac') -> "clipper::U_aniso_frac":
    return _clipper_python_core.neg_U_aniso_frac(u)
neg_U_aniso_frac = _clipper_python_core.neg_U_aniso_frac

def product_U_aniso_frac(s: 'clipper::ftype const &', u: 'U_aniso_frac') -> "clipper::U_aniso_frac":
    return _clipper_python_core.product_U_aniso_frac(s, u)
product_U_aniso_frac = _clipper_python_core.product_U_aniso_frac

class Grid(object):
    """


    generic grid  

    This holds the dimensions of a 3D array, indexed from 0 along each dimension.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from nu,nv,nw  

        """
        this = _clipper_python_core.new_Grid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nu(self) -> "int const &":
        """


        get nu  

        """
        return _clipper_python_core.Grid_nu(self)


    def nv(self) -> "int const &":
        """


        get nv  

        """
        return _clipper_python_core.Grid_nv(self)


    def nw(self) -> "int const &":
        """


        get nw  

        """
        return _clipper_python_core.Grid_nw(self)


    def size(self) -> "int":
        """


        return size of grid array  

        """
        return _clipper_python_core.Grid_size(self)


    def in_grid(self, g: 'Coord_grid') -> "bool":
        """


        determine if a point is in the grid  

        """
        return _clipper_python_core.Grid_in_grid(self, g)


    def index(self, c: 'Coord_grid') -> "int":
        """


        grid indexing operator  

        """
        return _clipper_python_core.Grid_index(self, c)


    def deindex(self, index: 'int const &') -> "clipper::Coord_grid":
        """


        grid deindexing operator  

        """
        return _clipper_python_core.Grid_deindex(self, index)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        Returns
        -------
        The formatted text string  

        """
        return _clipper_python_core.Grid_format(self)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.Grid_debug(self)


    @property
    def dim(self):
      import numpy
      return numpy.array([self.nu(), self.nv(), self.nw()])

    size = property(size)

    __swig_destroy__ = _clipper_python_core.delete_Grid
    __del__ = lambda self: None
Grid_swigregister = _clipper_python_core.Grid_swigregister
Grid_swigregister(Grid)

class Grid_sampling(Grid):
    """


    Grid sampling of a unit cell.  

        This class represents the grid sampling of a unit cell. It is
     otherwise identical to its parent, clipper::Grid_cell, but has an additional
    constructor which takes a spacegroup, cell and resolution and produces an
    appropriate grid obeying all of the symmetry constraints, and using efficient
    factors for the calculation of FFTs.  

    note: The following methods are inherited from Grid and Grid_cell but are
        documented here for convenience: nu(), nv(), nw(), size(), index(),
        deindex(), format(), coord_frac(), coord_grid(), to_unit().  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from Spacegroup, Cell, Resolution, Shannon rate  

        A grid is chosen to represent the specified cell at the given resolution,
        obeying any restrictions imposed by the spacegroup. A slightly finer grid may be
        chosen if doing so is liable to significantly increase the speed of FFTs on that
        grid.  

        Parameters
        ----------
        * `spacegroup` :  
            The spacegroup which the grid must obey.  
        * `cell` :  
            The cell which the grid must contain.  
        * `resol` :  
            The resolution to which the grid must sample.  
        * `rate` :  
            The linear Shannon rate (oversampling) required. If rate = 1, the grid
            spaceing will be half the resolution (the the minimum required). For a grid
            spaceing of resol/3, use the default rate=1.5.  

        """
        this = _clipper_python_core.new_Grid_sampling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, spacegroup: 'Spacegroup', cell: 'Cell', resol: 'Resolution', rate: 'clipper::ftype const'=1.5) -> "void":
        """


        initialiser: from Spacegroup, Cell, Resolution, Shannon rate  

        A grid is chosen to represent the specified cell at the given resolution,
        obeying any restrictions imposed by the spacegroup. A slightly finer grid may be
        chosen if doing so is liable to significantly increase the speed of FFTs on that
        grid.  

        Parameters
        ----------
        * `spacegroup` :  
            The spacegroup which the grid must obey.  
        * `cell` :  
            The cell which the grid must contain.  
        * `resol` :  
            The resolution to which the grid must sample.  
        * `rate` :  
            The linear Shannon rate (oversampling) required. If rate = 1, the grid
            spaceing will be half the resolution (the the minimum required). For a grid
            spaceing of resol/3, use the default rate=1.5.  

        """
        return _clipper_python_core.Grid_sampling_init(self, spacegroup, cell, resol, rate)


    def matrix_grid_frac(self) -> "clipper::Mat33< >":
        """


        return matrix which converts grid to fractional coordinates  

        The result is an RT operator. This is a redudent representation, but is handy
        for assembling compound operators.  

        Returns
        -------
        The operator  

        """
        return _clipper_python_core.Grid_sampling_matrix_grid_frac(self)


    def matrix_frac_grid(self) -> "clipper::Mat33< >":
        """


        return matrix which converts fractional to grid coordinates  

        The result is an RT operator. This is a redudent representation, but is handy
        for assembling compound operators.  

        Returns
        -------
        The operator  

        """
        return _clipper_python_core.Grid_sampling_matrix_frac_grid(self)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Grid_sampling_is_null(self)


    def __str__(self) -> "std::string":
        return _clipper_python_core.Grid_sampling___str__(self)

    def dim(self) -> "void":
        return _clipper_python_core.Grid_sampling_dim(self)

    dim = property(dim)
    format = property(format)

    __swig_destroy__ = _clipper_python_core.delete_Grid_sampling
    __del__ = lambda self: None
Grid_sampling_swigregister = _clipper_python_core.Grid_sampling_swigregister
Grid_sampling_swigregister(Grid_sampling)

class HKL_sampling(object):
    """


    HKL sampling of reciprocal space.  

    The HKL_sampling class uniquely describes a P0 reflection list bounded by some
    resolution limit in reciprocal space. It is described in terms of large
    integers, and so immune from rounding errors once the object is constructed.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: takes parameters of normal or inverse cell  

        Initialise using cell and resolution.  

        """
        this = _clipper_python_core.new_HKL_sampling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hkl_limit(self) -> "clipper::HKL":
        """


        return limiting values of H, K, L  

        Returned HKL contains maximum possible values of H, K, L respectively.  

        Returns
        -------
        Limiting h,k,l.  

        """
        return _clipper_python_core.HKL_sampling_hkl_limit(self)


    def resolution(self, cell: 'Cell') -> "clipper::Resolution":
        """


        return approximate resolution given cell  

        Returned resolution is an estimate based on highest reflection in list.  

        Returns
        -------
        The resolution.  

        """
        return _clipper_python_core.HKL_sampling_resolution(self, cell)


    def in_resolution(self, h: 'HKL') -> "bool":
        """


        test if a reflection is within the resolution limit  

        """
        return _clipper_python_core.HKL_sampling_in_resolution(self, h)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        """
        return _clipper_python_core.HKL_sampling_is_null(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.HKL_sampling_format(self)


    def __eq__(self, hkl2: 'HKL_sampling') -> "bool":
        return _clipper_python_core.HKL_sampling___eq__(self, hkl2)

    def __ne__(self, hkl2: 'HKL_sampling') -> "bool":
        return _clipper_python_core.HKL_sampling___ne__(self, hkl2)
    __swig_destroy__ = _clipper_python_core.delete_HKL_sampling
    __del__ = lambda self: None
HKL_sampling_swigregister = _clipper_python_core.HKL_sampling_swigregister
HKL_sampling_swigregister(HKL_sampling)

def equals_HKL_samp(h1: 'HKL_sampling', h2: 'HKL_sampling') -> "int":
    return _clipper_python_core.equals_HKL_samp(h1, h2)
equals_HKL_samp = _clipper_python_core.equals_HKL_samp

class Grid_range(Grid):
    """


    Grid range class: defines array limits for a grid.  

    This class is used for describing 3D grids covering an arbitrary part of the 3D
    space, i.e. which do not start from (0,0,0).  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: make grid to hold a sphere from cell, grid, radius  

        Make a map grid large enough to fully enclose a sphere about the origin of a
        given radius with a given cell and grid sampling.  

        Parameters
        ----------
        * `cell` :  
            The cell parameters.  
        * `grid` :  
            The grid sampling of the whole cell.  
        * `radius` :  
            The radius of the sphere in Angstroms.  

        """
        this = _clipper_python_core.new_Grid_range(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def min(self) -> "clipper::Coord_grid const &":
        """


        access grid limits  

        """
        return _clipper_python_core.Grid_range_min(self)


    def max(self) -> "clipper::Coord_grid const &":
        """


        access grid limits  

        """
        return _clipper_python_core.Grid_range_max(self)


    def add_border(self, b: 'int const') -> "void":
        """


        border: increase grid to include given border  

        Enlarge the grid by adding `b` cells in every direction. Will shrink the grid if
        `b` is negative.  

        Parameters
        ----------
        * `b` :  
            The number of cells by which to enlarge/shrink.  

        """
        return _clipper_python_core.Grid_range_add_border(self, b)


    def in_grid(self, g: 'Coord_grid') -> "bool":
        """


        determine if a point is in the grid  

        """
        return _clipper_python_core.Grid_range_in_grid(self, g)


    def index(self, c: 'Coord_grid') -> "int":
        """


        grid indexing operator  

        """
        return _clipper_python_core.Grid_range_index(self, c)


    def deindex(self, index: 'int const &') -> "clipper::Coord_grid":
        """


        grid deindexing operator  

        """
        return _clipper_python_core.Grid_range_deindex(self, index)

    __swig_destroy__ = _clipper_python_core.delete_Grid_range
    __del__ = lambda self: None
Grid_range_swigregister = _clipper_python_core.Grid_range_swigregister
Grid_range_swigregister(Grid_range)

class Atom(object):
    """


    Atom class.  

    This class defines a minimal atom object providing only those properties
    required for an electron density calculation. A template constructor allows it
    to be constructed from any other object with appropriate properties.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        Constructor: from atom-like object.  

        """
        this = _clipper_python_core.new_Atom()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _get_element_as_clipper_string(self) -> "clipper::String const &":
        """


        get atom element name: e.g. "C", "N", "Zn2+"  

        """
        return _clipper_python_core.Atom__get_element_as_clipper_string(self)


    def _get_coord_orth(self) -> "clipper::Coord_orth const &":
        """


        get atom orthogonal (Angstrom) coordinate  

        """
        return _clipper_python_core.Atom__get_coord_orth(self)


    def _get_occupancy(self) -> "clipper::ftype const &":
        """


        get atom occupancy  

        """
        return _clipper_python_core.Atom__get_occupancy(self)


    def _get_u_iso(self) -> "clipper::ftype const &":
        """


        get atom orthogonal isotropic U value  

        """
        return _clipper_python_core.Atom__get_u_iso(self)


    def _get_u_aniso(self) -> "clipper::U_aniso_orth const &":
        """


        get atom orthogonal anisotropic U value  

        """
        return _clipper_python_core.Atom__get_u_aniso(self)


    def _set_element(self, s: 'String') -> "void":
        """


        set element  

        """
        return _clipper_python_core.Atom__set_element(self, s)


    def _set_coord_orth(self, s: 'Coord_orth') -> "void":
        """


        set coord_orth  

        """
        return _clipper_python_core.Atom__set_coord_orth(self, s)


    def _set_occupancy(self, s: 'clipper::ftype const &') -> "void":
        """


        set occupancy  

        """
        return _clipper_python_core.Atom__set_occupancy(self, s)


    def _set_u_iso(self, s: 'clipper::ftype const &') -> "void":
        """


        set u_iso  

        """
        return _clipper_python_core.Atom__set_u_iso(self, s)


    def _set_u_aniso(self, s: 'U_aniso_orth') -> "void":
        """


        set u_aniso  

        """
        return _clipper_python_core.Atom__set_u_aniso(self, s)


    def transform(self, rt: 'RTop_orth') -> "void":
        """


        apply a rotation-translation operator (RTop) to the atom  

        The coordinates and U_aniso_orth are transformed. The sigmas are not, since
        without the full variance-covariance matrix this transformation is impossible.  

        Parameters
        ----------
        * `rt` :  
            The operator to apply.  

        """
        return _clipper_python_core.Atom_transform(self, rt)


    def is_null(self) -> "bool":
        """


        test for null atom: atom is null is coord is null  

        """
        return _clipper_python_core.Atom_is_null(self)


    def null() -> "clipper::Atom":
        """


        return null atom  

        """
        return _clipper_python_core.Atom_null()

    null = staticmethod(null)

    def _get_element(self) -> "std::string":
        return _clipper_python_core.Atom__get_element(self)

    _allow_unknown = True

    @property
    def allow_unknown(self):
      return self._allow_unknown

    @allow_unknown.setter
    def allow_unknown(self, allow):
      self._allow_unknown = allow

    def _set_element_with_check(self, element_name):
      if not self.allow_unknown:
        if element_name not in ('H', 'C', 'N', 'O', 'S'):
          if element_name not in ATOM_NAMES:
            raise TypeError('Unrecognised element!')
      self._set_element(element_name)

    element = property(_get_element, _set_element_with_check)
    occupancy = property(_get_occupancy, _set_occupancy)
    u_iso = property(_get_u_iso, _set_u_iso)
    _u_aniso = property(_get_u_aniso, _set_u_aniso)
    coord_orth = property(_get_coord_orth, _set_coord_orth)
    is_null = property(is_null)

    def _get_coord_xyz(self):
      ''' Get the orthographic (x,y,z) coordinates as a Numpy array. '''
      return self.coord_orth.xyz
    def _set_coord_xyz(self, coord):
      self.coord_orth = Coord_orth(*coord)
    coord = property(_get_coord_xyz, _set_coord_xyz)

    def _get_u_aniso_vals(self):
      '''
      Anisotropic B-factor matrix as a 6-member array:
      [u00, u11, u22, u01, u02, u12].
      For purely isotropic B-factors, set this to None
      '''
      return self._u_aniso._get_vals()

    def _set_u_aniso_vals(self, u_aniso):
      import numpy
      if u_aniso is None:
        self._set_u_aniso(U_aniso_orth(*([float('nan')]*6)))
      else:
        try:
          self._set_u_aniso(U_aniso_orth(*u_aniso))
        except:
          if type(u_aniso) == numpy.ndarray:
            self._set_u_aniso(U_aniso_orth(*(u_aniso.astype(float))))
          elif type(u_aniso) == U_aniso_orth:
            self._set_u_aniso(u_aniso)
          else:
            raise TypeError('''
              u_aniso must be None, a list of 6 numbers [u00, u11, u22, u01, u02, u12]\n
              or a clipper U_aniso_orth object.''')

    u_aniso = property(_get_u_aniso_vals, _set_u_aniso_vals)

    __swig_destroy__ = _clipper_python_core.delete_Atom
    __del__ = lambda self: None
Atom_swigregister = _clipper_python_core.Atom_swigregister
Atom_swigregister(Atom)

def Atom_null() -> "clipper::Atom":
    """


    return null atom  

    """
    return _clipper_python_core.Atom_null()

class Atom_list(object):
    """


    Atom list class.  

    This class defines a minimal atom list object providing only those properties
    required for an electron density calculation. It is a trivial derivation from
    std::vector<Atom>. In addition a template constructor allows it to be
    constructed from any other object with appropriate properties.  

    C++ includes: coords.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        Constructor: from vector-like list of atom-like objects.  

        """
        this = _clipper_python_core.new_Atom_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getitem__(self, i: 'int') -> "clipper::Atom &":
        return _clipper_python_core.Atom_list___getitem__(self, i)

    def __setitem__(self, i: 'int', atom: 'Atom') -> "void":
        return _clipper_python_core.Atom_list___setitem__(self, i, atom)

    def __len__(self) -> "size_t":
        return _clipper_python_core.Atom_list___len__(self)

    def pop(self, i: 'int') -> "clipper::Atom":
        return _clipper_python_core.Atom_list_pop(self, i)

    def append(self, a: 'Atom') -> "size_t":
        return _clipper_python_core.Atom_list_append(self, a)

    def extend_by(self, n: 'size_t') -> "void":
        return _clipper_python_core.Atom_list_extend_by(self, n)

    def _set_elements_base(self, elements: 'StringVector') -> "void":
        return _clipper_python_core.Atom_list__set_elements_base(self, elements)

    def _get_elements_base(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _clipper_python_core.Atom_list__get_elements_base(self)

    def _set_coord_orth_base(self, numpy_2d_in: 'double *') -> "void":
        return _clipper_python_core.Atom_list__set_coord_orth_base(self, numpy_2d_in)

    def _get_coord_orth_base(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.Atom_list__get_coord_orth_base(self, numpy_array)

    def _set_occupancies_base(self, numpy_1d_in: 'double *') -> "void":
        return _clipper_python_core.Atom_list__set_occupancies_base(self, numpy_1d_in)

    def _get_occupancies_base(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.Atom_list__get_occupancies_base(self, numpy_array)

    def _set_u_isos_base(self, numpy_1d_in: 'double *') -> "void":
        return _clipper_python_core.Atom_list__set_u_isos_base(self, numpy_1d_in)

    def _get_u_isos_base(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.Atom_list__get_u_isos_base(self, numpy_array)

    def _set_u_anisos_base(self, numpy_2d_in: 'double *') -> "void":
        return _clipper_python_core.Atom_list__set_u_anisos_base(self, numpy_2d_in)

    def _get_u_anisos_base(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.Atom_list__get_u_anisos_base(self, numpy_array)

    def get_minmax_grid(self, cell: 'Cell', grid: 'Grid_sampling') -> "void":
        return _clipper_python_core.Atom_list_get_minmax_grid(self, cell, grid)

    _allow_unknown = True

    @property
    def allow_unknown(self):
      return self._allow_unknown

    @allow_unknown.setter
    def allow_unknown(self, allow):
      self._allow_unknown = allow

#ifdef PYTHON_PROPERTIES

    def _get_elements(self):
      '''Ordered list of all element names'''
      return self._get_elements_base()

    def _set_elements(self, elements):
      if not self.allow_unknown:
        if not set(elements).issubset(ATOM_NAMES):
          bad_atoms = []
          for el in set(elements):
            if el not in ATOM_NAMES:
              bad_atoms.append(el)
          bad_atoms = set(bad_atoms)
          errstring = '''
            The following atom names are not recognised by Clipper:
            {}
            '''.format(bad_atoms)
          raise TypeError(errstring)
      self._set_elements_base(elements)

    elements = property(_get_elements, _set_elements)



    def _get_coord_orth(self):
      '''Orthographic (x,y,z) coordinates of all atoms'''
      import numpy
      n = len(self)
      coords = numpy.empty((n,3), numpy.double)
      self._get_coord_orth_base(coords)
      return coords

    def _set_coord_orth(self, coords):
      import numpy
      n = len(self)
      array_in = numpy.empty((n, 3), numpy.double)
      array_in[:] = coords
      self._set_coord_orth_base(array_in)

    coord_orth = property(_get_coord_orth, _set_coord_orth)

    def _get_occupancies(self):
      '''Occupancies of all atoms.'''
      import numpy
      n = len(self)
      occ = numpy.empty(n, numpy.double)
      self._get_occupancies_base(occ)
      return occ

    def _set_occupancies(self, occ):
      import numpy
      n = len(self)
      array_in = numpy.empty(n, numpy.double)
      array_in[:] = occ
      self._set_occupancies_base(array_in)

    occupancies = property(_get_occupancies, _set_occupancies)

    def _get_u_isos(self):
      '''Isotropic B-factors of all atoms.'''
      import numpy
      n = len(self)
      uisos = numpy.empty(n, numpy.double)
      self._get_u_isos_base(uisos)
      return uisos

    def _set_u_isos(self, uisos):
      import numpy
      n = len(self)
      array_in = numpy.empty(n, numpy.double)
      array_in[:] = uisos
      self._set_u_isos_base(array_in)

    u_isos = property(_get_u_isos, _set_u_isos)

    def _get_u_anisos(self):
      '''
      Anisotropic B-factor matrices for all atoms as an nx6 array, in the
      format: n*[u00, u11, u22, u01, u02, u12]. For purely isotropic
      atoms, set all elements in their row to math.nan or numpy.nan.
      '''
      import numpy
      n = len(self)
      uaniso = numpy.empty((n,6), numpy.double)
      self._get_u_anisos_base(uaniso)
      return uaniso

    def _set_u_anisos(self, u_anisos):
      import numpy
      n = len(self)
      array_in = numpy.empty((n,6), numpy.double)
      array_in[:] = u_anisos
      self._set_u_anisos_base(array_in)

    u_anisos = property(_get_u_anisos, _set_u_anisos)

#endif


    __swig_destroy__ = _clipper_python_core.delete_Atom_list
    __del__ = lambda self: None
Atom_list_swigregister = _clipper_python_core.Atom_list_swigregister
Atom_list_swigregister(Atom_list)

class Symops(object):
    """

    Stores a list of rotation/translation operators, which can be retrieved as
    Clipper RTOP_frac objects or numpy arrays of transformation matrices.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_Symops(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Symops
    __del__ = lambda self: None

    def __getitem__(self, i: 'int') -> "clipper::RTop_frac":
        return _clipper_python_core.Symops___getitem__(self, i)

    def __setitem__(self, i: 'int', op: 'RTop_frac') -> "void":
        return _clipper_python_core.Symops___setitem__(self, i, op)

    def __len__(self) -> "size_t":
        return _clipper_python_core.Symops___len__(self)

    def append(self, op: 'RTop_frac') -> "void":
        return _clipper_python_core.Symops_append(self, op)

    def pop(self, i: 'int') -> "clipper::RTop_frac":
        return _clipper_python_core.Symops_pop(self, i)

    def cell_trans(self, i: 'int') -> "clipper::Coord_frac":
        return _clipper_python_core.Symops_cell_trans(self, i)

    def _all_matrices44_frac(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.Symops__all_matrices44_frac(self, numpy_array)

    def _all_matrices34_frac(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.Symops__all_matrices34_frac(self, numpy_array)

    def _all_matrices44_orth(self, cell: 'Cell', numpy_array: 'double *') -> "void":
        return _clipper_python_core.Symops__all_matrices44_orth(self, cell, numpy_array)

    def _all_matrices34_orth(self, cell: 'Cell', numpy_array: 'double *') -> "void":
        return _clipper_python_core.Symops__all_matrices34_orth(self, cell, numpy_array)

    def all_matrices_frac(self, format = '3x4'):
      '''
      Returns a Numpy array containing all the current symmetry operators in
      fractional coordinates.
      Args:
        format (string):
          One of '3x4' (default) or '4x4'. If '3x4', each operator is
          returned as:
          [[rot00, rot01, rot02, trn_u]
           [rot10, rot11, rot12, trn_v]
           [rot20, rot21, rot22, trn_w]]
          If '4x4', the [0,0,0,1] row necessary to form a complete
          affine transformation matrix is added.
      '''
      import numpy
      n = len(self)
      if format == '3x4':
        ret = numpy.empty((n,3,4), numpy.double)
        self._all_matrices34_frac(ret)
      elif format == '4x4':
        ret = numpy.empty((n,4,4), numpy.double)
        self._all_matrices44_frac(ret)
      else:
        raise TypeError("Format must be one of '3x4' or '4x4'!")
      return ret

    def all_matrices_orth(self, cell, format = '3x4'):
      '''
      Returns a Numpy array containing all the current symmetry operators in
      fractional coordinates.
      Args:
        cell:
          The clipper Cell object defining your crystal cell parameters
        format (string):
          One of '3x4' (default) or '4x4'. If '3x4', each operator is
          returned as:
          [[rot00, rot01, rot02, trn_x]
           [rot10, rot11, rot12, trn_y]
           [rot20, rot21, rot22, trn_z]]
          If '4x4', the [0,0,0,1] row necessary to form a complete
          affine transformation matrix is added.
      '''
      import numpy
      n = len(self)
      if format == '3x4':
        ret = numpy.empty((n,3,4), numpy.double)
        self._all_matrices34_orth(cell, ret)
      elif format == '4x4':
        ret = numpy.empty((n,4,4), numpy.double)
        self._all_matrices44_orth(cell, ret)
      else:
        raise TypeError("Format must be one of '3x4' or '4x4'!")
      return ret

Symops_swigregister = _clipper_python_core.Symops_swigregister
Symops_swigregister(Symops)

class Unit_Cell(object):
    """
    Condensed description of a single unit cell based on an atomic model.

      Contains a reference fractional coordinate (typically corresponding
      to the centroid of the modelled asymmetric unit), a list of symmetry
      operators with the necessary translations added to fully pack a
      single unit cell, and a list of pre-computed inverse symmetry operators
      for convenience. Also provides methods to quickly find all the symmetry
      operators necessary to pack an arbitrary box in space with copies of
      your atomic model.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _clipper_python_core.delete_Unit_Cell
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _clipper_python_core.new_Unit_Cell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def symops(self) -> "clipper::Symops const &":
        """
        Returns a Symops object listing all the transformations mapping the
          reference model to other positions in the unit cell. 
        """
        return _clipper_python_core.Unit_Cell_symops(self)


    def inv_symops(self) -> "clipper::Symops const &":
        """
        Returns a Symops object listing all the transformations mapping each
          copy in the unit cell back to the reference model. 
        """
        return _clipper_python_core.Unit_Cell_inv_symops(self)


    def ref(self, *args) -> "clipper::Coord_frac &":
        return _clipper_python_core.Unit_Cell_ref(self, *args)

    def ref_box(self, *args) -> "clipper::Grid_range &":
        """
        Returns a Grid_range object defining the smallest rhomboid in integer
          grid coordinates that fully encloses the atomic model. 
        """
        return _clipper_python_core.Unit_Cell_ref_box(self, *args)


    def min(self) -> "clipper::Coord_grid":
        return _clipper_python_core.Unit_Cell_min(self)

    def max(self) -> "clipper::Coord_grid":
        return _clipper_python_core.Unit_Cell_max(self)

    def all_symops_in_box(self, box_origin_xyz: 'double [3]', box_size_uvw: 'long [3]', always_include_identity: 'bool'=False, sample_frequency: 'int'=2) -> "clipper::Symops":
        """
        all_symops_in_box(box_origin_xyz, box_size_uvw,
                            always_include_identity = False,
                            sample_frequency = 2)
              ---> Symops
          Returns a Symops object providing all symmetry operators which place
          some part of the atomic model within a box in grid space. If present, the
          identity operator will always appear first in the list.
          NOTE: this routine is optimised for speed rather than strictness, and
          may occasionally return extra operators which place the model just
          outside the target box. Think of the result as a shortlist of operators
          upon which more detailed atom-by-atom searches can be done if necessary.
          Args:
            box_origin_xyz(numpy 1x3 double):
              Position of the bottom corner of the search box (in Angstroms)
            box_size_uvw(numpy 1x3 int):
              Box side lengths in grid coordinates
            always_include_identity(bool):
              If true, the identity operator will always be returned
            sample_frequency(int):
              The box will be searched in steps equal to the minimum side length
              of the reference box divided by this number. In almost all cases
              this should be left as is.
        """
        return _clipper_python_core.Unit_Cell_all_symops_in_box(self, box_origin_xyz, box_size_uvw, always_include_identity, sample_frequency)


    symops = property(symops)
    inv_symops = property(inv_symops)
    ref = property(ref)
    ref_box = property(ref_box)
    min = property(min)
    max = property(max)

Unit_Cell_swigregister = _clipper_python_core.Unit_Cell_swigregister
Unit_Cell_swigregister(Unit_Cell)

class RTop_float(object):
    """


    Rotation-translation operator.  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from rotation and translation  

        """
        this = _clipper_python_core.new_RTop_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def inverse(self) -> "clipper::RTop< float >":
        """


        inverse  

        """
        return _clipper_python_core.RTop_float_inverse(self)


    def equals(self, m: 'RTop_float', tol: 'float const &') -> "bool":
        """


        test equality with some tolerance  

        """
        return _clipper_python_core.RTop_float_equals(self, m, tol)


    def rot(self, *args) -> "clipper::Mat33< float > &":
        """


        set rotation  

        """
        return _clipper_python_core.RTop_float_rot(self, *args)


    def trn(self, *args) -> "clipper::Vec3< float > &":
        """


        set translation  

        """
        return _clipper_python_core.RTop_float_trn(self, *args)


    def identity() -> "clipper::RTop< float >":
        """


        return identity operator  

        """
        return _clipper_python_core.RTop_float_identity()

    identity = staticmethod(identity)

    def null() -> "clipper::RTop< float >":
        """


        return identity operator  

        """
        return _clipper_python_core.RTop_float_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null operator  

        """
        return _clipper_python_core.RTop_float_is_null(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.RTop_float_format(self)

    __swig_destroy__ = _clipper_python_core.delete_RTop_float
    __del__ = lambda self: None
RTop_float_swigregister = _clipper_python_core.RTop_float_swigregister
RTop_float_swigregister(RTop_float)

def RTop_float_identity() -> "clipper::RTop< float >":
    """


    return identity operator  

    """
    return _clipper_python_core.RTop_float_identity()

def RTop_float_null() -> "clipper::RTop< float >":
    """


    return identity operator  

    """
    return _clipper_python_core.RTop_float_null()

class RTop_double(object):
    """


    Rotation-translation operator.  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from rotation and translation  

        """
        this = _clipper_python_core.new_RTop_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def inverse(self) -> "clipper::RTop< double >":
        """


        inverse  

        """
        return _clipper_python_core.RTop_double_inverse(self)


    def equals(self, m: 'RTop_double', tol: 'double const &') -> "bool":
        """


        test equality with some tolerance  

        """
        return _clipper_python_core.RTop_double_equals(self, m, tol)


    def rot(self, *args) -> "clipper::Mat33< double > &":
        """


        set rotation  

        """
        return _clipper_python_core.RTop_double_rot(self, *args)


    def trn(self, *args) -> "clipper::Vec3< double > &":
        """


        set translation  

        """
        return _clipper_python_core.RTop_double_trn(self, *args)


    def identity() -> "clipper::RTop< double >":
        """


        return identity operator  

        """
        return _clipper_python_core.RTop_double_identity()

    identity = staticmethod(identity)

    def null() -> "clipper::RTop< double >":
        """


        return identity operator  

        """
        return _clipper_python_core.RTop_double_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null operator  

        """
        return _clipper_python_core.RTop_double_is_null(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.RTop_double_format(self)

    __swig_destroy__ = _clipper_python_core.delete_RTop_double
    __del__ = lambda self: None
RTop_double_swigregister = _clipper_python_core.RTop_double_swigregister
RTop_double_swigregister(RTop_double)

def RTop_double_identity() -> "clipper::RTop< double >":
    """


    return identity operator  

    """
    return _clipper_python_core.RTop_double_identity()

def RTop_double_null() -> "clipper::RTop< double >":
    """


    return identity operator  

    """
    return _clipper_python_core.RTop_double_null()

class mat33_float(object):
    """


    3x3-matrix class  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: copy/convert from symmetric matrix  

        """
        this = _clipper_python_core.new_mat33_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def det(self) -> "float":
        """


        determinant  

        """
        return _clipper_python_core.mat33_float_det(self)


    def inverse(self) -> "clipper::Mat33< float >":
        """


        inverse  

        """
        return _clipper_python_core.mat33_float_inverse(self)


    def transpose(self) -> "clipper::Mat33< float >":
        """


        transpose  

        """
        return _clipper_python_core.mat33_float_transpose(self)


    def equals(self, m: 'mat33_float', tol: 'float const &') -> "bool":
        """


        test equality  

        """
        return _clipper_python_core.mat33_float_equals(self, m, tol)


    def __call__(self, *args) -> "float &":
        return _clipper_python_core.mat33_float___call__(self, *args)

    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.mat33_float_format(self)


    def identity() -> "clipper::Mat33< float >":
        """


        return identity matrix  

        """
        return _clipper_python_core.mat33_float_identity()

    identity = staticmethod(identity)

    def null() -> "clipper::Mat33< float >":
        """


        return null matrix (only valid for floating point types)  

        """
        return _clipper_python_core.mat33_float_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null matrix (only valid for floating point types)  

        """
        return _clipper_python_core.mat33_float_is_null(self)


    def __getitem__(self, i: 'int') -> "clipper::matrixRowClipper< float >":
        return _clipper_python_core.mat33_float___getitem__(self, i)

    def as_numpy(self) -> "void":
        return _clipper_python_core.mat33_float_as_numpy(self)

    def __neg__(self) -> "clipper::Mat33< float >":
        return _clipper_python_core.mat33_float___neg__(self)

    def __rmul__(self, *args) -> "clipper::Mat33< float >":
        return _clipper_python_core.mat33_float___rmul__(self, *args)

    def __sub__(self, m: 'mat33_float') -> "clipper::Mat33< float >":
        return _clipper_python_core.mat33_float___sub__(self, m)

    def __add__(self, m: 'mat33_float') -> "clipper::Mat33< float >":
        return _clipper_python_core.mat33_float___add__(self, m)

    def __mul__(self, *args) -> "clipper::Coord_frac":
        return _clipper_python_core.mat33_float___mul__(self, *args)

    as_numpy = property(as_numpy)

    __swig_destroy__ = _clipper_python_core.delete_mat33_float
    __del__ = lambda self: None
mat33_float_swigregister = _clipper_python_core.mat33_float_swigregister
mat33_float_swigregister(mat33_float)

def mat33_float_identity() -> "clipper::Mat33< float >":
    """


    return identity matrix  

    """
    return _clipper_python_core.mat33_float_identity()

def mat33_float_null() -> "clipper::Mat33< float >":
    """


    return null matrix (only valid for floating point types)  

    """
    return _clipper_python_core.mat33_float_null()

class mat33_double(object):
    """


    3x3-matrix class  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: copy/convert from symmetric matrix  

        """
        this = _clipper_python_core.new_mat33_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def det(self) -> "double":
        """


        determinant  

        """
        return _clipper_python_core.mat33_double_det(self)


    def inverse(self) -> "clipper::Mat33< double >":
        """


        inverse  

        """
        return _clipper_python_core.mat33_double_inverse(self)


    def transpose(self) -> "clipper::Mat33< double >":
        """


        transpose  

        """
        return _clipper_python_core.mat33_double_transpose(self)


    def equals(self, m: 'mat33_double', tol: 'double const &') -> "bool":
        """


        test equality  

        """
        return _clipper_python_core.mat33_double_equals(self, m, tol)


    def __call__(self, *args) -> "double &":
        return _clipper_python_core.mat33_double___call__(self, *args)

    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.mat33_double_format(self)


    def identity() -> "clipper::Mat33< double >":
        """


        return identity matrix  

        """
        return _clipper_python_core.mat33_double_identity()

    identity = staticmethod(identity)

    def null() -> "clipper::Mat33< double >":
        """


        return null matrix (only valid for floating point types)  

        """
        return _clipper_python_core.mat33_double_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null matrix (only valid for floating point types)  

        """
        return _clipper_python_core.mat33_double_is_null(self)


    def __getitem__(self, i: 'int') -> "clipper::matrixRowClipper< double >":
        return _clipper_python_core.mat33_double___getitem__(self, i)

    def as_numpy(self) -> "void":
        return _clipper_python_core.mat33_double_as_numpy(self)

    def __neg__(self) -> "clipper::Mat33< double >":
        return _clipper_python_core.mat33_double___neg__(self)

    def __rmul__(self, *args) -> "clipper::Mat33< double >":
        return _clipper_python_core.mat33_double___rmul__(self, *args)

    def __sub__(self, m: 'mat33_double') -> "clipper::Mat33< double >":
        return _clipper_python_core.mat33_double___sub__(self, m)

    def __add__(self, m: 'mat33_double') -> "clipper::Mat33< double >":
        return _clipper_python_core.mat33_double___add__(self, m)

    def __mul__(self, *args) -> "clipper::Coord_frac":
        return _clipper_python_core.mat33_double___mul__(self, *args)

    as_numpy = property(as_numpy)

    __swig_destroy__ = _clipper_python_core.delete_mat33_double
    __del__ = lambda self: None
mat33_double_swigregister = _clipper_python_core.mat33_double_swigregister
mat33_double_swigregister(mat33_double)

def mat33_double_identity() -> "clipper::Mat33< double >":
    """


    return identity matrix  

    """
    return _clipper_python_core.mat33_double_identity()

def mat33_double_null() -> "clipper::Mat33< double >":
    """


    return null matrix (only valid for floating point types)  

    """
    return _clipper_python_core.mat33_double_null()

class vec3_float(object):
    """


    3-vector class  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def equals(self, v: 'vec3_float', tol: 'float const &') -> "bool":
        """


        test equality  

        """
        return _clipper_python_core.vec3_float_equals(self, v, tol)


    def unit(self) -> "clipper::Vec3< float >":
        """


        return unit vector with same direction as this vector  

        """
        return _clipper_python_core.vec3_float_unit(self)


    def zero() -> "clipper::Vec3< float >":
        """


        return zero vector  

        """
        return _clipper_python_core.vec3_float_zero()

    zero = staticmethod(zero)

    def null() -> "clipper::Vec3< float >":
        """


        return null vector (only valid for floating point types)  

        """
        return _clipper_python_core.vec3_float_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null vector  

        """
        return _clipper_python_core.vec3_float_is_null(self)


    def dot(v1: 'vec3_float', v2: 'vec3_float') -> "float":
        """


        Vector dot product (equivalent to *)  

        """
        return _clipper_python_core.vec3_float_dot(v1, v2)

    dot = staticmethod(dot)

    def cross(v1: 'vec3_float', v2: 'vec3_float') -> "clipper::Vec3< float >":
        """


        Vector cross product.  

        """
        return _clipper_python_core.vec3_float_cross(v1, v2)

    cross = staticmethod(cross)

    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.vec3_float_format(self)


    def __iadd__(self, v: 'vec3_float') -> "clipper::Vec3< float > const &":
        return _clipper_python_core.vec3_float___iadd__(self, v)

    def __isub__(self, v: 'vec3_float') -> "clipper::Vec3< float > const &":
        return _clipper_python_core.vec3_float___isub__(self, v)

    def __init__(self, *args):
        """


        constructor: copy/convert  

        """
        this = _clipper_python_core.new_vec3_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getitem__(self, i: 'int') -> "float":
        return _clipper_python_core.vec3_float___getitem__(self, i)

    def __setitem__(self, i: 'int', value: 'float') -> "void":
        return _clipper_python_core.vec3_float___setitem__(self, i, value)

    def __str__(self) -> "std::string":
        return _clipper_python_core.vec3_float___str__(self)

    format = property(format)

    __swig_destroy__ = _clipper_python_core.delete_vec3_float
    __del__ = lambda self: None
vec3_float_swigregister = _clipper_python_core.vec3_float_swigregister
vec3_float_swigregister(vec3_float)

def vec3_float_zero() -> "clipper::Vec3< float >":
    """


    return zero vector  

    """
    return _clipper_python_core.vec3_float_zero()

def vec3_float_null() -> "clipper::Vec3< float >":
    """


    return null vector (only valid for floating point types)  

    """
    return _clipper_python_core.vec3_float_null()

def vec3_float_dot(v1: 'vec3_float', v2: 'vec3_float') -> "float":
    """


    Vector dot product (equivalent to *)  

    """
    return _clipper_python_core.vec3_float_dot(v1, v2)

def vec3_float_cross(v1: 'vec3_float', v2: 'vec3_float') -> "clipper::Vec3< float >":
    """


    Vector cross product.  

    """
    return _clipper_python_core.vec3_float_cross(v1, v2)

class vec3_double(object):
    """


    3-vector class  

    C++ includes: clipper_types.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def equals(self, v: 'vec3_double', tol: 'double const &') -> "bool":
        """


        test equality  

        """
        return _clipper_python_core.vec3_double_equals(self, v, tol)


    def unit(self) -> "clipper::Vec3< double >":
        """


        return unit vector with same direction as this vector  

        """
        return _clipper_python_core.vec3_double_unit(self)


    def zero() -> "clipper::Vec3< double >":
        """


        return zero vector  

        """
        return _clipper_python_core.vec3_double_zero()

    zero = staticmethod(zero)

    def null() -> "clipper::Vec3< double >":
        """


        return null vector (only valid for floating point types)  

        """
        return _clipper_python_core.vec3_double_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null vector  

        """
        return _clipper_python_core.vec3_double_is_null(self)


    def dot(v1: 'vec3_double', v2: 'vec3_double') -> "double":
        """


        Vector dot product (equivalent to *)  

        """
        return _clipper_python_core.vec3_double_dot(v1, v2)

    dot = staticmethod(dot)

    def cross(v1: 'vec3_double', v2: 'vec3_double') -> "clipper::Vec3< double >":
        """


        Vector cross product.  

        """
        return _clipper_python_core.vec3_double_cross(v1, v2)

    cross = staticmethod(cross)

    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.vec3_double_format(self)


    def __iadd__(self, v: 'vec3_double') -> "clipper::Vec3< double > const &":
        return _clipper_python_core.vec3_double___iadd__(self, v)

    def __isub__(self, v: 'vec3_double') -> "clipper::Vec3< double > const &":
        return _clipper_python_core.vec3_double___isub__(self, v)

    def __init__(self, *args):
        """


        constructor: copy/convert  

        """
        this = _clipper_python_core.new_vec3_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getitem__(self, i: 'int') -> "double":
        return _clipper_python_core.vec3_double___getitem__(self, i)

    def __setitem__(self, i: 'int', value: 'double') -> "void":
        return _clipper_python_core.vec3_double___setitem__(self, i, value)

    def __str__(self) -> "std::string":
        return _clipper_python_core.vec3_double___str__(self)

    format = property(format)

    __swig_destroy__ = _clipper_python_core.delete_vec3_double
    __del__ = lambda self: None
vec3_double_swigregister = _clipper_python_core.vec3_double_swigregister
vec3_double_swigregister(vec3_double)

def vec3_double_zero() -> "clipper::Vec3< double >":
    """


    return zero vector  

    """
    return _clipper_python_core.vec3_double_zero()

def vec3_double_null() -> "clipper::Vec3< double >":
    """


    return null vector (only valid for floating point types)  

    """
    return _clipper_python_core.vec3_double_null()

def vec3_double_dot(v1: 'vec3_double', v2: 'vec3_double') -> "double":
    """


    Vector dot product (equivalent to *)  

    """
    return _clipper_python_core.vec3_double_dot(v1, v2)

def vec3_double_cross(v1: 'vec3_double', v2: 'vec3_double') -> "clipper::Vec3< double >":
    """


    Vector cross product.  

    """
    return _clipper_python_core.vec3_double_cross(v1, v2)

class HKL_info(object):
    """


    HKL list container and tree root.  

    This object contains contains a reflection list, and all the properties on which
    such a list depends, i.e. spacegroup, cell, resolution. It also keeps a fast
    reflection lookup list and lookup lists for resolutions and reflection classes.  

    C++ includes: hkl_info.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: Takes spacegroup, cell, and resolution  

        Construct and initialise HKL_info object. This updates the spacegroup and cell
        and clears the reflection list. The resolution is used as a rejection criterion
        for reflections - no HKL will be stored beyond the given limit. Initially there
        are no reflections in the reflection list: see generate_hkl_list().  

        If any of the parameters have null values, the existing values will be
        unchanged. The object will only be fully initialised once all parameters are
        available.  

        Parameters
        ----------
        * `spacegroup` :  
            The spacegroup.  
        * `cell` :  
            The unit cell.  
        * `resolution` :  
            The resolution limit.  

        """
        this = _clipper_python_core.new_HKL_info(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        initialiser: Takes spacegroup, cell, and HKL_sampling  

        Initialise the HKL_info object. This updates the spacegroup and cell and clears
        the reflection list. The HKL_sampling determines the reflection list.  

        If any of the parameters have null values, the existing values will be
        unchanged. The object will only be fully initialised once all parameters are
        available.  

        Parameters
        ----------
        * `spacegroup` :  
            The spacegroup.  
        * `cell` :  
            The unit cell.  
        * `hkl_sampling` :  
            The resolution limit.  
        * `generate` :  
            If true, a reflection list will be generated for an ASU.  

        """
        return _clipper_python_core.HKL_info_init(self, *args)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.HKL_info_is_null(self)


    def cell(self) -> "clipper::Cell const &":
        """


        get the cell  

        """
        return _clipper_python_core.HKL_info_cell(self)


    def spacegroup(self) -> "clipper::Spacegroup const &":
        """


        get the spacegroup  

        """
        return _clipper_python_core.HKL_info_spacegroup(self)


    def hkl_sampling(self) -> "clipper::HKL_sampling const &":
        """


        [CLIPPER2] get HKL_sampling  

        """
        return _clipper_python_core.HKL_info_hkl_sampling(self)


    def resolution(self) -> "clipper::Resolution const &":
        """


        get the resolution  

        """
        return _clipper_python_core.HKL_info_resolution(self)


    def generate_hkl_list(self) -> "void":
        """


        synthesize hkl list  

        Using current cell, spacegroup, resolution.  

        """
        return _clipper_python_core.HKL_info_generate_hkl_list(self)


    def add_hkl_list(self, add: 'HKLVector') -> "void":
        """


        add new reflections to the list  

        The new HKLs are transformed to the default reciprocal ASU, and added to the
        reflection list. Duplicates and reflections outside the resoluution limit are
        ignored. Then the fast lookup tables for HKL, invresolsq, and reflection class
        are rebuilt.  

        Parameters
        ----------
        * `add` :  
            The list of new reflections to add.  

        """
        return _clipper_python_core.HKL_info_add_hkl_list(self, add)


    def num_reflections(self) -> "int":
        """


        get number of reflections in the object  

        """
        return _clipper_python_core.HKL_info_num_reflections(self)


    def hkl_of(self, index: 'int const &') -> "clipper::HKL const &":
        """


        reflection hkl from index  

        Parameters
        ----------
        * `index` :  
            The index.  

        Returns
        -------
        The corresponding HKL.  

        """
        return _clipper_python_core.HKL_info_hkl_of(self, index)


    def index_of(self, rfl: 'HKL') -> "int":
        """


        reflection index from hkl  

        This does not check symmetry equivalents (see find_sym).  

        Parameters
        ----------
        * `rfl` :  
            The HKL.  

        Returns
        -------
        The index, or -1 if it does not exist.  

        """
        return _clipper_python_core.HKL_info_index_of(self, rfl)


    def invresolsq(self, index: 'int const &') -> "clipper::ftype32 const &":
        """


        get reflection resolution using lookup  

        """
        return _clipper_python_core.HKL_info_invresolsq(self, index)


    def invresolsq_range(self) -> "Range< clipper::ftype > const &":
        """


        get resolution limits of the list  

        """
        return _clipper_python_core.HKL_info_invresolsq_range(self)


    def hkl_class(self, index: 'int const &') -> "clipper::HKL_class const &":
        """


        get reflection class using lookup  

        """
        return _clipper_python_core.HKL_info_hkl_class(self, index)


    def find_sym(self, rfl: 'HKL', sym: 'int &', friedel: 'bool &') -> "clipper::HKL":
        """


        find symop no and friedel to bring an HKL into ASU  

        Returns the index of the reflection, the sym no. and Friedel flag.  

        """
        return _clipper_python_core.HKL_info_find_sym(self, rfl, sym, friedel)


    def first(self) -> "clipper::HKL_info::HKL_reference_index":
        """


        return HKL_reference_index pointing to first reflection  

        """
        return _clipper_python_core.HKL_info_first(self)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_info_debug(self)


    cell = property(cell)
    spacegroup = property(spacegroup)
    resolution = property(resolution)

    __swig_destroy__ = _clipper_python_core.delete_HKL_info
    __del__ = lambda self: None
HKL_info_swigregister = _clipper_python_core.HKL_info_swigregister
HKL_info_swigregister(HKL_info)

class HKL_data_cacheobj(HKL_info):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data_cachekey: 'clipper::HKL_data_cacheobj::Key const &'):
        """


        """
        this = _clipper_python_core.new_HKL_data_cacheobj(hkl_data_cachekey)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def matches(self, hkl_data_cachekey: 'clipper::HKL_data_cacheobj::Key const &') -> "bool":
        """


        """
        return _clipper_python_core.HKL_data_cacheobj_matches(self, hkl_data_cachekey)


    def format(self) -> "clipper::String":
        """


        """
        return _clipper_python_core.HKL_data_cacheobj_format(self)

    mutex = _swig_property(_clipper_python_core.HKL_data_cacheobj_mutex_get, _clipper_python_core.HKL_data_cacheobj_mutex_set)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_cacheobj
    __del__ = lambda self: None
HKL_data_cacheobj_swigregister = _clipper_python_core.HKL_data_cacheobj_swigregister
HKL_data_cacheobj_swigregister(HKL_data_cacheobj)

class Datatype_base(object):
    """


    Reflection data type objects.  

    A class from which data type objects are usually derived  

    To define a new type for use in an HKL_data structure, subclass this class and
    override the following methods:  

    *   constructor - initialises to NAN  
    *   type() - returns type name, which is a list of the contained data  
    *   friedel() - applies Fridel transformation  
    *   shift_phase() - applies phase shift transformation  
    *   missing() - checks if data is present  
    *   data_size() - number of data elements in this type  
    *   data_names() - names of data elements in this type  
    *   data_export() - conversion to array (for I/O)  
    *   data_import() - conversion from array (for I/O)  
    *   scale() - (OPTIONAL) apply magnitude scale factor to data  

    note: polymorphism is NOT used here because virtual tables would be to expensive
        for every individual reflection, both in terms of space and cpu cycles.  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_Datatype_base()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Datatype_base
    __del__ = lambda self: None
Datatype_base_swigregister = _clipper_python_core.Datatype_base_swigregister
Datatype_base_swigregister(Datatype_base)

class HKL_data_base(object):
    """


    HKL_data_base.  

    This is the virtual base for the typed hkl_data objects. It exists to guarantee
    and interface by which data can be managed without knowledge of the specific
    data type.  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from spacegroup, cell, and HKL_sampling  

        Initialise the object using a given spacegroup, cell, and sampling.  

        Parameters
        ----------
        * `spacegroup` :  
            The spacegroup for this datalist.  
        * `cell` :  
            The unit cell for this datalist.  
        * `hkl_sampling` :  
            The reflection list description.  

        """
        return _clipper_python_core.HKL_data_base_init(self, *args)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.HKL_data_base_is_null(self)


    def base_hkl_info(self) -> "clipper::HKL_info const &":
        """


        get the parent HKL_info object  

        """
        return _clipper_python_core.HKL_data_base_base_hkl_info(self)


    def base_cell(self) -> "clipper::Cell const &":
        """


        get the parent cell  

        """
        return _clipper_python_core.HKL_data_base_base_cell(self)


    def spacegroup(self) -> "clipper::Spacegroup const &":
        """


        [CLIPPER2] get spacegroup  

        """
        return _clipper_python_core.HKL_data_base_spacegroup(self)


    def cell(self) -> "clipper::Cell const &":
        """


        [CLIPPER2] get cell  

        """
        return _clipper_python_core.HKL_data_base_cell(self)


    def resolution(self) -> "clipper::Resolution const &":
        """


        [CLIPPER2] get resolution  

        """
        return _clipper_python_core.HKL_data_base_resolution(self)


    def hkl_sampling(self) -> "clipper::HKL_sampling const &":
        """


        [CLIPPER2] get HKL_sampling  

        """
        return _clipper_python_core.HKL_data_base_hkl_sampling(self)


    def hkl_info(self) -> "clipper::HKL_info const &":
        """


        [CLIPPER2] get HKL_info object  

        """
        return _clipper_python_core.HKL_data_base_hkl_info(self)


    def invresolsq(self, index: 'int const &') -> "clipper::ftype":
        """


        get resolution by reflection index (based on true cell)  

        Return the resolution of a particular reflection. If the cell of this list
        closely matches (to within 0.5A) the cell of the parent list, this is a simple
        lookup, otherwise a metric calculation is required.  

        """
        return _clipper_python_core.HKL_data_base_invresolsq(self, index)


    def invresolsq_range(self) -> "Range< clipper::ftype >":
        """


        get resolution limits of the list (based on true cell and missing data)  

        Returns
        -------
        The high and low resolution limits of the non-missing data.  

        """
        return _clipper_python_core.HKL_data_base_invresolsq_range(self)


    def num_obs(self) -> "int":
        """


        get number of observations in this list (based on missing data)  

        Returns
        -------
        The number of non-missing data in the object.  

        """
        return _clipper_python_core.HKL_data_base_num_obs(self)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        """
        return _clipper_python_core.HKL_data_base_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_base_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_base_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_base_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_base_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_base_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_base_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_base_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        mask the data by marking any data missing in 'mask' as missing  

        """
        return _clipper_python_core.HKL_data_base_mask(self, mask)


    def first(self) -> "clipper::HKL_data_base::HKL_reference_index":
        """


        return HKL_reference_index pointing to first reflection  

        Returns
        -------
        HKL reference to the first data in this object.  

        """
        return _clipper_python_core.HKL_data_base_first(self)


    def first_data(self) -> "clipper::HKL_data_base::HKL_reference_index":
        """


        return HKL_reference_index pointing to first non-missing data  

        Returns
        -------
        HKL reference to the first non-missing data in this object.  

        """
        return _clipper_python_core.HKL_data_base_first_data(self)


    def next_data(self, ih: 'clipper::HKL_data_base::HKL_reference_index &') -> "clipper::HKL_data_base::HKL_reference_index &":
        """


        increment HKL_reference_index to next non-missing data  

        Parameters
        ----------
        * `ih` :  
            The HKL reference to increment.  

        Returns
        -------
        HKL reference to the next non-missing data in this object.  

        """
        return _clipper_python_core.HKL_data_base_next_data(self, ih)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_base_debug(self)


    def __init__(self):
        if self.__class__ == HKL_data_base:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_HKL_data_base(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_HKL_data_base(self)
        return weakref_proxy(self)
HKL_data_base_swigregister = _clipper_python_core.HKL_data_base_swigregister
HKL_data_base_swigregister(HKL_data_base)

class HKL_reference_base(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def base_hkl_info(self) -> "clipper::HKL_info const &":
        return _clipper_python_core.HKL_reference_base_base_hkl_info(self)

    def index(self) -> "int const &":
        return _clipper_python_core.HKL_reference_base_index(self)

    def invresolsq(self, *args) -> "clipper::ftype":
        return _clipper_python_core.HKL_reference_base_invresolsq(self, *args)

    def last(self) -> "bool":
        return _clipper_python_core.HKL_reference_base_last(self)

    def __init__(self):
        this = _clipper_python_core.new_HKL_reference_base()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_HKL_reference_base
    __del__ = lambda self: None
HKL_reference_base_swigregister = _clipper_python_core.HKL_reference_base_swigregister
HKL_reference_base_swigregister(HKL_reference_base)

class HKL_reference_index(HKL_reference_base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_HKL_reference_index(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hkl(self) -> "clipper::HKL const &":
        return _clipper_python_core.HKL_reference_index_hkl(self)

    def hkl_class(self) -> "clipper::HKL_class const &":
        return _clipper_python_core.HKL_reference_index_hkl_class(self)

    def next(self) -> "clipper::HKL_reference_index &":
        return _clipper_python_core.HKL_reference_index_next(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_reference_index
    __del__ = lambda self: None
HKL_reference_index_swigregister = _clipper_python_core.HKL_reference_index_swigregister
HKL_reference_index_swigregister(HKL_reference_index)

class Xmap_cacheobj(object):
    """


    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, xmap_cachekey: 'clipper::Xmap_cacheobj::Key const &'):
        """


        construct entry  

        """
        this = _clipper_python_core.new_Xmap_cacheobj(xmap_cachekey)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def matches(self, xmap_cachekey: 'clipper::Xmap_cacheobj::Key const &') -> "bool":
        """


        compare entry  

        """
        return _clipper_python_core.Xmap_cacheobj_matches(self, xmap_cachekey)


    def format(self) -> "clipper::String":
        """


        string description  

        """
        return _clipper_python_core.Xmap_cacheobj_format(self)

    key = _swig_property(_clipper_python_core.Xmap_cacheobj_key_get, _clipper_python_core.Xmap_cacheobj_key_set)
    xtl_grid = _swig_property(_clipper_python_core.Xmap_cacheobj_xtl_grid_get, _clipper_python_core.Xmap_cacheobj_xtl_grid_set)
    asu_grid = _swig_property(_clipper_python_core.Xmap_cacheobj_asu_grid_get, _clipper_python_core.Xmap_cacheobj_asu_grid_set)
    map_grid = _swig_property(_clipper_python_core.Xmap_cacheobj_map_grid_get, _clipper_python_core.Xmap_cacheobj_map_grid_set)
    nsym = _swig_property(_clipper_python_core.Xmap_cacheobj_nsym_get, _clipper_python_core.Xmap_cacheobj_nsym_set)
    asu = _swig_property(_clipper_python_core.Xmap_cacheobj_asu_get, _clipper_python_core.Xmap_cacheobj_asu_set)
    isymop = _swig_property(_clipper_python_core.Xmap_cacheobj_isymop_get, _clipper_python_core.Xmap_cacheobj_isymop_set)
    du = _swig_property(_clipper_python_core.Xmap_cacheobj_du_get, _clipper_python_core.Xmap_cacheobj_du_set)
    dv = _swig_property(_clipper_python_core.Xmap_cacheobj_dv_get, _clipper_python_core.Xmap_cacheobj_dv_set)
    dw = _swig_property(_clipper_python_core.Xmap_cacheobj_dw_get, _clipper_python_core.Xmap_cacheobj_dw_set)
    symperm = _swig_property(_clipper_python_core.Xmap_cacheobj_symperm_get, _clipper_python_core.Xmap_cacheobj_symperm_set)
    mat_grid_orth = _swig_property(_clipper_python_core.Xmap_cacheobj_mat_grid_orth_get, _clipper_python_core.Xmap_cacheobj_mat_grid_orth_set)
    mutex = _swig_property(_clipper_python_core.Xmap_cacheobj_mutex_get, _clipper_python_core.Xmap_cacheobj_mutex_set)
    __swig_destroy__ = _clipper_python_core.delete_Xmap_cacheobj
    __del__ = lambda self: None
Xmap_cacheobj_swigregister = _clipper_python_core.Xmap_cacheobj_swigregister
Xmap_cacheobj_swigregister(Xmap_cacheobj)

class Xmap_base(object):
    """


    Xmap_base: base for crystallographic map class.  

    The crystallographic map class stores a map of arbitrary data type. Its main
    difference from a 3-d array is that the data extent appears to be infinite, and
    yet internally only a unique ASU is stored. Iterators provide efficient access
    to data.  

    This base contains everything except the data, which is templated in the derived
    type Xmap<T>  

    C++ includes: xmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Default = _clipper_python_core.Xmap_base_Default
    Normal = _clipper_python_core.Xmap_base_Normal
    Sparse = _clipper_python_core.Xmap_base_Sparse

    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Xmap_base_is_null(self)


    def cell(self) -> "clipper::Cell const &":
        """


        get the cell  

        """
        return _clipper_python_core.Xmap_base_cell(self)


    def spacegroup(self) -> "clipper::Spacegroup const &":
        """


        get the spacegroup  

        """
        return _clipper_python_core.Xmap_base_spacegroup(self)


    def grid_sampling(self) -> "clipper::Grid_sampling const &":
        """


        get the cell grid  

        """
        return _clipper_python_core.Xmap_base_grid_sampling(self)


    def grid_asu(self) -> "clipper::Grid_range const &":
        """


        get the ASU grid  

        """
        return _clipper_python_core.Xmap_base_grid_asu(self)


    def coord_of(self, index: 'int const &') -> "clipper::Coord_grid":
        """


        map coordinate from index  

        Parameters
        ----------
        * `index` :  
            The index.  

        Returns
        -------
        The corresponding grid coordinate.  

        """
        return _clipper_python_core.Xmap_base_coord_of(self, index)


    def index_of(self, coord: 'Coord_grid') -> "int":
        """


        map index from coordinate  

        This does not check symmetry equivalents.  

        Parameters
        ----------
        * `coord` :  
            The coordinate.  

        Returns
        -------
        The index, or -1 if it does not exist.  

        """
        return _clipper_python_core.Xmap_base_index_of(self, coord)


    def to_map_unit(self, pos: 'Coord_grid') -> "clipper::Coord_grid":
        """


        function to pick right cell repeat for any grid coord  

        """
        return _clipper_python_core.Xmap_base_to_map_unit(self, pos)


    def operator_orth_grid(self) -> "clipper::RTop< > const &":
        return _clipper_python_core.Xmap_base_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< > const &":
        return _clipper_python_core.Xmap_base_operator_grid_orth(self)

    def coord_orth(self, cm: 'Coord_map') -> "clipper::Coord_orth":
        """


        convert map coordinate to orthogonal  

        Parameters
        ----------
        * `cm` :  
            The grid coordinate to be converted.  

        Returns
        -------
        The equivalent orthogonal coordinate.  

        """
        return _clipper_python_core.Xmap_base_coord_orth(self, cm)


    def coord_map(self, co: 'Coord_orth') -> "clipper::Coord_map":
        """


        convert orthogonal coordinate to map  

        Parameters
        ----------
        * `co` :  
            The orthogonal coordinate to be converted.  

        Returns
        -------
        The equivalent grid coordinate.  

        """
        return _clipper_python_core.Xmap_base_coord_map(self, co)


    def in_map(self, arg2: 'Coord_grid') -> "bool":
        """


        (This method is for compatibility with NXmap - it always returns true)  

        """
        return _clipper_python_core.Xmap_base_in_map(self, arg2)


    def multiplicity(self, pos: 'Coord_grid') -> "int":
        """


        get multiplicity of a map grid point  

        The multiplicity is the number of times the spacegroup operators map a
        particular grid point onto itself. This is required in order to properly weight
        map statistics so as to get the same result from just an ASU as using the whole
        cell.  

        Parameters
        ----------
        * `pos` :  
            The coordinate of the grid point.  

        Returns
        -------
        The multiplicty of the point.  

        """
        return _clipper_python_core.Xmap_base_multiplicity(self, pos)


    def first(self) -> "clipper::Xmap_base::Map_reference_index":
        """


        return a Map_reference_index for this map  

        """
        return _clipper_python_core.Xmap_base_first(self)


    def first_coord(self) -> "clipper::Xmap_base::Map_reference_coord":
        """


        return a Map_reference_coord for this map  

        """
        return _clipper_python_core.Xmap_base_first_coord(self)


    def default_type() -> "clipper::Xmap_base::FFTtype &":
        """


        set/get default backend type  

        """
        return _clipper_python_core.Xmap_base_default_type()

    default_type = staticmethod(default_type)
    __swig_destroy__ = _clipper_python_core.delete_Xmap_base
    __del__ = lambda self: None
Xmap_base_swigregister = _clipper_python_core.Xmap_base_swigregister
Xmap_base_swigregister(Xmap_base)

def Xmap_base_default_type() -> "clipper::Xmap_base::FFTtype &":
    """


    set/get default backend type  

    """
    return _clipper_python_core.Xmap_base_default_type()

class NXmap_base(object):
    """


    NXmap_base: base for non-crystallographic map class.  

    The non-crystallographic map class stores a map of arbitrary data type. Unlike
    an Xmap it is finite in extent and has no symmetry. An RT operator provides
    mapping onto an arbitrary orthogonal coordinate frame. Iterators provide
    efficient access to data.  

    This base contains everything except the data, which is templated in the derived
    type clipper::NXmap<T>.  

    C++ includes: nxmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.NXmap_base_is_null(self)


    def grid(self) -> "clipper::Grid const &":
        """


        return the grid dimensions for this map  

        """
        return _clipper_python_core.NXmap_base_grid(self)


    def operator_orth_grid(self) -> "clipper::RTop< > const &":
        return _clipper_python_core.NXmap_base_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< > const &":
        return _clipper_python_core.NXmap_base_operator_grid_orth(self)

    def coord_orth(self, cm: 'Coord_map') -> "clipper::Coord_orth":
        """


        convert map coordinate to orthogonal  

        Parameters
        ----------
        * `cm` :  
            The grid coordinate to be converted.  

        Returns
        -------
        The equivalent orthogonal coordinate.  

        """
        return _clipper_python_core.NXmap_base_coord_orth(self, cm)


    def coord_map(self, co: 'Coord_orth') -> "clipper::Coord_map":
        """


        convert orthogonal coordinate to map  

        Parameters
        ----------
        * `co` :  
            The orthogonal coordinate to be converted.  

        Returns
        -------
        The equivalent grid coordinate.  

        """
        return _clipper_python_core.NXmap_base_coord_map(self, co)


    def in_map(self, pos: 'Coord_grid') -> "bool":
        """


        is the given coord available in the map using the given interpolant?  

        Note that the higher the order of the interpolant, the more of the boundary of
        the map becomes inaccessible.  

        Parameters
        ----------
        * `cm` :  
            The coord_map to test.  

        Returns
        -------
        true if interpolation can be performed at that coordinate.  

        """
        return _clipper_python_core.NXmap_base_in_map(self, pos)


    def multiplicity(self, arg2: 'Coord_grid') -> "int":
        """


        get multiplicity of a map grid point (always 1 for NXmap)  

        """
        return _clipper_python_core.NXmap_base_multiplicity(self, arg2)


    def first(self) -> "clipper::NXmap_base::Map_reference_index":
        """


        return a basic Map_reference_index for this map  

        """
        return _clipper_python_core.NXmap_base_first(self)


    def first_coord(self) -> "clipper::NXmap_base::Map_reference_coord":
        """


        return a coord Map_reference_index for this map  

        """
        return _clipper_python_core.NXmap_base_first_coord(self)

    __swig_destroy__ = _clipper_python_core.delete_NXmap_base
    __del__ = lambda self: None
NXmap_base_swigregister = _clipper_python_core.NXmap_base_swigregister
NXmap_base_swigregister(NXmap_base)

class Xmap_float(Xmap_base):
    """


    Xmap<T>: actual crystallographic map class.  

    The crystallographic map class stores a map of arbitrary data type. Its main
    difference from a 3-d array is that the data extent appears to be infinite, and
    yet internally only a unique ASU is stored. Iterators provide efficient access
    to data.  

    This is derived from Xmap_base, and adds the templatised data itself and the
    methods which deal with it.  

    note: The following methods are inherited from Xmap_base but are documented here
        for convenience: cell(), spacegroup(), grid_sampling(), grid_asu(),
        in_asu(), multiplicity(), to_map_unit(), first(), first_coord().  

    C++ includes: xmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from spacegroup, cell, and grid  

        """
        this = _clipper_python_core.new_Xmap_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, spacegroup: 'Spacegroup', cell: 'Cell', grid_sam: 'Grid_sampling') -> "void":
        """


        initialiser: from spacegroup, cell, and grid  

        """
        return _clipper_python_core.Xmap_float_init(self, spacegroup, cell, grid_sam)


    def get_data(self, *args) -> "float const &":
        """


        get data by index (not recommended)  

        Accessing the data by index, rather than by Map_reference_index or
        Map_reference_coord, is generally to be avoided since the indices do not start
        at zero and do not increase contiguously. These methods are only useful when a
        large number of references into a map must be stored, e.g. for sorting into
        density order.  

        """
        return _clipper_python_core.Xmap_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by index (not recommended)  

        Accessing the data by index, rather than by Map_reference_index or
        Map_reference_coord, is generally to be avoided since the indices do not start
        at zero and do not increase contiguously. These methods are only useful when a
        large number of references into a map must be stored, e.g. for sorting into
        density order.  

        Returns
        -------
        true if data was set, i.e. index is valid.  

        """
        return _clipper_python_core.Xmap_float_set_data(self, *args)


    def __iadd__(self, other: 'Xmap_float') -> "clipper::Xmap< float > const &":
        return _clipper_python_core.Xmap_float___iadd__(self, other)

    def __isub__(self, other: 'Xmap_float') -> "clipper::Xmap< float > const &":
        return _clipper_python_core.Xmap_float___isub__(self, other)

    def get_reference_coord(self, pos: 'Coord_grid') -> "clipper::Xmap< float >::Map_reference_coord":
        return _clipper_python_core.Xmap_float_get_reference_coord(self, pos)

    def grid_sampling(self) -> "clipper::Grid_sampling const &":
        """


        """
        return _clipper_python_core.Xmap_float_grid_sampling(self)


    def cell(self) -> "clipper::Cell const &":
        """


        """
        return _clipper_python_core.Xmap_float_cell(self)


    def spacegroup(self) -> "clipper::Spacegroup const &":
        """


        """
        return _clipper_python_core.Xmap_float_spacegroup(self)


    def grid_asu(self) -> "clipper::Grid_range const &":
        """


        """
        return _clipper_python_core.Xmap_float_grid_asu(self)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Xmap_float_is_null(self)


    def _recalculate_stats(self) -> "std::vector< float,std::allocator< float > >":
        return _clipper_python_core.Xmap_float__recalculate_stats(self)

    def special_positions(self) -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _clipper_python_core.Xmap_float_special_positions(self)

    def special_positions_unit_cell_grid(self, frac_offset: 'double [3]') -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _clipper_python_core.Xmap_float_special_positions_unit_cell_grid(self, frac_offset)

    def special_positions_unit_cell_xyz(self, uc: 'Unit_Cell', frac_offset: 'double [3]') -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.Xmap_float_special_positions_unit_cell_xyz(self, uc, frac_offset)

    def export_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_float_export_numpy(self, *args)

    def import_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_float_import_numpy(self, *args)

    def _export_section_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_float__export_section_numpy(self, *args)

    def import_section_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_float_import_section_numpy(self, *args)

    def export_interpolated_box_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_float_export_interpolated_box_numpy(self, *args)

    def voxel_size(self) -> "void":
        return _clipper_python_core.Xmap_float_voxel_size(self)

    def voxel_size_frac(self) -> "void":
        return _clipper_python_core.Xmap_float_voxel_size_frac(self)

    def interp_cubic_frac_coord(self, f: 'Coord_frac') -> "float":
        return _clipper_python_core.Xmap_float_interp_cubic_frac_coord(self, f)

    def interp_cubic_xyz(self, numpy_1d_in: 'double [3]') -> "float":
        return _clipper_python_core.Xmap_float_interp_cubic_xyz(self, numpy_1d_in)

    def interp_linear_frac_coord(self, f: 'Coord_frac') -> "float":
        return _clipper_python_core.Xmap_float_interp_linear_frac_coord(self, f)

    def interp_linear_xyz(self, numpy_1d_in: 'double [3]') -> "float":
        return _clipper_python_core.Xmap_float_interp_linear_xyz(self, numpy_1d_in)

    def operator_orth_grid(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.Xmap_float_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.Xmap_float_operator_grid_orth(self)

    __stats = None
    def recalculate_stats(self):
      self.__stats = self._recalculate_stats()
#ifdef PYTHON_PROPERTIES
    @property
#endif
    def stats(self):
      if self.__stats is None:
        self.recalculate_stats()
      return self.__stats

#ifndef PYTHON_PROPERTIES
    def min(self):
      return self.stats()[0]
    def max(self):
      return self.stats()[1]
    def mean(self):
      return self.stats()[2]
    def sigma(self):
      return self.stats()[3]
    def skewness(self):
      return self.stats()[4]
    def kurtosis(self):
      return self.stats()[5]
#else
    @property
    def min(self):
      return self.stats[0]
    @property
    def max(self):
      return self.stats[1]
    @property
    def mean(self):
      return self.stats[2]
    @property
    def sigma(self):
      return self.stats[3]
    @property
    def skewness(self):
      return self.stats[4]
    @property
    def kurtosis(self):
      return self.stats[5]
#endif

    def export_section_numpy(self, start_coord_grid, end_coord_grid = None,
                            target = None, order = 'C', rot = 'xyz'):
      '''
      Export a section of the map into a Numpy array. Required arguments are a
      starting grid coordinate and either a finishing coordinate or a 3D Numpy
      array.
      Args:
        start_coord_grid:
          Minimum corner of the box in grid coordinates (either a Clipper
          Coord_grid or an iterable of 3 ints)
        end_coord_grid (default = None; incompatible with target):
          Maximum corner of the box in grid coordinates. If set, a Numpy array
          of the required size will be automatically created and filled.
        target (default = None; incompatible with end_coord_grid):
          A pre-initialised 3D Numpy array of doubles. If set, the end_grid_coord
          will be automatically calculated.
        order (default = 'C'):
          One of 'F' or 'C'. If 'C', the array will be filled in C-style row-major
          format (the default format of Numpy arrays). If 'F' it will be filled in
          Fortran-style column-major format.
        rot (default = 'xyz'):
          One of 'xyz' or 'zyx'. Some packages choose to store their data in xyz,
          others in zyx.
      '''
      if end_coord_grid is None and target is None:
        raise TypeError('Must provide either an end grid coordinate or a target Numpy array!')
      elif end_coord_grid is not None and target is not None:
        raise TypeError('Cannot specify both an end grid coordinate and a target array!')
      if end_coord_grid is not None:
        import numpy
    # Fill from start coord to end coord inclusive
        array_size = end_coord_grid - start_coord_grid + [1,1,1]
        if type(array_size) == Coord_grid:
#ifdef PYTHON_PROPERTIES
          array_size = array_size.uvw
#else
          array_size = array_size.get_uvw()
#endif
        if rot == 'zyx':
          array_size = array_size[::-1]
        _target = numpy.empty(array_size, numpy.double)
      else:
       _target = target
      result = self._export_section_numpy(_target, start_coord_grid, order, rot)
      if target is not None:
        return result
      return _target

#ifdef PYTHON_PROPERTIES

    _name = None

    @property
    def name(self):
      return self._name

    @name.setter
    def name(self, name):
      self._name = name

    _is_difference_map = False

    @property
    def is_difference_map(self):
      '''
      If true, this will be treated as a difference map (with positive
      and negative contours displayed, etc.).
      '''
      return self._is_difference_map

    @is_difference_map.setter
    def is_difference_map(self, isdiff):
      self._is_difference_map = isdiff

    grid = property(grid_sampling)
    grid_sampling = property(grid_sampling)
    cell = property(cell)
    spacegroup = property(spacegroup)
    operator_grid_orth = property(operator_grid_orth)
    operator_orth_grid = property(operator_orth_grid)
    voxel_size = property(voxel_size)
    voxel_size_frac = property(voxel_size_frac)
    grid_asu = property(grid_asu)
    is_null = property(is_null)

    @property
    def grid_samples(self):
      return self.grid.dim

#endif



    def fft_from(self, fb: 'HKL_data_F_phi_float') -> "void":
        """


        FFT from reflection list to map.  

        An FFT is calculated using the provided reflection list of F_phi, and used to
        fill this map. The reflection list is unchanged.  

        Parameters
        ----------
        * `fphidata` :  
            The reflection data list to use  

        """
        return _clipper_python_core.Xmap_float_fft_from(self, fb)


    def fft_to(self, fphidata: 'HKL_data_F_phi_float') -> "void":
        """


        FFT from map to reflection list.  

        The Fourier transform of this map is calculated and used to fill a reflection
        list of F_phi. The map is unchanged.  

        Arguably this should be part of hkl_data<F_phi<T>>. But that requires writing a
        specialisation of hkl_data for F_phi. This is simpler and imposes less demands
        on the compiler.  

        Parameters
        ----------
        * `fphidata` :  
            The reflection data list to set.  

        """
        return _clipper_python_core.Xmap_float_fft_to(self, fphidata)

    __swig_destroy__ = _clipper_python_core.delete_Xmap_float
    __del__ = lambda self: None
Xmap_float_swigregister = _clipper_python_core.Xmap_float_swigregister
Xmap_float_swigregister(Xmap_float)

class Xmap_double(Xmap_base):
    """


    Xmap<T>: actual crystallographic map class.  

    The crystallographic map class stores a map of arbitrary data type. Its main
    difference from a 3-d array is that the data extent appears to be infinite, and
    yet internally only a unique ASU is stored. Iterators provide efficient access
    to data.  

    This is derived from Xmap_base, and adds the templatised data itself and the
    methods which deal with it.  

    note: The following methods are inherited from Xmap_base but are documented here
        for convenience: cell(), spacegroup(), grid_sampling(), grid_asu(),
        in_asu(), multiplicity(), to_map_unit(), first(), first_coord().  

    C++ includes: xmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from spacegroup, cell, and grid  

        """
        this = _clipper_python_core.new_Xmap_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, spacegroup: 'Spacegroup', cell: 'Cell', grid_sam: 'Grid_sampling') -> "void":
        """


        initialiser: from spacegroup, cell, and grid  

        """
        return _clipper_python_core.Xmap_double_init(self, spacegroup, cell, grid_sam)


    def get_data(self, *args) -> "double const &":
        """


        get data by index (not recommended)  

        Accessing the data by index, rather than by Map_reference_index or
        Map_reference_coord, is generally to be avoided since the indices do not start
        at zero and do not increase contiguously. These methods are only useful when a
        large number of references into a map must be stored, e.g. for sorting into
        density order.  

        """
        return _clipper_python_core.Xmap_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by index (not recommended)  

        Accessing the data by index, rather than by Map_reference_index or
        Map_reference_coord, is generally to be avoided since the indices do not start
        at zero and do not increase contiguously. These methods are only useful when a
        large number of references into a map must be stored, e.g. for sorting into
        density order.  

        Returns
        -------
        true if data was set, i.e. index is valid.  

        """
        return _clipper_python_core.Xmap_double_set_data(self, *args)


    def __iadd__(self, other: 'Xmap_double') -> "clipper::Xmap< double > const &":
        return _clipper_python_core.Xmap_double___iadd__(self, other)

    def __isub__(self, other: 'Xmap_double') -> "clipper::Xmap< double > const &":
        return _clipper_python_core.Xmap_double___isub__(self, other)

    def get_reference_coord(self, pos: 'Coord_grid') -> "clipper::Xmap< double >::Map_reference_coord":
        return _clipper_python_core.Xmap_double_get_reference_coord(self, pos)

    def grid_sampling(self) -> "clipper::Grid_sampling const &":
        """


        """
        return _clipper_python_core.Xmap_double_grid_sampling(self)


    def cell(self) -> "clipper::Cell const &":
        """


        """
        return _clipper_python_core.Xmap_double_cell(self)


    def spacegroup(self) -> "clipper::Spacegroup const &":
        """


        """
        return _clipper_python_core.Xmap_double_spacegroup(self)


    def grid_asu(self) -> "clipper::Grid_range const &":
        """


        """
        return _clipper_python_core.Xmap_double_grid_asu(self)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Xmap_double_is_null(self)


    def _recalculate_stats(self) -> "std::vector< double,std::allocator< double > >":
        return _clipper_python_core.Xmap_double__recalculate_stats(self)

    def special_positions(self) -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _clipper_python_core.Xmap_double_special_positions(self)

    def special_positions_unit_cell_grid(self, frac_offset: 'double [3]') -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _clipper_python_core.Xmap_double_special_positions_unit_cell_grid(self, frac_offset)

    def special_positions_unit_cell_xyz(self, uc: 'Unit_Cell', frac_offset: 'double [3]') -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.Xmap_double_special_positions_unit_cell_xyz(self, uc, frac_offset)

    def export_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_double_export_numpy(self, *args)

    def import_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_double_import_numpy(self, *args)

    def _export_section_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_double__export_section_numpy(self, *args)

    def import_section_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_double_import_section_numpy(self, *args)

    def export_interpolated_box_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_double_export_interpolated_box_numpy(self, *args)

    def voxel_size(self) -> "void":
        return _clipper_python_core.Xmap_double_voxel_size(self)

    def voxel_size_frac(self) -> "void":
        return _clipper_python_core.Xmap_double_voxel_size_frac(self)

    def interp_cubic_frac_coord(self, f: 'Coord_frac') -> "double":
        return _clipper_python_core.Xmap_double_interp_cubic_frac_coord(self, f)

    def interp_cubic_xyz(self, numpy_1d_in: 'double [3]') -> "double":
        return _clipper_python_core.Xmap_double_interp_cubic_xyz(self, numpy_1d_in)

    def interp_linear_frac_coord(self, f: 'Coord_frac') -> "double":
        return _clipper_python_core.Xmap_double_interp_linear_frac_coord(self, f)

    def interp_linear_xyz(self, numpy_1d_in: 'double [3]') -> "double":
        return _clipper_python_core.Xmap_double_interp_linear_xyz(self, numpy_1d_in)

    def operator_orth_grid(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.Xmap_double_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.Xmap_double_operator_grid_orth(self)

    __stats = None
    def recalculate_stats(self):
      self.__stats = self._recalculate_stats()
#ifdef PYTHON_PROPERTIES
    @property
#endif
    def stats(self):
      if self.__stats is None:
        self.recalculate_stats()
      return self.__stats

#ifndef PYTHON_PROPERTIES
    def min(self):
      return self.stats()[0]
    def max(self):
      return self.stats()[1]
    def mean(self):
      return self.stats()[2]
    def sigma(self):
      return self.stats()[3]
    def skewness(self):
      return self.stats()[4]
    def kurtosis(self):
      return self.stats()[5]
#else
    @property
    def min(self):
      return self.stats[0]
    @property
    def max(self):
      return self.stats[1]
    @property
    def mean(self):
      return self.stats[2]
    @property
    def sigma(self):
      return self.stats[3]
    @property
    def skewness(self):
      return self.stats[4]
    @property
    def kurtosis(self):
      return self.stats[5]
#endif

    def export_section_numpy(self, start_coord_grid, end_coord_grid = None,
                            target = None, order = 'C', rot = 'xyz'):
      '''
      Export a section of the map into a Numpy array. Required arguments are a
      starting grid coordinate and either a finishing coordinate or a 3D Numpy
      array.
      Args:
        start_coord_grid:
          Minimum corner of the box in grid coordinates (either a Clipper
          Coord_grid or an iterable of 3 ints)
        end_coord_grid (default = None; incompatible with target):
          Maximum corner of the box in grid coordinates. If set, a Numpy array
          of the required size will be automatically created and filled.
        target (default = None; incompatible with end_coord_grid):
          A pre-initialised 3D Numpy array of doubles. If set, the end_grid_coord
          will be automatically calculated.
        order (default = 'C'):
          One of 'F' or 'C'. If 'C', the array will be filled in C-style row-major
          format (the default format of Numpy arrays). If 'F' it will be filled in
          Fortran-style column-major format.
        rot (default = 'xyz'):
          One of 'xyz' or 'zyx'. Some packages choose to store their data in xyz,
          others in zyx.
      '''
      if end_coord_grid is None and target is None:
        raise TypeError('Must provide either an end grid coordinate or a target Numpy array!')
      elif end_coord_grid is not None and target is not None:
        raise TypeError('Cannot specify both an end grid coordinate and a target array!')
      if end_coord_grid is not None:
        import numpy
    # Fill from start coord to end coord inclusive
        array_size = end_coord_grid - start_coord_grid + [1,1,1]
        if type(array_size) == Coord_grid:
#ifdef PYTHON_PROPERTIES
          array_size = array_size.uvw
#else
          array_size = array_size.get_uvw()
#endif
        if rot == 'zyx':
          array_size = array_size[::-1]
        _target = numpy.empty(array_size, numpy.double)
      else:
       _target = target
      result = self._export_section_numpy(_target, start_coord_grid, order, rot)
      if target is not None:
        return result
      return _target

#ifdef PYTHON_PROPERTIES

    _name = None

    @property
    def name(self):
      return self._name

    @name.setter
    def name(self, name):
      self._name = name

    _is_difference_map = False

    @property
    def is_difference_map(self):
      '''
      If true, this will be treated as a difference map (with positive
      and negative contours displayed, etc.).
      '''
      return self._is_difference_map

    @is_difference_map.setter
    def is_difference_map(self, isdiff):
      self._is_difference_map = isdiff

    grid = property(grid_sampling)
    grid_sampling = property(grid_sampling)
    cell = property(cell)
    spacegroup = property(spacegroup)
    operator_grid_orth = property(operator_grid_orth)
    operator_orth_grid = property(operator_orth_grid)
    voxel_size = property(voxel_size)
    voxel_size_frac = property(voxel_size_frac)
    grid_asu = property(grid_asu)
    is_null = property(is_null)

    @property
    def grid_samples(self):
      return self.grid.dim

#endif



    def fft_from(self, fb: 'HKL_data_F_phi_double') -> "void":
        """


        FFT from reflection list to map.  

        An FFT is calculated using the provided reflection list of F_phi, and used to
        fill this map. The reflection list is unchanged.  

        Parameters
        ----------
        * `fphidata` :  
            The reflection data list to use  

        """
        return _clipper_python_core.Xmap_double_fft_from(self, fb)


    def fft_to(self, fphidata: 'HKL_data_F_phi_float') -> "void":
        """


        FFT from map to reflection list.  

        The Fourier transform of this map is calculated and used to fill a reflection
        list of F_phi. The map is unchanged.  

        Arguably this should be part of hkl_data<F_phi<T>>. But that requires writing a
        specialisation of hkl_data for F_phi. This is simpler and imposes less demands
        on the compiler.  

        Parameters
        ----------
        * `fphidata` :  
            The reflection data list to set.  

        """
        return _clipper_python_core.Xmap_double_fft_to(self, fphidata)

    __swig_destroy__ = _clipper_python_core.delete_Xmap_double
    __del__ = lambda self: None
Xmap_double_swigregister = _clipper_python_core.Xmap_double_swigregister
Xmap_double_swigregister(Xmap_double)

class Xmap_int(Xmap_base):
    """


    Xmap<T>: actual crystallographic map class.  

    The crystallographic map class stores a map of arbitrary data type. Its main
    difference from a 3-d array is that the data extent appears to be infinite, and
    yet internally only a unique ASU is stored. Iterators provide efficient access
    to data.  

    This is derived from Xmap_base, and adds the templatised data itself and the
    methods which deal with it.  

    note: The following methods are inherited from Xmap_base but are documented here
        for convenience: cell(), spacegroup(), grid_sampling(), grid_asu(),
        in_asu(), multiplicity(), to_map_unit(), first(), first_coord().  

    C++ includes: xmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from spacegroup, cell, and grid  

        """
        this = _clipper_python_core.new_Xmap_int(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, spacegroup: 'Spacegroup', cell: 'Cell', grid_sam: 'Grid_sampling') -> "void":
        """


        initialiser: from spacegroup, cell, and grid  

        """
        return _clipper_python_core.Xmap_int_init(self, spacegroup, cell, grid_sam)


    def get_data(self, *args) -> "int const &":
        """


        get data by index (not recommended)  

        Accessing the data by index, rather than by Map_reference_index or
        Map_reference_coord, is generally to be avoided since the indices do not start
        at zero and do not increase contiguously. These methods are only useful when a
        large number of references into a map must be stored, e.g. for sorting into
        density order.  

        """
        return _clipper_python_core.Xmap_int_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by index (not recommended)  

        Accessing the data by index, rather than by Map_reference_index or
        Map_reference_coord, is generally to be avoided since the indices do not start
        at zero and do not increase contiguously. These methods are only useful when a
        large number of references into a map must be stored, e.g. for sorting into
        density order.  

        Returns
        -------
        true if data was set, i.e. index is valid.  

        """
        return _clipper_python_core.Xmap_int_set_data(self, *args)


    def __iadd__(self, other: 'Xmap_int') -> "clipper::Xmap< int > const &":
        return _clipper_python_core.Xmap_int___iadd__(self, other)

    def __isub__(self, other: 'Xmap_int') -> "clipper::Xmap< int > const &":
        return _clipper_python_core.Xmap_int___isub__(self, other)

    def get_reference_coord(self, pos: 'Coord_grid') -> "clipper::Xmap< int >::Map_reference_coord":
        return _clipper_python_core.Xmap_int_get_reference_coord(self, pos)

    def grid_sampling(self) -> "clipper::Grid_sampling const &":
        """


        """
        return _clipper_python_core.Xmap_int_grid_sampling(self)


    def cell(self) -> "clipper::Cell const &":
        """


        """
        return _clipper_python_core.Xmap_int_cell(self)


    def spacegroup(self) -> "clipper::Spacegroup const &":
        """


        """
        return _clipper_python_core.Xmap_int_spacegroup(self)


    def grid_asu(self) -> "clipper::Grid_range const &":
        """


        """
        return _clipper_python_core.Xmap_int_grid_asu(self)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        Returns
        -------
        true if the object has not been initalised.  

        """
        return _clipper_python_core.Xmap_int_is_null(self)


    def _recalculate_stats(self) -> "std::vector< int,std::allocator< int > >":
        return _clipper_python_core.Xmap_int__recalculate_stats(self)

    def special_positions(self) -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _clipper_python_core.Xmap_int_special_positions(self)

    def special_positions_unit_cell_grid(self, frac_offset: 'double [3]') -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _clipper_python_core.Xmap_int_special_positions_unit_cell_grid(self, frac_offset)

    def special_positions_unit_cell_xyz(self, uc: 'Unit_Cell', frac_offset: 'double [3]') -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.Xmap_int_special_positions_unit_cell_xyz(self, uc, frac_offset)

    def export_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_int_export_numpy(self, *args)

    def import_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_int_import_numpy(self, *args)

    def _export_section_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_int__export_section_numpy(self, *args)

    def import_section_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_int_import_section_numpy(self, *args)

    def export_interpolated_box_numpy(self, *args) -> "int":
        return _clipper_python_core.Xmap_int_export_interpolated_box_numpy(self, *args)

    def voxel_size(self) -> "void":
        return _clipper_python_core.Xmap_int_voxel_size(self)

    def voxel_size_frac(self) -> "void":
        return _clipper_python_core.Xmap_int_voxel_size_frac(self)

    def interp_cubic_frac_coord(self, f: 'Coord_frac') -> "int":
        return _clipper_python_core.Xmap_int_interp_cubic_frac_coord(self, f)

    def interp_cubic_xyz(self, numpy_1d_in: 'double [3]') -> "int":
        return _clipper_python_core.Xmap_int_interp_cubic_xyz(self, numpy_1d_in)

    def interp_linear_frac_coord(self, f: 'Coord_frac') -> "int":
        return _clipper_python_core.Xmap_int_interp_linear_frac_coord(self, f)

    def interp_linear_xyz(self, numpy_1d_in: 'double [3]') -> "int":
        return _clipper_python_core.Xmap_int_interp_linear_xyz(self, numpy_1d_in)

    def operator_orth_grid(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.Xmap_int_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.Xmap_int_operator_grid_orth(self)

    __stats = None
    def recalculate_stats(self):
      self.__stats = self._recalculate_stats()
#ifdef PYTHON_PROPERTIES
    @property
#endif
    def stats(self):
      if self.__stats is None:
        self.recalculate_stats()
      return self.__stats

#ifndef PYTHON_PROPERTIES
    def min(self):
      return self.stats()[0]
    def max(self):
      return self.stats()[1]
    def mean(self):
      return self.stats()[2]
    def sigma(self):
      return self.stats()[3]
    def skewness(self):
      return self.stats()[4]
    def kurtosis(self):
      return self.stats()[5]
#else
    @property
    def min(self):
      return self.stats[0]
    @property
    def max(self):
      return self.stats[1]
    @property
    def mean(self):
      return self.stats[2]
    @property
    def sigma(self):
      return self.stats[3]
    @property
    def skewness(self):
      return self.stats[4]
    @property
    def kurtosis(self):
      return self.stats[5]
#endif

    def export_section_numpy(self, start_coord_grid, end_coord_grid = None,
                            target = None, order = 'C', rot = 'xyz'):
      '''
      Export a section of the map into a Numpy array. Required arguments are a
      starting grid coordinate and either a finishing coordinate or a 3D Numpy
      array.
      Args:
        start_coord_grid:
          Minimum corner of the box in grid coordinates (either a Clipper
          Coord_grid or an iterable of 3 ints)
        end_coord_grid (default = None; incompatible with target):
          Maximum corner of the box in grid coordinates. If set, a Numpy array
          of the required size will be automatically created and filled.
        target (default = None; incompatible with end_coord_grid):
          A pre-initialised 3D Numpy array of doubles. If set, the end_grid_coord
          will be automatically calculated.
        order (default = 'C'):
          One of 'F' or 'C'. If 'C', the array will be filled in C-style row-major
          format (the default format of Numpy arrays). If 'F' it will be filled in
          Fortran-style column-major format.
        rot (default = 'xyz'):
          One of 'xyz' or 'zyx'. Some packages choose to store their data in xyz,
          others in zyx.
      '''
      if end_coord_grid is None and target is None:
        raise TypeError('Must provide either an end grid coordinate or a target Numpy array!')
      elif end_coord_grid is not None and target is not None:
        raise TypeError('Cannot specify both an end grid coordinate and a target array!')
      if end_coord_grid is not None:
        import numpy
    # Fill from start coord to end coord inclusive
        array_size = end_coord_grid - start_coord_grid + [1,1,1]
        if type(array_size) == Coord_grid:
#ifdef PYTHON_PROPERTIES
          array_size = array_size.uvw
#else
          array_size = array_size.get_uvw()
#endif
        if rot == 'zyx':
          array_size = array_size[::-1]
        _target = numpy.empty(array_size, numpy.double)
      else:
       _target = target
      result = self._export_section_numpy(_target, start_coord_grid, order, rot)
      if target is not None:
        return result
      return _target

#ifdef PYTHON_PROPERTIES

    _name = None

    @property
    def name(self):
      return self._name

    @name.setter
    def name(self, name):
      self._name = name

    _is_difference_map = False

    @property
    def is_difference_map(self):
      '''
      If true, this will be treated as a difference map (with positive
      and negative contours displayed, etc.).
      '''
      return self._is_difference_map

    @is_difference_map.setter
    def is_difference_map(self, isdiff):
      self._is_difference_map = isdiff

    grid = property(grid_sampling)
    grid_sampling = property(grid_sampling)
    cell = property(cell)
    spacegroup = property(spacegroup)
    operator_grid_orth = property(operator_grid_orth)
    operator_orth_grid = property(operator_orth_grid)
    voxel_size = property(voxel_size)
    voxel_size_frac = property(voxel_size_frac)
    grid_asu = property(grid_asu)
    is_null = property(is_null)

    @property
    def grid_samples(self):
      return self.grid.dim

#endif


    __swig_destroy__ = _clipper_python_core.delete_Xmap_int
    __del__ = lambda self: None
Xmap_int_swigregister = _clipper_python_core.Xmap_int_swigregister
Xmap_int_swigregister(Xmap_int)

class NXmap_float(NXmap_base):
    """


    NXmap<T>: actual non-crystallographic map class.  

    The non-crystallographic map class stores a map of arbitrary data type. Unlike
    an Xmap it is finite in extent and has no symmetry. An RT operator provides
    mapping onto an arbitrary orthogonal coordinate frame. Iterators provide
    efficient access to data.  

    This is derived from NXmap_base, and adds the templatised data itself and the
    methods which deal with it.  

    note: The following methods are inherited from NXmap_base but are documented
        here for convenience: grid(), coord_orth(), coord_grid(), first(),
        first_coord().  

    C++ includes: nxmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init(self, *args) -> "void":
        """


        initialiser: takes grid, cell, and fraction limits  

        Initialise an NXmap to some rhomboid chosen from within a crystal grid
        coordinate space, specified by a cell, sampling and box within that grid. This
        is useful for creating an NXmap which exactly matches some subregion of a
        crystallographic map.  

        Parameters
        ----------
        * `cell` :  
            Unit cell defining the crystal space.  
        * `grid` :  
            The grid sampling of the given unit cell.  
        * `grid_extent` :  
            The map extent within that cell.  

        """
        return _clipper_python_core.NXmap_float_init(self, *args)


    def get_data(self, pos: 'Coord_grid') -> "float const &":
        """


        get a density value for an arbitrary position  

        """
        return _clipper_python_core.NXmap_float_get_data(self, pos)


    def set_data(self, pos: 'Coord_grid', val: 'float const &') -> "void":
        """


        set a density value for an arbitrary position  

        """
        return _clipper_python_core.NXmap_float_set_data(self, pos, val)


    def __iadd__(self, other: 'NXmap_float') -> "clipper::NXmap< float > const &":
        return _clipper_python_core.NXmap_float___iadd__(self, other)

    def __isub__(self, other: 'NXmap_float') -> "clipper::NXmap< float > const &":
        return _clipper_python_core.NXmap_float___isub__(self, other)

    def __init__(self, *args):
        """


        Constructor: takes grid, cell, and extent.  

        Initialise an NXmap to some rhomboid chosen from within a crystal grid
        coordinate space, specified by a cell, sampling and box within that grid. This
        is useful for creating an NXmap which exactly matches some subregion of a
        crystallographic map.  

        Parameters
        ----------
        * `cell` :  
            Unit cell defining the crystal space.  
        * `grid` :  
            The grid sampling of the given unit cell.  
        * `grid_extent` :  
            The map extent within that cell.  

        """
        this = _clipper_python_core.new_NXmap_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def export_numpy(self, *args) -> "int":
        return _clipper_python_core.NXmap_float_export_numpy(self, *args)

    def import_numpy(self, *args) -> "int":
        return _clipper_python_core.NXmap_float_import_numpy(self, *args)

    def operator_orth_grid(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.NXmap_float_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.NXmap_float_operator_grid_orth(self)
    __swig_destroy__ = _clipper_python_core.delete_NXmap_float
    __del__ = lambda self: None
NXmap_float_swigregister = _clipper_python_core.NXmap_float_swigregister
NXmap_float_swigregister(NXmap_float)

class NXmap_double(NXmap_base):
    """


    NXmap<T>: actual non-crystallographic map class.  

    The non-crystallographic map class stores a map of arbitrary data type. Unlike
    an Xmap it is finite in extent and has no symmetry. An RT operator provides
    mapping onto an arbitrary orthogonal coordinate frame. Iterators provide
    efficient access to data.  

    This is derived from NXmap_base, and adds the templatised data itself and the
    methods which deal with it.  

    note: The following methods are inherited from NXmap_base but are documented
        here for convenience: grid(), coord_orth(), coord_grid(), first(),
        first_coord().  

    C++ includes: nxmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init(self, *args) -> "void":
        """


        initialiser: takes grid, cell, and fraction limits  

        Initialise an NXmap to some rhomboid chosen from within a crystal grid
        coordinate space, specified by a cell, sampling and box within that grid. This
        is useful for creating an NXmap which exactly matches some subregion of a
        crystallographic map.  

        Parameters
        ----------
        * `cell` :  
            Unit cell defining the crystal space.  
        * `grid` :  
            The grid sampling of the given unit cell.  
        * `grid_extent` :  
            The map extent within that cell.  

        """
        return _clipper_python_core.NXmap_double_init(self, *args)


    def get_data(self, pos: 'Coord_grid') -> "double const &":
        """


        get a density value for an arbitrary position  

        """
        return _clipper_python_core.NXmap_double_get_data(self, pos)


    def set_data(self, pos: 'Coord_grid', val: 'double const &') -> "void":
        """


        set a density value for an arbitrary position  

        """
        return _clipper_python_core.NXmap_double_set_data(self, pos, val)


    def __iadd__(self, other: 'NXmap_double') -> "clipper::NXmap< double > const &":
        return _clipper_python_core.NXmap_double___iadd__(self, other)

    def __isub__(self, other: 'NXmap_double') -> "clipper::NXmap< double > const &":
        return _clipper_python_core.NXmap_double___isub__(self, other)

    def __init__(self, *args):
        """


        Constructor: takes grid, cell, and extent.  

        Initialise an NXmap to some rhomboid chosen from within a crystal grid
        coordinate space, specified by a cell, sampling and box within that grid. This
        is useful for creating an NXmap which exactly matches some subregion of a
        crystallographic map.  

        Parameters
        ----------
        * `cell` :  
            Unit cell defining the crystal space.  
        * `grid` :  
            The grid sampling of the given unit cell.  
        * `grid_extent` :  
            The map extent within that cell.  

        """
        this = _clipper_python_core.new_NXmap_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def export_numpy(self, *args) -> "int":
        return _clipper_python_core.NXmap_double_export_numpy(self, *args)

    def import_numpy(self, *args) -> "int":
        return _clipper_python_core.NXmap_double_import_numpy(self, *args)

    def operator_orth_grid(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.NXmap_double_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.NXmap_double_operator_grid_orth(self)
    __swig_destroy__ = _clipper_python_core.delete_NXmap_double
    __del__ = lambda self: None
NXmap_double_swigregister = _clipper_python_core.NXmap_double_swigregister
NXmap_double_swigregister(NXmap_double)

class NXmap_int(NXmap_base):
    """


    NXmap<T>: actual non-crystallographic map class.  

    The non-crystallographic map class stores a map of arbitrary data type. Unlike
    an Xmap it is finite in extent and has no symmetry. An RT operator provides
    mapping onto an arbitrary orthogonal coordinate frame. Iterators provide
    efficient access to data.  

    This is derived from NXmap_base, and adds the templatised data itself and the
    methods which deal with it.  

    note: The following methods are inherited from NXmap_base but are documented
        here for convenience: grid(), coord_orth(), coord_grid(), first(),
        first_coord().  

    C++ includes: nxmap.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init(self, *args) -> "void":
        """


        initialiser: takes grid, cell, and fraction limits  

        Initialise an NXmap to some rhomboid chosen from within a crystal grid
        coordinate space, specified by a cell, sampling and box within that grid. This
        is useful for creating an NXmap which exactly matches some subregion of a
        crystallographic map.  

        Parameters
        ----------
        * `cell` :  
            Unit cell defining the crystal space.  
        * `grid` :  
            The grid sampling of the given unit cell.  
        * `grid_extent` :  
            The map extent within that cell.  

        """
        return _clipper_python_core.NXmap_int_init(self, *args)


    def get_data(self, pos: 'Coord_grid') -> "int const &":
        """


        get a density value for an arbitrary position  

        """
        return _clipper_python_core.NXmap_int_get_data(self, pos)


    def set_data(self, pos: 'Coord_grid', val: 'int const &') -> "void":
        """


        set a density value for an arbitrary position  

        """
        return _clipper_python_core.NXmap_int_set_data(self, pos, val)


    def __iadd__(self, other: 'NXmap_int') -> "clipper::NXmap< int > const &":
        return _clipper_python_core.NXmap_int___iadd__(self, other)

    def __isub__(self, other: 'NXmap_int') -> "clipper::NXmap< int > const &":
        return _clipper_python_core.NXmap_int___isub__(self, other)

    def __init__(self, *args):
        """


        Constructor: takes grid, cell, and extent.  

        Initialise an NXmap to some rhomboid chosen from within a crystal grid
        coordinate space, specified by a cell, sampling and box within that grid. This
        is useful for creating an NXmap which exactly matches some subregion of a
        crystallographic map.  

        Parameters
        ----------
        * `cell` :  
            Unit cell defining the crystal space.  
        * `grid` :  
            The grid sampling of the given unit cell.  
        * `grid_extent` :  
            The map extent within that cell.  

        """
        this = _clipper_python_core.new_NXmap_int(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def export_numpy(self, *args) -> "int":
        return _clipper_python_core.NXmap_int_export_numpy(self, *args)

    def import_numpy(self, *args) -> "int":
        return _clipper_python_core.NXmap_int_import_numpy(self, *args)

    def operator_orth_grid(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.NXmap_int_operator_orth_grid(self)

    def operator_grid_orth(self) -> "clipper::RTop< clipper::ftype >":
        return _clipper_python_core.NXmap_int_operator_grid_orth(self)
    __swig_destroy__ = _clipper_python_core.delete_NXmap_int
    __del__ = lambda self: None
NXmap_int_swigregister = _clipper_python_core.NXmap_int_swigregister
NXmap_int_swigregister(NXmap_int)

class CCP4MAPfile(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_CCP4MAPfile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CCP4MAPfile
    __del__ = lambda self: None

    def open_read(self, filename_in: 'String') -> "void":
        return _clipper_python_core.CCP4MAPfile_open_read(self, filename_in)

    def close_read(self) -> "void":
        return _clipper_python_core.CCP4MAPfile_close_read(self)

    def open_write(self, filename_out: 'String') -> "void":
        return _clipper_python_core.CCP4MAPfile_open_write(self, filename_out)

    def close_write(self) -> "void":
        return _clipper_python_core.CCP4MAPfile_close_write(self)

    def set_cell(self, cell: 'Cell') -> "void":
        return _clipper_python_core.CCP4MAPfile_set_cell(self, cell)

    def spacegroup(self) -> "clipper::Spacegroup const &":
        return _clipper_python_core.CCP4MAPfile_spacegroup(self)

    def cell(self) -> "clipper::Cell const &":
        return _clipper_python_core.CCP4MAPfile_cell(self)

    def grid_sampling(self) -> "clipper::Grid_sampling const &":
        return _clipper_python_core.CCP4MAPfile_grid_sampling(self)
    ASUCORRECT = _clipper_python_core.CCP4MAPfile_ASUCORRECT
    ASUINCOMPLETE = _clipper_python_core.CCP4MAPfile_ASUINCOMPLETE
    ASUINCONSISTENT = _clipper_python_core.CCP4MAPfile_ASUINCONSISTENT

    def import_xmap_float(self, xmap: 'Xmap_float') -> "void":
        return _clipper_python_core.CCP4MAPfile_import_xmap_float(self, xmap)

    def import_xmap_double(self, xmap: 'Xmap_double') -> "void":
        return _clipper_python_core.CCP4MAPfile_import_xmap_double(self, xmap)

    def export_xmap_float(self, xmap: 'Xmap_float') -> "void":
        return _clipper_python_core.CCP4MAPfile_export_xmap_float(self, xmap)

    def export_xmap_double(self, xmap: 'Xmap_double') -> "void":
        return _clipper_python_core.CCP4MAPfile_export_xmap_double(self, xmap)

    def import_nxmap_float(self, nxmap: 'NXmap_float') -> "void":
        return _clipper_python_core.CCP4MAPfile_import_nxmap_float(self, nxmap)

    def import_nxmap_double(self, nxmap: 'NXmap_double') -> "void":
        return _clipper_python_core.CCP4MAPfile_import_nxmap_double(self, nxmap)

    def export_nxmap_float(self, nxmap: 'NXmap_float') -> "void":
        return _clipper_python_core.CCP4MAPfile_export_nxmap_float(self, nxmap)

    def export_nxmap_double(self, nxmap: 'NXmap_double') -> "void":
        return _clipper_python_core.CCP4MAPfile_export_nxmap_double(self, nxmap)
CCP4MAPfile_swigregister = _clipper_python_core.CCP4MAPfile_swigregister
CCP4MAPfile_swigregister(CCP4MAPfile)

class MTZcrystal(Cell):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MTZcrystal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def crystal_name(self) -> "clipper::String const &":
        return _clipper_python_core.MTZcrystal_crystal_name(self)

    def project_name(self) -> "clipper::String const &":
        return _clipper_python_core.MTZcrystal_project_name(self)
    __swig_destroy__ = _clipper_python_core.delete_MTZcrystal
    __del__ = lambda self: None
MTZcrystal_swigregister = _clipper_python_core.MTZcrystal_swigregister
MTZcrystal_swigregister(MTZcrystal)

class MTZdataset(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MTZdataset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dataset_name(self) -> "clipper::String const &":
        return _clipper_python_core.MTZdataset_dataset_name(self)

    def wavelength(self) -> "clipper::ftype const &":
        return _clipper_python_core.MTZdataset_wavelength(self)
    __swig_destroy__ = _clipper_python_core.delete_MTZdataset
    __del__ = lambda self: None
MTZdataset_swigregister = _clipper_python_core.MTZdataset_swigregister
MTZdataset_swigregister(MTZdataset)

class CMTZcrystal(MTZcrystal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_CMTZcrystal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CMTZcrystal
    __del__ = lambda self: None
CMTZcrystal_swigregister = _clipper_python_core.CMTZcrystal_swigregister
CMTZcrystal_swigregister(CMTZcrystal)

class CMTZdataset(MTZdataset):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_CMTZdataset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CMTZdataset
    __del__ = lambda self: None
CMTZdataset_swigregister = _clipper_python_core.CMTZdataset_swigregister
CMTZdataset_swigregister(CMTZdataset)

class CCP4MTZ_type_registry(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_CCP4MTZ_type_registry()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    add_type = staticmethod(_clipper_python_core.CCP4MTZ_type_registry_add_type)
    type = staticmethod(_clipper_python_core.CCP4MTZ_type_registry_type)
    scale = staticmethod(_clipper_python_core.CCP4MTZ_type_registry_scale)
    add_group = staticmethod(_clipper_python_core.CCP4MTZ_type_registry_add_group)
    group_type = staticmethod(_clipper_python_core.CCP4MTZ_type_registry_group_type)
    __swig_destroy__ = _clipper_python_core.delete_CCP4MTZ_type_registry
    __del__ = lambda self: None
CCP4MTZ_type_registry_swigregister = _clipper_python_core.CCP4MTZ_type_registry_swigregister
CCP4MTZ_type_registry_swigregister(CCP4MTZ_type_registry)

def CCP4MTZ_type_registry_add_type(name: 'String', type: 'String', scale: 'clipper::ftype32 const &') -> "void":
    return _clipper_python_core.CCP4MTZ_type_registry_add_type(name, type, scale)
CCP4MTZ_type_registry_add_type = _clipper_python_core.CCP4MTZ_type_registry_add_type

def CCP4MTZ_type_registry_type(name: 'String') -> "clipper::String":
    return _clipper_python_core.CCP4MTZ_type_registry_type(name)
CCP4MTZ_type_registry_type = _clipper_python_core.CCP4MTZ_type_registry_type

def CCP4MTZ_type_registry_scale(name: 'String') -> "clipper::ftype32":
    return _clipper_python_core.CCP4MTZ_type_registry_scale(name)
CCP4MTZ_type_registry_scale = _clipper_python_core.CCP4MTZ_type_registry_scale

def CCP4MTZ_type_registry_add_group(name: 'String', type: 'String') -> "void":
    return _clipper_python_core.CCP4MTZ_type_registry_add_group(name, type)
CCP4MTZ_type_registry_add_group = _clipper_python_core.CCP4MTZ_type_registry_add_group

def CCP4MTZ_type_registry_group_type(name: 'String') -> "clipper::String":
    return _clipper_python_core.CCP4MTZ_type_registry_group_type(name)
CCP4MTZ_type_registry_group_type = _clipper_python_core.CCP4MTZ_type_registry_group_type

class CCP4MTZfile(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Default = _clipper_python_core.CCP4MTZfile_Default
    Normal = _clipper_python_core.CCP4MTZfile_Normal
    Legacy = _clipper_python_core.CCP4MTZfile_Legacy

    def __init__(self):
        this = _clipper_python_core.new_CCP4MTZfile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CCP4MTZfile
    __del__ = lambda self: None

    def open_read(self, filename_in: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_open_read(self, filename_in)

    def close_read(self) -> "void":
        return _clipper_python_core.CCP4MTZfile_close_read(self)

    def open_append(self, filename_in: 'String', filename_out: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_open_append(self, filename_in, filename_out)

    def close_append(self) -> "void":
        return _clipper_python_core.CCP4MTZfile_close_append(self)

    def open_write(self, filename_out: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_open_write(self, filename_out)

    def close_write(self) -> "void":
        return _clipper_python_core.CCP4MTZfile_close_write(self)

    def spacegroup(self) -> "clipper::Spacegroup const &":
        return _clipper_python_core.CCP4MTZfile_spacegroup(self)

    def cell(self) -> "clipper::Cell const &":
        return _clipper_python_core.CCP4MTZfile_cell(self)

    def resolution(self) -> "clipper::Resolution const &":
        return _clipper_python_core.CCP4MTZfile_resolution(self)

    def hkl_sampling(self) -> "clipper::HKL_sampling const &":
        return _clipper_python_core.CCP4MTZfile_hkl_sampling(self)

    def import_hkl_list(self, target: 'HKL_info') -> "void":
        return _clipper_python_core.CCP4MTZfile_import_hkl_list(self, target)

    def import_hkl_info(self, target: 'HKL_info', generate: 'bool const'=True) -> "void":
        return _clipper_python_core.CCP4MTZfile_import_hkl_info(self, target, generate)

    def import_crystal(self, cxtl: 'MTZcrystal', mtzpath: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_import_crystal(self, cxtl, mtzpath)

    def import_dataset(self, cset: 'MTZdataset', mtzpath: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_import_dataset(self, cset, mtzpath)

    def export_hkl_info(self, target: 'HKL_info') -> "void":
        return _clipper_python_core.CCP4MTZfile_export_hkl_info(self, target)

    def export_crystal(self, cxtl: 'MTZcrystal', mtzpath: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_export_crystal(self, cxtl, mtzpath)

    def export_dataset(self, cset: 'MTZdataset', mtzpath: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_export_dataset(self, cset, mtzpath)

    def import_chkl_data(self, *args) -> "void":
        return _clipper_python_core.CCP4MTZfile_import_chkl_data(self, *args)

    def export_chkl_data(self, target: 'Container &', mtzpath: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_export_chkl_data(self, target, mtzpath)

    def column_paths(self) -> "std::vector< clipper::String,std::allocator< clipper::String > >":
        return _clipper_python_core.CCP4MTZfile_column_paths(self)

    def title(self) -> "clipper::String":
        return _clipper_python_core.CCP4MTZfile_title(self)

    def set_title(self, title: 'String') -> "void":
        return _clipper_python_core.CCP4MTZfile_set_title(self, title)

    def history(self) -> "std::vector< clipper::String,std::allocator< clipper::String > >":
        return _clipper_python_core.CCP4MTZfile_history(self)

    def set_history(self, history: 'ClipperStringVector') -> "void":
        return _clipper_python_core.CCP4MTZfile_set_history(self, history)

    def num_reflections(self) -> "int":
        return _clipper_python_core.CCP4MTZfile_num_reflections(self)

    def sort_order(self) -> "std::vector< int,std::allocator< int > >":
        return _clipper_python_core.CCP4MTZfile_sort_order(self)

    def low_res_limit(self) -> "clipper::ftype32":
        return _clipper_python_core.CCP4MTZfile_low_res_limit(self)

    def high_res_limit(self) -> "clipper::ftype32":
        return _clipper_python_core.CCP4MTZfile_high_res_limit(self)

    def ccp4_spacegroup_number(self) -> "int":
        return _clipper_python_core.CCP4MTZfile_ccp4_spacegroup_number(self)

    def spacegroup_confidence(self) -> "char":
        return _clipper_python_core.CCP4MTZfile_spacegroup_confidence(self)

    def set_spacegroup_confidence(self, spg_confidence: 'char const &') -> "void":
        return _clipper_python_core.CCP4MTZfile_set_spacegroup_confidence(self, spg_confidence)

    def set_column_label_mode(self, mode: 'clipper::CCP4MTZfile::CCP4MTZcolumn_label_mode') -> "void":
        return _clipper_python_core.CCP4MTZfile_set_column_label_mode(self, mode)

    def set_verbose(self, verbose: 'int') -> "void":
        return _clipper_python_core.CCP4MTZfile_set_verbose(self, verbose)

    def column_labels(self) -> "std::vector< clipper::String,std::allocator< clipper::String > >":
        return _clipper_python_core.CCP4MTZfile_column_labels(self)

    def import_hkl_data(self, *args) -> "void":
        return _clipper_python_core.CCP4MTZfile_import_hkl_data(self, *args)

    def export_hkl_data(self, *args) -> "void":
        return _clipper_python_core.CCP4MTZfile_export_hkl_data(self, *args)

    open_read = log_clipper(open_read)
    import_hkl_data = log_clipper(import_hkl_data)

#ifdef PYTHON_PROPERTIES
    ccp4_spacegroup_number = property(ccp4_spacegroup_number)
    cell = property(cell)
    column_labels = property(column_labels)
    column_paths = property(column_paths)
    high_res_limit = property(high_res_limit)
    history = property(history)
    hkl_sampling = property(hkl_sampling)
    low_res_limit = property(low_res_limit)
    resolution = property(resolution)
    sort_order = property(sort_order)
    spacegroup = property(spacegroup)
#endif

CCP4MTZfile_swigregister = _clipper_python_core.CCP4MTZfile_swigregister
CCP4MTZfile_swigregister(CCP4MTZfile)

class CCP4CommandInput(StringVector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, argc: 'int', argv: 'char **', echo: 'bool'=False):
        this = _clipper_python_core.new_CCP4CommandInput(argc, argv, echo)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CCP4CommandInput
    __del__ = lambda self: None
CCP4CommandInput_swigregister = _clipper_python_core.CCP4CommandInput_swigregister
CCP4CommandInput_swigregister(CCP4CommandInput)

class CCP4Program(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, name: 'char const *', vers: 'char const *', rcsdate: 'char const *'):
        this = _clipper_python_core.new_CCP4Program(name, vers, rcsdate)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CCP4Program
    __del__ = lambda self: None

    def summary_beg(self) -> "void":
        return _clipper_python_core.CCP4Program_summary_beg(self)

    def summary_end(self) -> "void":
        return _clipper_python_core.CCP4Program_summary_end(self)

    def set_termination_message(self, msg: 'std::string') -> "void":
        return _clipper_python_core.CCP4Program_set_termination_message(self, msg)
CCP4Program_swigregister = _clipper_python_core.CCP4Program_swigregister
CCP4Program_swigregister(CCP4Program)

class Range_sampling(object):
    """


    Range sampling: discrete sampling of a real range.  

    C++ includes: clipper_stats.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from range and number of samplings  

        """
        this = _clipper_python_core.new_Range_sampling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def indexf(self, x: 'clipper::ftype const &') -> "clipper::ftype":
        """


        return fractional posn in counting range from x-value (0..n)  

        """
        return _clipper_python_core.Range_sampling_indexf(self, x)


    def index(self, x: 'clipper::ftype const &') -> "int":
        """


        return nearest index to particular x-value  

        """
        return _clipper_python_core.Range_sampling_index(self, x)


    def index_bounded(self, x: 'clipper::ftype const &') -> "int":
        """


        return nearest index to particular x-value (bounded 0...n-1)  

        """
        return _clipper_python_core.Range_sampling_index_bounded(self, x)


    def x(self, *args) -> "clipper::ftype":
        """


        return x-value corresponding to centre of i'th range  

        """
        return _clipper_python_core.Range_sampling_x(self, *args)


    def x_min(self, i: 'int const &') -> "clipper::ftype":
        """


        return x-value corresponding to bottom of i'th range  

        """
        return _clipper_python_core.Range_sampling_x_min(self, i)


    def x_max(self, i: 'int const &') -> "clipper::ftype":
        """


        return x-value corresponding to top of i'th range  

        """
        return _clipper_python_core.Range_sampling_x_max(self, i)


    def size(self) -> "int":
        """


        return number of samplings in range  

        """
        return _clipper_python_core.Range_sampling_size(self)

    __swig_destroy__ = _clipper_python_core.delete_Range_sampling
    __del__ = lambda self: None
Range_sampling_swigregister = _clipper_python_core.Range_sampling_swigregister
Range_sampling_swigregister(Range_sampling)

class Histogram(Range_sampling):
    """


    General histogram class.  

    This class is used to accumulate and access a histogram of values spread over a
    specified range. On storing data or retrieving by interpolation the range is
    checked.  

    C++ includes: clipper_stats.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from range and sampling  

        """
        this = _clipper_python_core.new_Histogram(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def accumulate(self, *args) -> "void":
        """


        add specified value to histogram (if it is in range)  

        """
        return _clipper_python_core.Histogram_accumulate(self, *args)


    def sum(self) -> "clipper::ftype":
        """


        return sum of whole histogram  

        """
        return _clipper_python_core.Histogram_sum(self)


    def y(self, *args) -> "clipper::ftype":
        """


        return value at interpolated position in histogram  

        """
        return _clipper_python_core.Histogram_y(self, *args)


    def __iadd__(self, h: 'Histogram') -> "clipper::Histogram const &":
        return _clipper_python_core.Histogram___iadd__(self, h)
    __swig_destroy__ = _clipper_python_core.delete_Histogram
    __del__ = lambda self: None
Histogram_swigregister = _clipper_python_core.Histogram_swigregister
Histogram_swigregister(Histogram)

class Generic_ordinal(object):
    """


    Generic ordinal gernerator.  

    This is a generic fast ordinal calculator. It is supplied with a list of values,
    from which it prepares a cumulative distribution function. This may the used to
    return the approximate fracitonal ordinal (in the range 0...1) for any given
    value from the distibution.  

    The distibution may be initialised by providing a vector of values from the
    distribution, or by adding the values and calling prep_ordinal().  

    This distribution may also be inverted. Generation of a value from an ordinal
    may be used for generating random values from a given distribution, or for
    histogram matching.  

    C++ includes: clipper_stats.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from range and sampling  

        """
        this = _clipper_python_core.new_Generic_ordinal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ordinal(self, value: 'clipper::ftype const &') -> "clipper::ftype":
        """


        return reflection ordinal  

        """
        return _clipper_python_core.Generic_ordinal_ordinal(self, value)


    def accumulate(self, *args) -> "void":
        """


        accumulate values to build the distribution  

        """
        return _clipper_python_core.Generic_ordinal_accumulate(self, *args)


    def prep_ordinal(self) -> "void":
        """


        generate the ordinal histogram  

        """
        return _clipper_python_core.Generic_ordinal_prep_ordinal(self)


    def invert(self) -> "void":
        """


        invert distribution to get value from ordinal  

        """
        return _clipper_python_core.Generic_ordinal_invert(self)


    def init(self, *args) -> "void":
        """


        DEPRECATED: initialiser: takes a number of bins for histogram.  

        """
        return _clipper_python_core.Generic_ordinal_init(self, *args)


    def add_pass_1(self, value: 'clipper::ftype const &') -> "void":
        """


        DEPRECATED: add a value to the distribution (pass 1 of 2)  

        """
        return _clipper_python_core.Generic_ordinal_add_pass_1(self, value)


    def add_pass_2(self, value: 'clipper::ftype const &') -> "void":
        """


        DEPRECATED: add a value to the distribution (pass 2 of 2)  

        """
        return _clipper_python_core.Generic_ordinal_add_pass_2(self, value)

    __swig_destroy__ = _clipper_python_core.delete_Generic_ordinal
    __del__ = lambda self: None
Generic_ordinal_swigregister = _clipper_python_core.Generic_ordinal_swigregister
Generic_ordinal_swigregister(Generic_ordinal)

class Map_stats(object):
    """


    Generic map statistics class.  

    This class is used to calculate and store the mean and standard deviation of a
    generic map object of scalar types (e.g. Xmap, NXmap). If the map contains NaN
    values, those points are excluded for the calculation. In the case of an Xmap,
    the proper multiplicty corrections are applied to give statistics for a whole
    unit cell  

    C++ includes: map_utils.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def mean(self) -> "clipper::ftype const &":
        """


        Mean of map.  

        """
        return _clipper_python_core.Map_stats_mean(self)


    def std_dev(self) -> "clipper::ftype const &":
        """


        Std deviation of map.  

        """
        return _clipper_python_core.Map_stats_std_dev(self)


    def min(self) -> "clipper::ftype const &":
        """


        Minimum of map.  

        """
        return _clipper_python_core.Map_stats_min(self)


    def max(self) -> "clipper::ftype const &":
        """


        Maximum of map.  

        """
        return _clipper_python_core.Map_stats_max(self)


    def _range_ptr(self) -> "clipper::Range< > const":
        """


        Range.  

        """
        return _clipper_python_core.Map_stats__range_ptr(self)


    def __init__(self, *args):
        """


        Constructor: from Xmap.  

        For float and double maps  map The map for which moments are to be calculated.  

        """
        this = _clipper_python_core.new_Map_stats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def range(self) -> "void":
        """


        Range.  

        """
        return _clipper_python_core.Map_stats_range(self)

    __swig_destroy__ = _clipper_python_core.delete_Map_stats
    __del__ = lambda self: None
Map_stats_swigregister = _clipper_python_core.Map_stats_swigregister
Map_stats_swigregister(Map_stats)

class Map_index_sort(object):
    """


    Generic map sorting class.  

    This class is used to sort a vector of integer indices into a map. This includes
    sorting the whole map to get highest or lowest density first, or sorting some
    subset, e.g. a list of peak indices. Integer indices are used because they are
    the most compact way of referencing a unique map location. e.g.  

    C++ includes: map_utils.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_Map_index_sort()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Map_index_sort
    __del__ = lambda self: None
Map_index_sort_swigregister = _clipper_python_core.Map_index_sort_swigregister
Map_index_sort_swigregister(Map_index_sort)

class Sig_Coord_orth(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_Sig_Coord_orth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def sigx(self) -> "clipper::ftype const &":
        return _clipper_python_core.Sig_Coord_orth_sigx(self)

    def sigy(self) -> "clipper::ftype const &":
        return _clipper_python_core.Sig_Coord_orth_sigy(self)

    def sigz(self) -> "clipper::ftype const &":
        return _clipper_python_core.Sig_Coord_orth_sigz(self)
    __swig_destroy__ = _clipper_python_core.delete_Sig_Coord_orth
    __del__ = lambda self: None
Sig_Coord_orth_swigregister = _clipper_python_core.Sig_Coord_orth_swigregister
Sig_Coord_orth_swigregister(Sig_Coord_orth)

class Sig_U_aniso_orth(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_Sig_U_aniso_orth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Sig_U_aniso_orth
    __del__ = lambda self: None
Sig_U_aniso_orth_swigregister = _clipper_python_core.Sig_U_aniso_orth_swigregister
Sig_U_aniso_orth_swigregister(Sig_U_aniso_orth)

class MMDBAtom(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MMDBAtom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def id(self) -> "clipper::String":
        return _clipper_python_core.MMDBAtom_id(self)

    def element(self) -> "clipper::String":
        return _clipper_python_core.MMDBAtom_element(self)

    def coord_orth(self) -> "clipper::Coord_orth":
        return _clipper_python_core.MMDBAtom_coord_orth(self)

    def occupancy(self) -> "clipper::ftype":
        return _clipper_python_core.MMDBAtom_occupancy(self)

    def u_iso(self) -> "clipper::ftype":
        return _clipper_python_core.MMDBAtom_u_iso(self)

    def u_aniso_orth(self) -> "clipper::U_aniso_orth":
        return _clipper_python_core.MMDBAtom_u_aniso_orth(self)

    def set_id(self, n: 'String') -> "void":
        return _clipper_python_core.MMDBAtom_set_id(self, n)

    def set_element(self, n: 'String') -> "void":
        return _clipper_python_core.MMDBAtom_set_element(self, n)

    def set_coord_orth(self, v: 'Coord_orth') -> "void":
        return _clipper_python_core.MMDBAtom_set_coord_orth(self, v)

    def set_occupancy(self, v: 'clipper::ftype const &') -> "void":
        return _clipper_python_core.MMDBAtom_set_occupancy(self, v)

    def set_u_iso(self, v: 'clipper::ftype const &') -> "void":
        return _clipper_python_core.MMDBAtom_set_u_iso(self, v)

    def set_u_aniso_orth(self, v: 'U_aniso_orth') -> "void":
        return _clipper_python_core.MMDBAtom_set_u_aniso_orth(self, v)

    def sig_coord_orth(self) -> "clipper::Sig_Coord_orth":
        return _clipper_python_core.MMDBAtom_sig_coord_orth(self)

    def sig_occupancy(self) -> "clipper::ftype":
        return _clipper_python_core.MMDBAtom_sig_occupancy(self)

    def sig_u_iso(self) -> "clipper::ftype":
        return _clipper_python_core.MMDBAtom_sig_u_iso(self)

    def sig_u_aniso_orth(self) -> "clipper::Sig_U_aniso_orth":
        return _clipper_python_core.MMDBAtom_sig_u_aniso_orth(self)

    def set_sig_coord_orth(self, s: 'Sig_Coord_orth') -> "void":
        return _clipper_python_core.MMDBAtom_set_sig_coord_orth(self, s)

    def set_sig_occupancy(self, s: 'clipper::ftype const &') -> "void":
        return _clipper_python_core.MMDBAtom_set_sig_occupancy(self, s)

    def set_sig_u_iso(self, s: 'clipper::ftype const &') -> "void":
        return _clipper_python_core.MMDBAtom_set_sig_u_iso(self, s)

    def set_sig_u_aniso_orth(self, s: 'Sig_U_aniso_orth') -> "void":
        return _clipper_python_core.MMDBAtom_set_sig_u_aniso_orth(self, s)

    def altconf(self) -> "clipper::String":
        return _clipper_python_core.MMDBAtom_altconf(self)

    def serial_num(self) -> "int":
        return _clipper_python_core.MMDBAtom_serial_num(self)

    def charge(self) -> "clipper::String":
        return _clipper_python_core.MMDBAtom_charge(self)
    __swig_destroy__ = _clipper_python_core.delete_MMDBAtom
    __del__ = lambda self: None
MMDBAtom_swigregister = _clipper_python_core.MMDBAtom_swigregister
MMDBAtom_swigregister(MMDBAtom)

class MMDBResidue(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MMDBResidue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def type(self) -> "clipper::String":
        return _clipper_python_core.MMDBResidue_type(self)

    def seqnum(self) -> "int":
        return _clipper_python_core.MMDBResidue_seqnum(self)

    def inscode(self) -> "clipper::String":
        return _clipper_python_core.MMDBResidue_inscode(self)

    def set_type(self, n: 'String') -> "void":
        return _clipper_python_core.MMDBResidue_set_type(self, n)

    def set_seqnum(self, n: 'int const &') -> "void":
        return _clipper_python_core.MMDBResidue_set_seqnum(self, n)

    def set_inscode(self, n: 'String') -> "void":
        return _clipper_python_core.MMDBResidue_set_inscode(self, n)
    __swig_destroy__ = _clipper_python_core.delete_MMDBResidue
    __del__ = lambda self: None
MMDBResidue_swigregister = _clipper_python_core.MMDBResidue_swigregister
MMDBResidue_swigregister(MMDBResidue)

class MMDBChain(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MMDBChain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def id(self) -> "clipper::String":
        return _clipper_python_core.MMDBChain_id(self)

    def set_id(self, n: 'String') -> "void":
        return _clipper_python_core.MMDBChain_set_id(self, n)
    __swig_destroy__ = _clipper_python_core.delete_MMDBChain
    __del__ = lambda self: None
MMDBChain_swigregister = _clipper_python_core.MMDBChain_swigregister
MMDBChain_swigregister(MMDBChain)

class MMDBModel(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MMDBModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def id(self) -> "clipper::String":
        return _clipper_python_core.MMDBModel_id(self)

    def set_id(self, n: 'String') -> "void":
        return _clipper_python_core.MMDBModel_set_id(self, n)
    __swig_destroy__ = _clipper_python_core.delete_MMDBModel
    __del__ = lambda self: None
MMDBModel_swigregister = _clipper_python_core.MMDBModel_swigregister
MMDBModel_swigregister(MMDBModel)

class MMDBManager(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Default = _clipper_python_core.MMDBManager_Default
    PDB = _clipper_python_core.MMDBManager_PDB
    CIF = _clipper_python_core.MMDBManager_CIF
    Binary = _clipper_python_core.MMDBManager_Binary

    def __init__(self):
        this = _clipper_python_core.new_MMDBManager()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MMDBManager
    __del__ = lambda self: None

    def spacegroup(self) -> "clipper::Spacegroup":
        return _clipper_python_core.MMDBManager_spacegroup(self)

    def cell(self) -> "clipper::Cell":
        return _clipper_python_core.MMDBManager_cell(self)

    def set_spacegroup(self, spacegroup: 'Spacegroup') -> "void":
        return _clipper_python_core.MMDBManager_set_spacegroup(self, spacegroup)

    def set_cell(self, cell: 'Cell') -> "void":
        return _clipper_python_core.MMDBManager_set_cell(self, cell)
MMDBManager_swigregister = _clipper_python_core.MMDBManager_swigregister
MMDBManager_swigregister(MMDBManager)

class MMDBAtom_list(Atom_list):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, ppcatom: 'clipper::mmdb::PPCAtom const', natom: 'int const'):
        this = _clipper_python_core.new_MMDBAtom_list(ppcatom, natom)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MMDBAtom_list
    __del__ = lambda self: None
MMDBAtom_list_swigregister = _clipper_python_core.MMDBAtom_list_swigregister
MMDBAtom_list_swigregister(MMDBAtom_list)

UNIQUE = _clipper_python_core.UNIQUE
ANY = _clipper_python_core.ANY
COPY_NONE = _clipper_python_core.COPY_NONE
COPY_M = _clipper_python_core.COPY_M
COPY_P = _clipper_python_core.COPY_P
COPY_MP = _clipper_python_core.COPY_MP
COPY_C = _clipper_python_core.COPY_C
COPY_MC = _clipper_python_core.COPY_MC
COPY_PC = _clipper_python_core.COPY_PC
COPY_MPC = _clipper_python_core.COPY_MPC
MEMBERS = _clipper_python_core.MEMBERS
PROPERTIES = _clipper_python_core.PROPERTIES
CHILDREN = _clipper_python_core.CHILDREN
class MAtom(Atom):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MAtom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def id(self) -> "clipper::String const &":
        return _clipper_python_core.MAtom_id(self)

    def set_id(self, s: 'String') -> "void":
        return _clipper_python_core.MAtom_set_id(self, s)

    def name(self) -> "clipper::String":
        return _clipper_python_core.MAtom_name(self)

    def set_name(self, *args) -> "void":
        return _clipper_python_core.MAtom_set_name(self, *args)

    def atom(self, *args) -> "clipper::Atom &":
        return _clipper_python_core.MAtom_atom(self, *args)

    def copy(self, other: 'MAtom', mode: 'clipper::MM::COPY const &') -> "clipper::MAtom &":
        return _clipper_python_core.MAtom_copy(self, other, mode)
    id_tidy = staticmethod(_clipper_python_core.MAtom_id_tidy)
    id_match = staticmethod(_clipper_python_core.MAtom_id_match)

    def __str__(self) -> "std::string":
        return _clipper_python_core.MAtom___str__(self)
    __swig_destroy__ = _clipper_python_core.delete_MAtom
    __del__ = lambda self: None
MAtom_swigregister = _clipper_python_core.MAtom_swigregister
MAtom_swigregister(MAtom)

def MAtom_id_tidy(id: 'String') -> "clipper::String":
    return _clipper_python_core.MAtom_id_tidy(id)
MAtom_id_tidy = _clipper_python_core.MAtom_id_tidy

def MAtom_id_match(id1: 'String', id2: 'String', mode: 'clipper::MM::MODE const &') -> "bool":
    return _clipper_python_core.MAtom_id_match(id1, id2, mode)
MAtom_id_match = _clipper_python_core.MAtom_id_match

class MMonomer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def id(self) -> "clipper::String const &":
        return _clipper_python_core.MMonomer_id(self)

    def set_id(self, s: 'String') -> "void":
        return _clipper_python_core.MMonomer_set_id(self, s)

    def type(self) -> "clipper::String const &":
        return _clipper_python_core.MMonomer_type(self)

    def set_type(self, s: 'String') -> "void":
        return _clipper_python_core.MMonomer_set_type(self, s)

    def seqnum(self) -> "int":
        return _clipper_python_core.MMonomer_seqnum(self)

    def set_seqnum(self, *args) -> "void":
        return _clipper_python_core.MMonomer_set_seqnum(self, *args)

    def atom_list(self) -> "clipper::Atom_list":
        return _clipper_python_core.MMonomer_atom_list(self)

    def transform(self, rt: 'RTop_orth') -> "void":
        return _clipper_python_core.MMonomer_transform(self, rt)

    def size(self) -> "int":
        return _clipper_python_core.MMonomer_size(self)

    def find(self, *args) -> "clipper::MAtom &":
        return _clipper_python_core.MMonomer_find(self, *args)

    def select(self, *args) -> "clipper::MMonomer":
        return _clipper_python_core.MMonomer_select(self, *args)

    def select_index(self, *args) -> "std::vector< int,std::allocator< int > >":
        return _clipper_python_core.MMonomer_select_index(self, *args)

    def lookup(self, str: 'String', mode: 'clipper::MM::MODE const &') -> "int":
        return _clipper_python_core.MMonomer_lookup(self, str, mode)

    def insert(self, add: 'MAtom', pos: 'int'=-1) -> "void":
        return _clipper_python_core.MMonomer_insert(self, add, pos)

    def copy(self, other: 'MMonomer', mode: 'clipper::MM::COPY const &') -> "clipper::MMonomer &":
        return _clipper_python_core.MMonomer_copy(self, other, mode)
    id_tidy = staticmethod(_clipper_python_core.MMonomer_id_tidy)
    id_match = staticmethod(_clipper_python_core.MMonomer_id_match)
    Default = _clipper_python_core.MMonomer_Default
    Dunbrack = _clipper_python_core.MMonomer_Dunbrack
    Richardson = _clipper_python_core.MMonomer_Richardson

    def protein_mainchain_build_carbonyl_oxygen(self, *args) -> "void":
        return _clipper_python_core.MMonomer_protein_mainchain_build_carbonyl_oxygen(self, *args)

    def protein_sidechain_number_of_rotamers(self, *args) -> "int":
        return _clipper_python_core.MMonomer_protein_sidechain_number_of_rotamers(self, *args)

    def protein_sidechain_number_of_rotomers(self) -> "int":
        return _clipper_python_core.MMonomer_protein_sidechain_number_of_rotomers(self)

    def protein_sidechain_build_rotamer(self, *args) -> "clipper::ftype":
        return _clipper_python_core.MMonomer_protein_sidechain_build_rotamer(self, *args)

    def protein_sidechain_build_rotomer(self, n: 'int const &') -> "clipper::ftype":
        return _clipper_python_core.MMonomer_protein_sidechain_build_rotomer(self, n)
    protein_peptide_bond = staticmethod(_clipper_python_core.MMonomer_protein_peptide_bond)
    protein_ramachandran_phi = staticmethod(_clipper_python_core.MMonomer_protein_ramachandran_phi)
    protein_ramachandran_psi = staticmethod(_clipper_python_core.MMonomer_protein_ramachandran_psi)
    default_type = staticmethod(_clipper_python_core.MMonomer_default_type)

    def __getitem__(self, i: 'int') -> "clipper::MAtom &":
        return _clipper_python_core.MMonomer___getitem__(self, i)

    def __setitem__(self, i: 'int', atom: 'MAtom') -> "void":
        return _clipper_python_core.MMonomer___setitem__(self, i, atom)

    def __len__(self) -> "size_t":
        return _clipper_python_core.MMonomer___len__(self)

    def __init__(self):
        this = _clipper_python_core.new_MMonomer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MMonomer
    __del__ = lambda self: None
MMonomer_swigregister = _clipper_python_core.MMonomer_swigregister
MMonomer_swigregister(MMonomer)

def and_MMonomer(m1: 'MMonomer', m2: 'MMonomer') -> "clipper::MMonomer":
    return _clipper_python_core.and_MMonomer(m1, m2)
and_MMonomer = _clipper_python_core.and_MMonomer

def or_MMonomer(m1: 'MMonomer', m2: 'MMonomer') -> "clipper::MMonomer":
    return _clipper_python_core.or_MMonomer(m1, m2)
or_MMonomer = _clipper_python_core.or_MMonomer

def MMonomer_id_tidy(id: 'String') -> "clipper::String":
    return _clipper_python_core.MMonomer_id_tidy(id)
MMonomer_id_tidy = _clipper_python_core.MMonomer_id_tidy

def MMonomer_id_match(id1: 'String', id2: 'String', mode: 'clipper::MM::MODE const &') -> "bool":
    return _clipper_python_core.MMonomer_id_match(id1, id2, mode)
MMonomer_id_match = _clipper_python_core.MMonomer_id_match

def MMonomer_protein_peptide_bond(m1: 'MMonomer', m2: 'MMonomer', r: 'clipper::ftype'=1.5) -> "bool":
    return _clipper_python_core.MMonomer_protein_peptide_bond(m1, m2, r)
MMonomer_protein_peptide_bond = _clipper_python_core.MMonomer_protein_peptide_bond

def MMonomer_protein_ramachandran_phi(m1: 'MMonomer', m2: 'MMonomer') -> "double":
    return _clipper_python_core.MMonomer_protein_ramachandran_phi(m1, m2)
MMonomer_protein_ramachandran_phi = _clipper_python_core.MMonomer_protein_ramachandran_phi

def MMonomer_protein_ramachandran_psi(m1: 'MMonomer', m2: 'MMonomer') -> "double":
    return _clipper_python_core.MMonomer_protein_ramachandran_psi(m1, m2)
MMonomer_protein_ramachandran_psi = _clipper_python_core.MMonomer_protein_ramachandran_psi

def MMonomer_default_type() -> "clipper::MMonomer::TYPE &":
    return _clipper_python_core.MMonomer_default_type()
MMonomer_default_type = _clipper_python_core.MMonomer_default_type

class MPolymer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def id(self) -> "clipper::String const &":
        return _clipper_python_core.MPolymer_id(self)

    def set_id(self, s: 'String') -> "void":
        return _clipper_python_core.MPolymer_set_id(self, s)

    def atom_list(self) -> "clipper::Atom_list":
        return _clipper_python_core.MPolymer_atom_list(self)

    def transform(self, rt: 'RTop_orth') -> "void":
        return _clipper_python_core.MPolymer_transform(self, rt)

    def size(self) -> "int":
        return _clipper_python_core.MPolymer_size(self)

    def find(self, *args) -> "clipper::MMonomer &":
        return _clipper_python_core.MPolymer_find(self, *args)

    def select(self, *args) -> "clipper::MPolymer":
        return _clipper_python_core.MPolymer_select(self, *args)

    def select_index(self, *args) -> "std::vector< int,std::allocator< int > >":
        return _clipper_python_core.MPolymer_select_index(self, *args)

    def lookup(self, str: 'String', mode: 'clipper::MM::MODE const &') -> "int":
        return _clipper_python_core.MPolymer_lookup(self, str, mode)

    def insert(self, add: 'MMonomer', pos: 'int'=-1) -> "void":
        return _clipper_python_core.MPolymer_insert(self, add, pos)

    def copy(self, other: 'MPolymer', mode: 'clipper::MM::COPY const &') -> "clipper::MPolymer &":
        return _clipper_python_core.MPolymer_copy(self, other, mode)
    id_tidy = staticmethod(_clipper_python_core.MPolymer_id_tidy)
    id_match = staticmethod(_clipper_python_core.MPolymer_id_match)

    def __getitem__(self, i: 'int') -> "clipper::MMonomer &":
        return _clipper_python_core.MPolymer___getitem__(self, i)

    def __setitem__(self, i: 'int', mmon: 'MMonomer') -> "void":
        return _clipper_python_core.MPolymer___setitem__(self, i, mmon)

    def __len__(self) -> "size_t":
        return _clipper_python_core.MPolymer___len__(self)

    def __init__(self):
        this = _clipper_python_core.new_MPolymer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MPolymer
    __del__ = lambda self: None
MPolymer_swigregister = _clipper_python_core.MPolymer_swigregister
MPolymer_swigregister(MPolymer)

def and_MPolymer(m1: 'MPolymer', m2: 'MPolymer') -> "clipper::MPolymer":
    return _clipper_python_core.and_MPolymer(m1, m2)
and_MPolymer = _clipper_python_core.and_MPolymer

def or_MPolymer(m1: 'MPolymer', m2: 'MPolymer') -> "clipper::MPolymer":
    return _clipper_python_core.or_MPolymer(m1, m2)
or_MPolymer = _clipper_python_core.or_MPolymer

def MPolymer_id_tidy(id: 'String') -> "clipper::String":
    return _clipper_python_core.MPolymer_id_tidy(id)
MPolymer_id_tidy = _clipper_python_core.MPolymer_id_tidy

def MPolymer_id_match(id1: 'String', id2: 'String', mode: 'clipper::MM::MODE const &') -> "bool":
    return _clipper_python_core.MPolymer_id_match(id1, id2, mode)
MPolymer_id_match = _clipper_python_core.MPolymer_id_match

class MModel(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def atom_list(self) -> "clipper::Atom_list":
        return _clipper_python_core.MModel_atom_list(self)

    def transform(self, rt: 'RTop_orth') -> "void":
        return _clipper_python_core.MModel_transform(self, rt)

    def size(self) -> "int":
        return _clipper_python_core.MModel_size(self)

    def find(self, *args) -> "clipper::MPolymer &":
        return _clipper_python_core.MModel_find(self, *args)

    def select(self, *args) -> "clipper::MModel":
        return _clipper_python_core.MModel_select(self, *args)

    def select_index(self, *args) -> "std::vector< int,std::allocator< int > >":
        return _clipper_python_core.MModel_select_index(self, *args)

    def lookup(self, str: 'String', mode: 'clipper::MM::MODE const &') -> "int":
        return _clipper_python_core.MModel_lookup(self, str, mode)

    def insert(self, add: 'MPolymer', pos: 'int'=-1) -> "void":
        return _clipper_python_core.MModel_insert(self, add, pos)

    def copy(self, other: 'MModel', mode: 'clipper::MM::COPY const &') -> "clipper::MModel &":
        return _clipper_python_core.MModel_copy(self, other, mode)

    def atom(self, *args) -> "clipper::MAtom &":
        return _clipper_python_core.MModel_atom(self, *args)

    def select_atom_index(self, *args) -> "std::vector< clipper::MAtomIndex,std::allocator< clipper::MAtomIndex > >":
        return _clipper_python_core.MModel_select_atom_index(self, *args)

    def __getitem__(self, i: 'int') -> "clipper::MPolymer &":
        return _clipper_python_core.MModel___getitem__(self, i)

    def __setitem__(self, i: 'int', mpol: 'MPolymer') -> "void":
        return _clipper_python_core.MModel___setitem__(self, i, mpol)

    def __len__(self) -> "size_t":
        return _clipper_python_core.MModel___len__(self)

    def __init__(self):
        this = _clipper_python_core.new_MModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MModel
    __del__ = lambda self: None
MModel_swigregister = _clipper_python_core.MModel_swigregister
MModel_swigregister(MModel)

def and_MModel(m1: 'MModel', m2: 'MModel') -> "clipper::MModel":
    return _clipper_python_core.and_MModel(m1, m2)
and_MModel = _clipper_python_core.and_MModel

def or_MModel(m1: 'MModel', m2: 'MModel') -> "clipper::MModel":
    return _clipper_python_core.or_MModel(m1, m2)
or_MModel = _clipper_python_core.or_MModel

class MiniMol(MModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    UNIQUE = _clipper_python_core.MiniMol_UNIQUE
    ANY = _clipper_python_core.MiniMol_ANY

    def __init__(self, *args):
        this = _clipper_python_core.new_MiniMol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, spacegroup: 'Spacegroup', cell: 'Cell') -> "void":
        return _clipper_python_core.MiniMol_init(self, spacegroup, cell)

    def cell(self) -> "clipper::Cell const &":
        return _clipper_python_core.MiniMol_cell(self)

    def spacegroup(self) -> "clipper::Spacegroup const &":
        return _clipper_python_core.MiniMol_spacegroup(self)

    def model(self, *args) -> "clipper::MModel &":
        return _clipper_python_core.MiniMol_model(self, *args)

    def symmetry_atom(self, index: 'clipper::MAtomIndexSymmetry const &') -> "clipper::MAtom":
        return _clipper_python_core.MiniMol_symmetry_atom(self, index)

    def is_null(self) -> "bool":
        return _clipper_python_core.MiniMol_is_null(self)
    __swig_destroy__ = _clipper_python_core.delete_MiniMol
    __del__ = lambda self: None
MiniMol_swigregister = _clipper_python_core.MiniMol_swigregister
MiniMol_swigregister(MiniMol)

class MMDBfile(MMDBManager):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def read_file(self, file: 'String') -> "void":
        return _clipper_python_core.MMDBfile_read_file(self, file)

    def write_file(self, *args) -> "void":
        return _clipper_python_core.MMDBfile_write_file(self, *args)

    def import_minimol(self, minimol: 'MiniMol', hnd: 'int const'=-1) -> "void":
        return _clipper_python_core.MMDBfile_import_minimol(self, minimol, hnd)

    def export_minimol(self, minimol: 'MiniMol') -> "void":
        return _clipper_python_core.MMDBfile_export_minimol(self, minimol)

    def __init__(self):
        this = _clipper_python_core.new_MMDBfile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MMDBfile
    __del__ = lambda self: None
MMDBfile_swigregister = _clipper_python_core.MMDBfile_swigregister
MMDBfile_swigregister(MMDBfile)

class SEQfile(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def read_file(self, file: 'String') -> "void":
        return _clipper_python_core.SEQfile_read_file(self, file)

    def import_polymer_sequence(self, target: 'MPolymerSequence &') -> "void":
        return _clipper_python_core.SEQfile_import_polymer_sequence(self, target)

    def import_molecule_sequence(self, target: 'MMoleculeSequence &') -> "void":
        return _clipper_python_core.SEQfile_import_molecule_sequence(self, target)

    def __init__(self):
        this = _clipper_python_core.new_SEQfile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_SEQfile
    __del__ = lambda self: None
SEQfile_swigregister = _clipper_python_core.SEQfile_swigregister
SEQfile_swigregister(SEQfile)

class MPolymerSequence(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_MPolymerSequence()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def id(self) -> "clipper::String const &":
        return _clipper_python_core.MPolymerSequence_id(self)

    def set_id(self, s: 'String') -> "void":
        return _clipper_python_core.MPolymerSequence_set_id(self, s)

    def sequence(self) -> "clipper::String const &":
        return _clipper_python_core.MPolymerSequence_sequence(self)

    def set_sequence(self, s: 'String') -> "void":
        return _clipper_python_core.MPolymerSequence_set_sequence(self, s)
    id_tidy = staticmethod(_clipper_python_core.MPolymerSequence_id_tidy)
    id_match = staticmethod(_clipper_python_core.MPolymerSequence_id_match)
    __swig_destroy__ = _clipper_python_core.delete_MPolymerSequence
    __del__ = lambda self: None
MPolymerSequence_swigregister = _clipper_python_core.MPolymerSequence_swigregister
MPolymerSequence_swigregister(MPolymerSequence)

def MPolymerSequence_id_tidy(id: 'String') -> "clipper::String":
    return _clipper_python_core.MPolymerSequence_id_tidy(id)
MPolymerSequence_id_tidy = _clipper_python_core.MPolymerSequence_id_tidy

def MPolymerSequence_id_match(id1: 'String', id2: 'String', mode: 'clipper::MM::MODE const &') -> "bool":
    return _clipper_python_core.MPolymerSequence_id_match(id1, id2, mode)
MPolymerSequence_id_match = _clipper_python_core.MPolymerSequence_id_match

class MMoleculeSequence(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def size(self) -> "int":
        return _clipper_python_core.MMoleculeSequence_size(self)

    def find(self, *args) -> "clipper::MPolymerSequence &":
        return _clipper_python_core.MMoleculeSequence_find(self, *args)

    def lookup(self, str: 'String', mode: 'clipper::MM::MODE const &') -> "int":
        return _clipper_python_core.MMoleculeSequence_lookup(self, str, mode)

    def insert(self, add: 'MPolymerSequence', pos: 'int'=-1) -> "void":
        return _clipper_python_core.MMoleculeSequence_insert(self, add, pos)

    def is_null(self) -> "bool":
        return _clipper_python_core.MMoleculeSequence_is_null(self)

    def __init__(self):
        this = _clipper_python_core.new_MMoleculeSequence()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_MMoleculeSequence
    __del__ = lambda self: None
MMoleculeSequence_swigregister = _clipper_python_core.MMoleculeSequence_swigregister
MMoleculeSequence_swigregister(MMoleculeSequence)

class MSequenceAlign(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    GLOBAL = _clipper_python_core.MSequenceAlign_GLOBAL
    LOCAL = _clipper_python_core.MSequenceAlign_LOCAL

    def __init__(self, *args):
        this = _clipper_python_core.new_MSequenceAlign(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, seq1: 'String', seq2: 'String') -> "std::pair< std::vector< int,std::allocator< int > >,std::vector< int,std::allocator< int > > >":
        return _clipper_python_core.MSequenceAlign___call__(self, seq1, seq2)
    __swig_destroy__ = _clipper_python_core.delete_MSequenceAlign
    __del__ = lambda self: None
MSequenceAlign_swigregister = _clipper_python_core.MSequenceAlign_swigregister
MSequenceAlign_swigregister(MSequenceAlign)

class Flag(object):
    """


    Reflection data type: Free-R flag.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_Flag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.Flag_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.Flag_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.Flag_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.Flag_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.Flag_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.Flag_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.Flag_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.Flag_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.Flag_data_import(self, array)


    def flag(self, *args) -> "int &":
        """


        """
        return _clipper_python_core.Flag_flag(self, *args)


    def _get_flag(self) -> "int":
        return _clipper_python_core.Flag__get_flag(self)

    def _set_flag(self, theFlag: 'int') -> "void":
        return _clipper_python_core.Flag__set_flag(self, theFlag)

    def copy(self) -> "clipper::datatypes::Flag":
        return _clipper_python_core.Flag_copy(self)

    @property
    def flag(self):
      return self._get_flag()

    @flag.setter
    def flag(self, theFlag):
      self._set_flag(theFlag)

    __swig_destroy__ = _clipper_python_core.delete_Flag
    __del__ = lambda self: None
Flag_swigregister = _clipper_python_core.Flag_swigregister
Flag_swigregister(Flag)

def Flag_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.Flag_type()

def Flag_data_size() -> "int":
    """


    """
    return _clipper_python_core.Flag_data_size()

def Flag_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.Flag_data_names()

class Flag_bool(object):
    """


    Reflection data type: boolean (false = missing)  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        """
        this = _clipper_python_core.new_Flag_bool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.Flag_bool_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.Flag_bool_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.Flag_bool_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.Flag_bool_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.Flag_bool_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.Flag_bool_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.Flag_bool_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.Flag_bool_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.Flag_bool_data_import(self, array)


    def flag(self, *args) -> "bool &":
        """


        """
        return _clipper_python_core.Flag_bool_flag(self, *args)


    def _get_flag(self) -> "bool":
        return _clipper_python_core.Flag_bool__get_flag(self)

    def _set_flag(self, theFlag: 'bool') -> "void":
        return _clipper_python_core.Flag_bool__set_flag(self, theFlag)

    def copy(self) -> "clipper::datatypes::Flag_bool":
        return _clipper_python_core.Flag_bool_copy(self)

    @property
    def state(self):
      return self._get_flag()

    @state.setter
    def state(self, theflag):
      self._set_flag(theflag)

    __swig_destroy__ = _clipper_python_core.delete_Flag_bool
    __del__ = lambda self: None
Flag_bool_swigregister = _clipper_python_core.Flag_bool_swigregister
Flag_bool_swigregister(Flag_bool)

def Flag_bool_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.Flag_bool_type()

def Flag_bool_data_size() -> "int":
    """


    """
    return _clipper_python_core.Flag_bool_data_size()

def Flag_bool_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.Flag_bool_data_names()

class F_sigF_float(object):
    """


    Reflection data type: F + sigF.  

    Note that F_sigF also has methods for returning f_pl(), sigf_pl(), f_mi,
    sigf_mi(), so you can use this type in any template type where you would use
    F_sigF_ano.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_F_sigF_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_float_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_float_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.F_sigF_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.F_sigF_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_float_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_float_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.F_sigF_float_scale(self, s)


    def f(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_float_f(self, *args)


    def sigf(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_float_sigf(self, *args)


    def f_pl(self) -> "float const &":
        """


        """
        return _clipper_python_core.F_sigF_float_f_pl(self)


    def sigf_pl(self) -> "float const &":
        """


        """
        return _clipper_python_core.F_sigF_float_sigf_pl(self)


    def f_mi(self) -> "float const &":
        """


        """
        return _clipper_python_core.F_sigF_float_f_mi(self)


    def sigf_mi(self) -> "float const &":
        """


        """
        return _clipper_python_core.F_sigF_float_sigf_mi(self)


    def cov(self) -> "float":
        """


        """
        return _clipper_python_core.F_sigF_float_cov(self)


    def copy(self) -> "clipper::datatypes::F_sigF< float >":
        return _clipper_python_core.F_sigF_float_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_F_sigF_float
    __del__ = lambda self: None
F_sigF_float_swigregister = _clipper_python_core.F_sigF_float_swigregister
F_sigF_float_swigregister(F_sigF_float)

def F_sigF_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_float_type()

def F_sigF_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.F_sigF_float_data_size()

def F_sigF_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_float_data_names()

class F_sigF_double(object):
    """


    Reflection data type: F + sigF.  

    Note that F_sigF also has methods for returning f_pl(), sigf_pl(), f_mi,
    sigf_mi(), so you can use this type in any template type where you would use
    F_sigF_ano.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_F_sigF_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_double_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_double_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.F_sigF_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.F_sigF_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_double_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_double_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.F_sigF_double_scale(self, s)


    def f(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_double_f(self, *args)


    def sigf(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_double_sigf(self, *args)


    def f_pl(self) -> "double const &":
        """


        """
        return _clipper_python_core.F_sigF_double_f_pl(self)


    def sigf_pl(self) -> "double const &":
        """


        """
        return _clipper_python_core.F_sigF_double_sigf_pl(self)


    def f_mi(self) -> "double const &":
        """


        """
        return _clipper_python_core.F_sigF_double_f_mi(self)


    def sigf_mi(self) -> "double const &":
        """


        """
        return _clipper_python_core.F_sigF_double_sigf_mi(self)


    def cov(self) -> "double":
        """


        """
        return _clipper_python_core.F_sigF_double_cov(self)


    def copy(self) -> "clipper::datatypes::F_sigF< double >":
        return _clipper_python_core.F_sigF_double_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_F_sigF_double
    __del__ = lambda self: None
F_sigF_double_swigregister = _clipper_python_core.F_sigF_double_swigregister
F_sigF_double_swigregister(F_sigF_double)

def F_sigF_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_double_type()

def F_sigF_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.F_sigF_double_data_size()

def F_sigF_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_double_data_names()

class F_sigF_ano_float(object):
    """


    Reflection data type: F(+) F(+) sigF(+) sigF(-) cov+-.  

    Note that F_sigF_ano also has methods for returning f(), sigf(), so you can use
    this type in any template type where you would use F_sigF.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        """
        this = _clipper_python_core.new_F_sigF_ano_float()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, a: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_data_export(self, a)


    def data_import(self, a: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_data_import(self, a)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.F_sigF_ano_float_scale(self, s)


    def f_pl(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_f_pl(self, *args)


    def sigf_pl(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_sigf_pl(self, *args)


    def f_mi(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_f_mi(self, *args)


    def sigf_mi(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_sigf_mi(self, *args)


    def cov(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_cov(self, *args)


    def f(self) -> "float":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_f(self)


    def sigf(self) -> "float":
        """


        """
        return _clipper_python_core.F_sigF_ano_float_sigf(self)


    def copy(self) -> "clipper::datatypes::F_sigF_ano< float >":
        return _clipper_python_core.F_sigF_ano_float_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_F_sigF_ano_float
    __del__ = lambda self: None
F_sigF_ano_float_swigregister = _clipper_python_core.F_sigF_ano_float_swigregister
F_sigF_ano_float_swigregister(F_sigF_ano_float)

def F_sigF_ano_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_ano_float_type()

def F_sigF_ano_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.F_sigF_ano_float_data_size()

def F_sigF_ano_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_ano_float_data_names()

class F_sigF_ano_double(object):
    """


    Reflection data type: F(+) F(+) sigF(+) sigF(-) cov+-.  

    Note that F_sigF_ano also has methods for returning f(), sigf(), so you can use
    this type in any template type where you would use F_sigF.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        """
        this = _clipper_python_core.new_F_sigF_ano_double()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, a: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_data_export(self, a)


    def data_import(self, a: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_data_import(self, a)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.F_sigF_ano_double_scale(self, s)


    def f_pl(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_f_pl(self, *args)


    def sigf_pl(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_sigf_pl(self, *args)


    def f_mi(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_f_mi(self, *args)


    def sigf_mi(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_sigf_mi(self, *args)


    def cov(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_cov(self, *args)


    def f(self) -> "double":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_f(self)


    def sigf(self) -> "double":
        """


        """
        return _clipper_python_core.F_sigF_ano_double_sigf(self)


    def copy(self) -> "clipper::datatypes::F_sigF_ano< double >":
        return _clipper_python_core.F_sigF_ano_double_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_F_sigF_ano_double
    __del__ = lambda self: None
F_sigF_ano_double_swigregister = _clipper_python_core.F_sigF_ano_double_swigregister
F_sigF_ano_double_swigregister(F_sigF_ano_double)

def F_sigF_ano_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_ano_double_type()

def F_sigF_ano_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.F_sigF_ano_double_data_size()

def F_sigF_ano_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_sigF_ano_double_data_names()

class I_sigI_float(object):
    """


    Reflection data type: I + sigI.  

    Note that I_sigI also has methods for returning I_pl(), sigI_pl(), I_mi,
    sigI_mi(), so you can use this type in any template type where you would use
    I_sigI_ano.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_I_sigI_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.I_sigI_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.I_sigI_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.I_sigI_float_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.I_sigI_float_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.I_sigI_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.I_sigI_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.I_sigI_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.I_sigI_float_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.I_sigI_float_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.I_sigI_float_scale(self, s)


    def I(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.I_sigI_float_I(self, *args)


    def sigI(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.I_sigI_float_sigI(self, *args)


    def I_pl(self) -> "float const &":
        """


        """
        return _clipper_python_core.I_sigI_float_I_pl(self)


    def sigI_pl(self) -> "float const &":
        """


        """
        return _clipper_python_core.I_sigI_float_sigI_pl(self)


    def I_mi(self) -> "float const &":
        """


        """
        return _clipper_python_core.I_sigI_float_I_mi(self)


    def sigI_mi(self) -> "float const &":
        """


        """
        return _clipper_python_core.I_sigI_float_sigI_mi(self)


    def cov(self) -> "float":
        """


        """
        return _clipper_python_core.I_sigI_float_cov(self)


    def copy(self) -> "clipper::datatypes::I_sigI< float >":
        return _clipper_python_core.I_sigI_float_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_I_sigI_float
    __del__ = lambda self: None
I_sigI_float_swigregister = _clipper_python_core.I_sigI_float_swigregister
I_sigI_float_swigregister(I_sigI_float)

def I_sigI_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.I_sigI_float_type()

def I_sigI_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.I_sigI_float_data_size()

def I_sigI_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.I_sigI_float_data_names()

class I_sigI_double(object):
    """


    Reflection data type: I + sigI.  

    Note that I_sigI also has methods for returning I_pl(), sigI_pl(), I_mi,
    sigI_mi(), so you can use this type in any template type where you would use
    I_sigI_ano.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_I_sigI_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.I_sigI_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.I_sigI_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.I_sigI_double_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.I_sigI_double_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.I_sigI_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.I_sigI_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.I_sigI_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.I_sigI_double_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.I_sigI_double_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.I_sigI_double_scale(self, s)


    def I(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.I_sigI_double_I(self, *args)


    def sigI(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.I_sigI_double_sigI(self, *args)


    def I_pl(self) -> "double const &":
        """


        """
        return _clipper_python_core.I_sigI_double_I_pl(self)


    def sigI_pl(self) -> "double const &":
        """


        """
        return _clipper_python_core.I_sigI_double_sigI_pl(self)


    def I_mi(self) -> "double const &":
        """


        """
        return _clipper_python_core.I_sigI_double_I_mi(self)


    def sigI_mi(self) -> "double const &":
        """


        """
        return _clipper_python_core.I_sigI_double_sigI_mi(self)


    def cov(self) -> "double":
        """


        """
        return _clipper_python_core.I_sigI_double_cov(self)


    def copy(self) -> "clipper::datatypes::I_sigI< double >":
        return _clipper_python_core.I_sigI_double_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_I_sigI_double
    __del__ = lambda self: None
I_sigI_double_swigregister = _clipper_python_core.I_sigI_double_swigregister
I_sigI_double_swigregister(I_sigI_double)

def I_sigI_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.I_sigI_double_type()

def I_sigI_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.I_sigI_double_data_size()

def I_sigI_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.I_sigI_double_data_names()

class E_sigE_float(object):
    """


    Reflection data type: E + sigE.  

    This is not strictly a type for storing E values, but rather a type for storing
    any sturcture factor magnitude-like quantity which has already had a symmetry
    enhancement factor (epsilon) removed from it. E's are most commonly stored in
    this form, wheras F's and U's are not. You can compute corrected F's from
    uncorrected F's using:  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_E_sigE_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.E_sigE_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.E_sigE_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.E_sigE_float_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.E_sigE_float_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.E_sigE_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.E_sigE_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.E_sigE_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.E_sigE_float_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.E_sigE_float_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.E_sigE_float_scale(self, s)


    def E(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.E_sigE_float_E(self, *args)


    def sigE(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.E_sigE_float_sigE(self, *args)


    def E_pl(self) -> "float const &":
        """


        """
        return _clipper_python_core.E_sigE_float_E_pl(self)


    def sigE_pl(self) -> "float const &":
        """


        """
        return _clipper_python_core.E_sigE_float_sigE_pl(self)


    def E_mi(self) -> "float const &":
        """


        """
        return _clipper_python_core.E_sigE_float_E_mi(self)


    def sigE_mi(self) -> "float const &":
        """


        """
        return _clipper_python_core.E_sigE_float_sigE_mi(self)


    def cov(self) -> "float":
        """


        """
        return _clipper_python_core.E_sigE_float_cov(self)


    def copy(self) -> "clipper::datatypes::E_sigE< float >":
        return _clipper_python_core.E_sigE_float_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_E_sigE_float
    __del__ = lambda self: None
E_sigE_float_swigregister = _clipper_python_core.E_sigE_float_swigregister
E_sigE_float_swigregister(E_sigE_float)

def E_sigE_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.E_sigE_float_type()

def E_sigE_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.E_sigE_float_data_size()

def E_sigE_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.E_sigE_float_data_names()

class E_sigE_double(object):
    """


    Reflection data type: E + sigE.  

    This is not strictly a type for storing E values, but rather a type for storing
    any sturcture factor magnitude-like quantity which has already had a symmetry
    enhancement factor (epsilon) removed from it. E's are most commonly stored in
    this form, wheras F's and U's are not. You can compute corrected F's from
    uncorrected F's using:  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_E_sigE_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.E_sigE_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.E_sigE_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.E_sigE_double_friedel(self)


    def shift_phase(self, arg2: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.E_sigE_double_shift_phase(self, arg2)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.E_sigE_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.E_sigE_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.E_sigE_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.E_sigE_double_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.E_sigE_double_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.E_sigE_double_scale(self, s)


    def E(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.E_sigE_double_E(self, *args)


    def sigE(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.E_sigE_double_sigE(self, *args)


    def E_pl(self) -> "double const &":
        """


        """
        return _clipper_python_core.E_sigE_double_E_pl(self)


    def sigE_pl(self) -> "double const &":
        """


        """
        return _clipper_python_core.E_sigE_double_sigE_pl(self)


    def E_mi(self) -> "double const &":
        """


        """
        return _clipper_python_core.E_sigE_double_E_mi(self)


    def sigE_mi(self) -> "double const &":
        """


        """
        return _clipper_python_core.E_sigE_double_sigE_mi(self)


    def cov(self) -> "double":
        """


        """
        return _clipper_python_core.E_sigE_double_cov(self)


    def copy(self) -> "clipper::datatypes::E_sigE< double >":
        return _clipper_python_core.E_sigE_double_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_E_sigE_double
    __del__ = lambda self: None
E_sigE_double_swigregister = _clipper_python_core.E_sigE_double_swigregister
E_sigE_double_swigregister(E_sigE_double)

def E_sigE_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.E_sigE_double_type()

def E_sigE_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.E_sigE_double_data_size()

def E_sigE_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.E_sigE_double_data_names()

class ABCD_float(object):
    """


    Reflection data type: Hendrickson-Lattman coeff.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_ABCD_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.ABCD_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.ABCD_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.ABCD_float_friedel(self)


    def shift_phase(self, dphi: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.ABCD_float_shift_phase(self, dphi)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.ABCD_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.ABCD_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.ABCD_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.ABCD_float_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.ABCD_float_data_import(self, array)


    def a(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.ABCD_float_a(self, *args)


    def b(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.ABCD_float_b(self, *args)


    def c(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.ABCD_float_c(self, *args)


    def d(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.ABCD_float_d(self, *args)


    def copy(self) -> "clipper::datatypes::ABCD< float >":
        return _clipper_python_core.ABCD_float_copy(self)

    def __add__(self, h2: 'ABCD_float') -> "clipper::datatypes::ABCD< float >":
        return _clipper_python_core.ABCD_float___add__(self, h2)

    def vals(self) -> "void":
        return _clipper_python_core.ABCD_float_vals(self)
    __swig_destroy__ = _clipper_python_core.delete_ABCD_float
    __del__ = lambda self: None
ABCD_float_swigregister = _clipper_python_core.ABCD_float_swigregister
ABCD_float_swigregister(ABCD_float)

def ABCD_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.ABCD_float_type()

def ABCD_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.ABCD_float_data_size()

def ABCD_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.ABCD_float_data_names()

class ABCD_double(object):
    """


    Reflection data type: Hendrickson-Lattman coeff.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_ABCD_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.ABCD_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.ABCD_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.ABCD_double_friedel(self)


    def shift_phase(self, dphi: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.ABCD_double_shift_phase(self, dphi)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.ABCD_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.ABCD_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.ABCD_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.ABCD_double_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.ABCD_double_data_import(self, array)


    def a(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.ABCD_double_a(self, *args)


    def b(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.ABCD_double_b(self, *args)


    def c(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.ABCD_double_c(self, *args)


    def d(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.ABCD_double_d(self, *args)


    def copy(self) -> "clipper::datatypes::ABCD< double >":
        return _clipper_python_core.ABCD_double_copy(self)

    def __add__(self, h2: 'ABCD_double') -> "clipper::datatypes::ABCD< double >":
        return _clipper_python_core.ABCD_double___add__(self, h2)

    def vals(self) -> "void":
        return _clipper_python_core.ABCD_double_vals(self)
    __swig_destroy__ = _clipper_python_core.delete_ABCD_double
    __del__ = lambda self: None
ABCD_double_swigregister = _clipper_python_core.ABCD_double_swigregister
ABCD_double_swigregister(ABCD_double)

def ABCD_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.ABCD_double_type()

def ABCD_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.ABCD_double_data_size()

def ABCD_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.ABCD_double_data_names()

class Phi_fom_float(object):
    """


    Reflection data type: best phi + fom.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_Phi_fom_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.Phi_fom_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_float_friedel(self)


    def shift_phase(self, dphi: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_float_shift_phase(self, dphi)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.Phi_fom_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.Phi_fom_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.Phi_fom_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_float_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_float_data_import(self, array)


    def phi(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.Phi_fom_float_phi(self, *args)


    def fom(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.Phi_fom_float_fom(self, *args)

    __swig_destroy__ = _clipper_python_core.delete_Phi_fom_float
    __del__ = lambda self: None
Phi_fom_float_swigregister = _clipper_python_core.Phi_fom_float_swigregister
Phi_fom_float_swigregister(Phi_fom_float)

def Phi_fom_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.Phi_fom_float_type()

def Phi_fom_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.Phi_fom_float_data_size()

def Phi_fom_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.Phi_fom_float_data_names()

class Phi_fom_double(object):
    """


    Reflection data type: best phi + fom.  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_Phi_fom_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.Phi_fom_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_double_friedel(self)


    def shift_phase(self, dphi: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_double_shift_phase(self, dphi)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.Phi_fom_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.Phi_fom_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.Phi_fom_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_double_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.Phi_fom_double_data_import(self, array)


    def phi(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.Phi_fom_double_phi(self, *args)


    def fom(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.Phi_fom_double_fom(self, *args)

    __swig_destroy__ = _clipper_python_core.delete_Phi_fom_double
    __del__ = lambda self: None
Phi_fom_double_swigregister = _clipper_python_core.Phi_fom_double_swigregister
Phi_fom_double_swigregister(Phi_fom_double)

def Phi_fom_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.Phi_fom_double_type()

def Phi_fom_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.Phi_fom_double_data_size()

def Phi_fom_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.Phi_fom_double_data_names()

class F_phi_float(object):
    """


    Reflection data type: F + phi model or map coeff (e.g. Fcalc, Fbest)  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.F_phi_float_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_phi_float_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.F_phi_float_friedel(self)


    def shift_phase(self, dphi: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.F_phi_float_shift_phase(self, dphi)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.F_phi_float_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.F_phi_float_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_phi_float_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.F_phi_float_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.F_phi_float_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.F_phi_float_scale(self, s)


    def f(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_phi_float_f(self, *args)


    def phi(self, *args) -> "float &":
        """


        """
        return _clipper_python_core.F_phi_float_phi(self, *args)


    def a(self) -> "float":
        """


        read real part  

        """
        return _clipper_python_core.F_phi_float_a(self)


    def b(self) -> "float":
        """


        read imag part  

        """
        return _clipper_python_core.F_phi_float_b(self)


    def __init__(self, *args):
        """


        convert from complex  

        """
        this = _clipper_python_core.new_F_phi_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resolve(self, phi: 'float const') -> "float":
        """


        resolve along phase direction  

        """
        return _clipper_python_core.F_phi_float_resolve(self, phi)


    def norm(self) -> "clipper::datatypes::F_phi< float > const &":
        """


        tidy up so that real part is positive and phase 0...twopi  

        """
        return _clipper_python_core.F_phi_float_norm(self)


    def copy(self) -> "clipper::datatypes::F_phi< float >":
        return _clipper_python_core.F_phi_float_copy(self)

    def as_complex(self) -> "std::complex< float >":
        return _clipper_python_core.F_phi_float_as_complex(self)

    def __add__(self, h2: 'F_phi_float') -> "clipper::datatypes::F_phi< float >":
        return _clipper_python_core.F_phi_float___add__(self, h2)

    def __sub__(self, h2: 'F_phi_float') -> "clipper::datatypes::F_phi< float >":
        return _clipper_python_core.F_phi_float___sub__(self, h2)

    def __neg__(self) -> "clipper::datatypes::F_phi< float >":
        return _clipper_python_core.F_phi_float___neg__(self)
    __swig_destroy__ = _clipper_python_core.delete_F_phi_float
    __del__ = lambda self: None
F_phi_float_swigregister = _clipper_python_core.F_phi_float_swigregister
F_phi_float_swigregister(F_phi_float)

def F_phi_float_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_phi_float_type()

def F_phi_float_data_size() -> "int":
    """


    """
    return _clipper_python_core.F_phi_float_data_size()

def F_phi_float_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_phi_float_data_names()

class F_phi_double(object):
    """


    Reflection data type: F + phi model or map coeff (e.g. Fcalc, Fbest)  

    C++ includes: hkl_datatypes.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def set_null(self) -> "void":
        """


        """
        return _clipper_python_core.F_phi_double_set_null(self)


    def type() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_phi_double_type()

    type = staticmethod(type)

    def friedel(self) -> "void":
        """


        """
        return _clipper_python_core.F_phi_double_friedel(self)


    def shift_phase(self, dphi: 'clipper::ftype const &') -> "void":
        """


        """
        return _clipper_python_core.F_phi_double_shift_phase(self, dphi)


    def missing(self) -> "bool":
        """


        """
        return _clipper_python_core.F_phi_double_missing(self)


    def data_size() -> "int":
        """


        """
        return _clipper_python_core.F_phi_double_data_size()

    data_size = staticmethod(data_size)

    def data_names() -> "clipper::String":
        """


        """
        return _clipper_python_core.F_phi_double_data_names()

    data_names = staticmethod(data_names)

    def data_export(self, array: 'clipper::xtype []') -> "void":
        """


        """
        return _clipper_python_core.F_phi_double_data_export(self, array)


    def data_import(self, array: 'clipper::xtype const []') -> "void":
        """


        """
        return _clipper_python_core.F_phi_double_data_import(self, array)


    def scale(self, s: 'clipper::ftype const &') -> "void":
        """


        this type is scalable - apply magnitude scale factor  

        """
        return _clipper_python_core.F_phi_double_scale(self, s)


    def f(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_phi_double_f(self, *args)


    def phi(self, *args) -> "double &":
        """


        """
        return _clipper_python_core.F_phi_double_phi(self, *args)


    def a(self) -> "double":
        """


        read real part  

        """
        return _clipper_python_core.F_phi_double_a(self)


    def b(self) -> "double":
        """


        read imag part  

        """
        return _clipper_python_core.F_phi_double_b(self)


    def __init__(self, *args):
        """


        convert from complex  

        """
        this = _clipper_python_core.new_F_phi_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resolve(self, phi: 'double const') -> "double":
        """


        resolve along phase direction  

        """
        return _clipper_python_core.F_phi_double_resolve(self, phi)


    def norm(self) -> "clipper::datatypes::F_phi< double > const &":
        """


        tidy up so that real part is positive and phase 0...twopi  

        """
        return _clipper_python_core.F_phi_double_norm(self)


    def copy(self) -> "clipper::datatypes::F_phi< double >":
        return _clipper_python_core.F_phi_double_copy(self)

    def as_complex(self) -> "std::complex< double >":
        return _clipper_python_core.F_phi_double_as_complex(self)

    def __add__(self, h2: 'F_phi_double') -> "clipper::datatypes::F_phi< double >":
        return _clipper_python_core.F_phi_double___add__(self, h2)

    def __sub__(self, h2: 'F_phi_double') -> "clipper::datatypes::F_phi< double >":
        return _clipper_python_core.F_phi_double___sub__(self, h2)

    def __neg__(self) -> "clipper::datatypes::F_phi< double >":
        return _clipper_python_core.F_phi_double___neg__(self)
    __swig_destroy__ = _clipper_python_core.delete_F_phi_double
    __del__ = lambda self: None
F_phi_double_swigregister = _clipper_python_core.F_phi_double_swigregister
F_phi_double_swigregister(F_phi_double)

def F_phi_double_type() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_phi_double_type()

def F_phi_double_data_size() -> "int":
    """


    """
    return _clipper_python_core.F_phi_double_data_size()

def F_phi_double_data_names() -> "clipper::String":
    """


    """
    return _clipper_python_core.F_phi_double_data_names()

class HKL_data_Flag(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_Flag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_Flag_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_Flag_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_Flag_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_Flag_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_Flag_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Flag_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Flag_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Flag_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Flag_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_Flag_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_Flag_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_Flag_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_Flag_debug(self)


    def __eq__(self, n: 'int const &') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag___eq__(self, n)

    def __ne__(self, n: 'int const &') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag___ne__(self, n)

    def __ge__(self, n: 'int const &') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag___ge__(self, n)

    def __le__(self, n: 'int const &') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag___le__(self, n)

    def __gt__(self, n: 'int const &') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag___gt__(self, n)

    def __lt__(self, n: 'int const &') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag___lt__(self, n)

    def __getitem__(self, i: 'int') -> "clipper::datatypes::Flag &":
        return _clipper_python_core.HKL_data_Flag___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_Flag___len__(self)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::Flag >":
        return _clipper_python_core.HKL_data_Flag_copy(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_Flag
    __del__ = lambda self: None
HKL_data_Flag_swigregister = _clipper_python_core.HKL_data_Flag_swigregister
HKL_data_Flag_swigregister(HKL_data_Flag)

class HKL_data_Flag_bool(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_Flag_bool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_Flag_bool_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_Flag_bool_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_Flag_bool_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_Flag_bool_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_Flag_bool_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Flag_bool_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Flag_bool_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Flag_bool_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Flag_bool_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_Flag_bool_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_Flag_bool_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_Flag_bool_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_Flag_bool_debug(self)


    def __invert__(self) -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag_bool___invert__(self)

    def __or__(self, d1: 'HKL_data_Flag_bool') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag_bool___or__(self, d1)

    def __xor__(self, d1: 'HKL_data_Flag_bool') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag_bool___xor__(self, d1)

    def __and__(self, d1: 'HKL_data_Flag_bool') -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag_bool___and__(self, d1)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::Flag_bool >":
        return _clipper_python_core.HKL_data_Flag_bool_copy(self)

    def __getitem__(self, i: 'int') -> "clipper::datatypes::Flag_bool &":
        return _clipper_python_core.HKL_data_Flag_bool___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_Flag_bool___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_Flag_bool
    __del__ = lambda self: None
HKL_data_Flag_bool_swigregister = _clipper_python_core.HKL_data_Flag_bool_swigregister
HKL_data_Flag_bool_swigregister(HKL_data_Flag_bool)

class HKL_data_F_phi_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_F_phi_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_F_phi_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_F_phi_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_F_phi_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_F_phi_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_F_phi_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_phi_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_phi_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_phi_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_phi_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_F_phi_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_F_phi_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_F_phi_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_F_phi_float_debug(self)


    def copy(self) -> "clipper::HKL_data< clipper::datatypes::F_phi< float > >":
        return _clipper_python_core.HKL_data_F_phi_float_copy(self)

    def __add__(self, h2: 'HKL_data_F_phi_float') -> "clipper::HKL_data< clipper::datatypes::F_phi< float > >":
        return _clipper_python_core.HKL_data_F_phi_float___add__(self, h2)

    def __sub__(self, h2: 'HKL_data_F_phi_float') -> "clipper::HKL_data< clipper::datatypes::F_phi< float > >":
        return _clipper_python_core.HKL_data_F_phi_float___sub__(self, h2)

    def __neg__(self) -> "clipper::HKL_data< clipper::datatypes::F_phi< float > >":
        return _clipper_python_core.HKL_data_F_phi_float___neg__(self)

    def __mul__(self, s: 'float const &') -> "clipper::HKL_data< clipper::datatypes::F_phi< float > >":
        return _clipper_python_core.HKL_data_F_phi_float___mul__(self, s)

    def __rmul__(self, s: 'float const &') -> "clipper::HKL_data< clipper::datatypes::F_phi< float > >":
        return _clipper_python_core.HKL_data_F_phi_float___rmul__(self, s)

    def compute_neg(self, fphi: 'HKL_data_F_phi_float') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float_compute_neg(self, fphi)

    def compute_add_fphi(self, fphi1: 'HKL_data_F_phi_float', fphi2: 'HKL_data_F_phi_float') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float_compute_add_fphi(self, fphi1, fphi2)

    def compute_sub_fphi(self, fphi1: 'HKL_data_F_phi_float', fphi2: 'HKL_data_F_phi_float') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float_compute_sub_fphi(self, fphi1, fphi2)

    def compute_from_fsigf_phifom(self, fsigf: 'HKL_data_F_sigF_float', phifom: 'HKL_data_Phi_fom_float') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float_compute_from_fsigf_phifom(self, fsigf, phifom)

    def compute_scale_u_iso_fphi(self, scale: 'float const &', u_value: 'float const &', fphi: 'HKL_data_F_phi_float') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float_compute_scale_u_iso_fphi(self, scale, u_value, fphi)

    def compute_scale_u_aniso_fphi(self, scale: 'float const &', u_value: 'U_aniso_orth', fphi: 'HKL_data_F_phi_float') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float_compute_scale_u_aniso_fphi(self, scale, u_value, fphi)

    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_F_phi_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_F_phi_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::F_phi &":
        return _clipper_python_core.HKL_data_F_phi_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_F_phi_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_F_phi_float
    __del__ = lambda self: None
HKL_data_F_phi_float_swigregister = _clipper_python_core.HKL_data_F_phi_float_swigregister
HKL_data_F_phi_float_swigregister(HKL_data_F_phi_float)

class HKL_data_F_phi_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_F_phi_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_F_phi_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_F_phi_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_F_phi_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_F_phi_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_F_phi_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_phi_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_phi_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_phi_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_phi_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_F_phi_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_F_phi_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_F_phi_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_F_phi_double_debug(self)


    def copy(self) -> "clipper::HKL_data< clipper::datatypes::F_phi< double > >":
        return _clipper_python_core.HKL_data_F_phi_double_copy(self)

    def __add__(self, h2: 'HKL_data_F_phi_double') -> "clipper::HKL_data< clipper::datatypes::F_phi< double > >":
        return _clipper_python_core.HKL_data_F_phi_double___add__(self, h2)

    def __sub__(self, h2: 'HKL_data_F_phi_double') -> "clipper::HKL_data< clipper::datatypes::F_phi< double > >":
        return _clipper_python_core.HKL_data_F_phi_double___sub__(self, h2)

    def __neg__(self) -> "clipper::HKL_data< clipper::datatypes::F_phi< double > >":
        return _clipper_python_core.HKL_data_F_phi_double___neg__(self)

    def __mul__(self, s: 'double const &') -> "clipper::HKL_data< clipper::datatypes::F_phi< double > >":
        return _clipper_python_core.HKL_data_F_phi_double___mul__(self, s)

    def __rmul__(self, s: 'double const &') -> "clipper::HKL_data< clipper::datatypes::F_phi< double > >":
        return _clipper_python_core.HKL_data_F_phi_double___rmul__(self, s)

    def compute_neg(self, fphi: 'HKL_data_F_phi_double') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double_compute_neg(self, fphi)

    def compute_add_fphi(self, fphi1: 'HKL_data_F_phi_double', fphi2: 'HKL_data_F_phi_double') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double_compute_add_fphi(self, fphi1, fphi2)

    def compute_sub_fphi(self, fphi1: 'HKL_data_F_phi_double', fphi2: 'HKL_data_F_phi_double') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double_compute_sub_fphi(self, fphi1, fphi2)

    def compute_from_fsigf_phifom(self, fsigf: 'HKL_data_F_sigF_double', phifom: 'HKL_data_Phi_fom_double') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double_compute_from_fsigf_phifom(self, fsigf, phifom)

    def compute_scale_u_iso_fphi(self, scale: 'double const &', u_value: 'double const &', fphi: 'HKL_data_F_phi_double') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double_compute_scale_u_iso_fphi(self, scale, u_value, fphi)

    def compute_scale_u_aniso_fphi(self, scale: 'double const &', u_value: 'U_aniso_orth', fphi: 'HKL_data_F_phi_double') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double_compute_scale_u_aniso_fphi(self, scale, u_value, fphi)

    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_F_phi_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_F_phi_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::F_phi &":
        return _clipper_python_core.HKL_data_F_phi_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_F_phi_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_F_phi_double
    __del__ = lambda self: None
HKL_data_F_phi_double_swigregister = _clipper_python_core.HKL_data_F_phi_double_swigregister
HKL_data_F_phi_double_swigregister(HKL_data_F_phi_double)

class HKL_data_ABCD_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_ABCD_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_ABCD_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_ABCD_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_ABCD_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_ABCD_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_ABCD_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_ABCD_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_ABCD_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_ABCD_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_ABCD_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_ABCD_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_ABCD_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_ABCD_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_ABCD_float_debug(self)


    def __add__(self, h2: 'HKL_data_ABCD_float') -> "clipper::HKL_data< clipper::datatypes::ABCD< float > >":
        return _clipper_python_core.HKL_data_ABCD_float___add__(self, h2)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::ABCD< float > >":
        return _clipper_python_core.HKL_data_ABCD_float_copy(self)

    def compute_from_phi_fom(self, phiw: 'HKL_data_Phi_fom_float') -> "void":
        return _clipper_python_core.HKL_data_ABCD_float_compute_from_phi_fom(self, phiw)

    def compute_add_abcd(self, abcd1: 'HKL_data_ABCD_float', abcd2: 'HKL_data_ABCD_float') -> "void":
        return _clipper_python_core.HKL_data_ABCD_float_compute_add_abcd(self, abcd1, abcd2)

    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_ABCD_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_ABCD_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::ABCD &":
        return _clipper_python_core.HKL_data_ABCD_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_ABCD_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_ABCD_float
    __del__ = lambda self: None
HKL_data_ABCD_float_swigregister = _clipper_python_core.HKL_data_ABCD_float_swigregister
HKL_data_ABCD_float_swigregister(HKL_data_ABCD_float)

class HKL_data_ABCD_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_ABCD_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_ABCD_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_ABCD_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_ABCD_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_ABCD_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_ABCD_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_ABCD_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_ABCD_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_ABCD_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_ABCD_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_ABCD_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_ABCD_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_ABCD_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_ABCD_double_debug(self)


    def __add__(self, h2: 'HKL_data_ABCD_double') -> "clipper::HKL_data< clipper::datatypes::ABCD< double > >":
        return _clipper_python_core.HKL_data_ABCD_double___add__(self, h2)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::ABCD< double > >":
        return _clipper_python_core.HKL_data_ABCD_double_copy(self)

    def compute_from_phi_fom(self, phiw: 'HKL_data_Phi_fom_double') -> "void":
        return _clipper_python_core.HKL_data_ABCD_double_compute_from_phi_fom(self, phiw)

    def compute_add_abcd(self, abcd1: 'HKL_data_ABCD_double', abcd2: 'HKL_data_ABCD_double') -> "void":
        return _clipper_python_core.HKL_data_ABCD_double_compute_add_abcd(self, abcd1, abcd2)

    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_ABCD_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_ABCD_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::ABCD &":
        return _clipper_python_core.HKL_data_ABCD_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_ABCD_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_ABCD_double
    __del__ = lambda self: None
HKL_data_ABCD_double_swigregister = _clipper_python_core.HKL_data_ABCD_double_swigregister
HKL_data_ABCD_double_swigregister(HKL_data_ABCD_double)

class HKL_data_E_sigE_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_E_sigE_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_E_sigE_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_E_sigE_float_debug(self)


    def scaleBySqrtResolution(self, escale: 'ResolutionFn') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_float_scaleBySqrtResolution(self, escale)

    def scaleByResolution(self, escale: 'ResolutionFn') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_float_scaleByResolution(self, escale)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::E_sigE< float > >":
        return _clipper_python_core.HKL_data_E_sigE_float_copy(self)

    def compute_from_fsigf(self, fsigf: 'HKL_data_F_sigF_float') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_float_compute_from_fsigf(self, fsigf)

    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_E_sigE_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::E_sigE &":
        return _clipper_python_core.HKL_data_E_sigE_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_E_sigE_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_E_sigE_float
    __del__ = lambda self: None
HKL_data_E_sigE_float_swigregister = _clipper_python_core.HKL_data_E_sigE_float_swigregister
HKL_data_E_sigE_float_swigregister(HKL_data_E_sigE_float)

class HKL_data_E_sigE_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_E_sigE_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_E_sigE_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_E_sigE_double_debug(self)


    def scaleBySqrtResolution(self, escale: 'ResolutionFn') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_double_scaleBySqrtResolution(self, escale)

    def scaleByResolution(self, escale: 'ResolutionFn') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_double_scaleByResolution(self, escale)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::E_sigE< double > >":
        return _clipper_python_core.HKL_data_E_sigE_double_copy(self)

    def compute_from_fsigf(self, fsigf: 'HKL_data_F_sigF_double') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_double_compute_from_fsigf(self, fsigf)

    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_E_sigE_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_E_sigE_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::E_sigE &":
        return _clipper_python_core.HKL_data_E_sigE_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_E_sigE_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_E_sigE_double
    __del__ = lambda self: None
HKL_data_E_sigE_double_swigregister = _clipper_python_core.HKL_data_E_sigE_double_swigregister
HKL_data_E_sigE_double_swigregister(HKL_data_E_sigE_double)

class HKL_data_Phi_fom_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_Phi_fom_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_Phi_fom_float_debug(self)


    def compute_from_abcd(self, abcd: 'HKL_data_ABCD_float') -> "void":
        return _clipper_python_core.HKL_data_Phi_fom_float_compute_from_abcd(self, abcd)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::Phi_fom< float > >":
        return _clipper_python_core.HKL_data_Phi_fom_float_copy(self)

    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_Phi_fom_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_Phi_fom_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::Phi_fom &":
        return _clipper_python_core.HKL_data_Phi_fom_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_Phi_fom_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_Phi_fom_float
    __del__ = lambda self: None
HKL_data_Phi_fom_float_swigregister = _clipper_python_core.HKL_data_Phi_fom_float_swigregister
HKL_data_Phi_fom_float_swigregister(HKL_data_Phi_fom_float)

class HKL_data_Phi_fom_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_Phi_fom_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_Phi_fom_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_Phi_fom_double_debug(self)


    def compute_from_abcd(self, abcd: 'HKL_data_ABCD_double') -> "void":
        return _clipper_python_core.HKL_data_Phi_fom_double_compute_from_abcd(self, abcd)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::Phi_fom< double > >":
        return _clipper_python_core.HKL_data_Phi_fom_double_copy(self)

    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_Phi_fom_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_Phi_fom_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::Phi_fom &":
        return _clipper_python_core.HKL_data_Phi_fom_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_Phi_fom_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_Phi_fom_double
    __del__ = lambda self: None
HKL_data_Phi_fom_double_swigregister = _clipper_python_core.HKL_data_Phi_fom_double_swigregister
HKL_data_Phi_fom_double_swigregister(HKL_data_Phi_fom_double)

class HKL_data_F_sigF_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_F_sigF_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_F_sigF_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_F_sigF_float_debug(self)


    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_F_sigF_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::F_sigF &":
        return _clipper_python_core.HKL_data_F_sigF_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_F_sigF_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_F_sigF_float
    __del__ = lambda self: None
HKL_data_F_sigF_float_swigregister = _clipper_python_core.HKL_data_F_sigF_float_swigregister
HKL_data_F_sigF_float_swigregister(HKL_data_F_sigF_float)

class HKL_data_F_sigF_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_F_sigF_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_F_sigF_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_F_sigF_double_debug(self)


    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_F_sigF_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::F_sigF &":
        return _clipper_python_core.HKL_data_F_sigF_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_F_sigF_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_F_sigF_double
    __del__ = lambda self: None
HKL_data_F_sigF_double_swigregister = _clipper_python_core.HKL_data_F_sigF_double_swigregister
HKL_data_F_sigF_double_swigregister(HKL_data_F_sigF_double)

class HKL_data_F_sigF_ano_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_F_sigF_ano_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_F_sigF_ano_float_debug(self)


    def compute_scale_u_iso_fsigfano(self, scale: 'float const &', u_value: 'float const &', fsigfano: 'HKL_data_F_sigF_ano_float') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_ano_float_compute_scale_u_iso_fsigfano(self, scale, u_value, fsigfano)

    def compute_scale_u_aniso_fsigfano(self, scale: 'float const &', u_value: 'U_aniso_orth', fsigfano: 'HKL_data_F_sigF_ano_float') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_ano_float_compute_scale_u_aniso_fsigfano(self, scale, u_value, fsigfano)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::F_sigF_ano< float > >":
        return _clipper_python_core.HKL_data_F_sigF_ano_float_copy(self)

    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_ano_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_F_sigF_ano_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::F_sigF_ano &":
        return _clipper_python_core.HKL_data_F_sigF_ano_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_F_sigF_ano_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_F_sigF_ano_float
    __del__ = lambda self: None
HKL_data_F_sigF_ano_float_swigregister = _clipper_python_core.HKL_data_F_sigF_ano_float_swigregister
HKL_data_F_sigF_ano_float_swigregister(HKL_data_F_sigF_ano_float)

class HKL_data_F_sigF_ano_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_F_sigF_ano_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_F_sigF_ano_double_debug(self)


    def compute_scale_u_iso_fsigfano(self, scale: 'double const &', u_value: 'double const &', fsigfano: 'HKL_data_F_sigF_ano_double') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_ano_double_compute_scale_u_iso_fsigfano(self, scale, u_value, fsigfano)

    def compute_scale_u_aniso_fsigfano(self, scale: 'double const &', u_value: 'U_aniso_orth', fsigfano: 'HKL_data_F_sigF_ano_double') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_ano_double_compute_scale_u_aniso_fsigfano(self, scale, u_value, fsigfano)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::F_sigF_ano< double > >":
        return _clipper_python_core.HKL_data_F_sigF_ano_double_copy(self)

    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_F_sigF_ano_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_F_sigF_ano_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::F_sigF_ano &":
        return _clipper_python_core.HKL_data_F_sigF_ano_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_F_sigF_ano_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_F_sigF_ano_double
    __del__ = lambda self: None
HKL_data_F_sigF_ano_double_swigregister = _clipper_python_core.HKL_data_F_sigF_ano_double_swigregister
HKL_data_F_sigF_ano_double_swigregister(HKL_data_F_sigF_ano_double)

class HKL_data_I_sigI_float(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_I_sigI_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_I_sigI_float_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_I_sigI_float_debug(self)


    def compute_scale_u_iso_isigi(self, scale: 'float const &', u_value: 'float const &', isigi: 'HKL_data_I_sigI_float') -> "void":
        return _clipper_python_core.HKL_data_I_sigI_float_compute_scale_u_iso_isigi(self, scale, u_value, isigi)

    def compute_scale_u_aniso_isigi(self, scale: 'float const &', u_value: 'U_aniso_orth', isigi: 'HKL_data_I_sigI_float') -> "void":
        return _clipper_python_core.HKL_data_I_sigI_float_compute_scale_u_aniso_isigi(self, scale, u_value, isigi)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::I_sigI< float > >":
        return _clipper_python_core.HKL_data_I_sigI_float_copy(self)

    def _getDataNumpy(self, numpy_array: 'float *') -> "void":
        return _clipper_python_core.HKL_data_I_sigI_float__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'float'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _clipper_python_core.HKL_data_I_sigI_float_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data32::I_sigI &":
        return _clipper_python_core.HKL_data_I_sigI_float___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_I_sigI_float___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_I_sigI_float
    __del__ = lambda self: None
HKL_data_I_sigI_float_swigregister = _clipper_python_core.HKL_data_I_sigI_float_swigregister
HKL_data_I_sigI_float_swigregister(HKL_data_I_sigI_float)

class HKL_data_I_sigI_double(HKL_data_base):
    """


    HKL_data<>  

    An actual hkl_data object, containing actual data of type T. This implements the
    generic interface, and in addition provides type-specific access functions.  

    note: The following methods are inherited from HKL_data_base but are documented
        here for convenience: base_hkl_info(), base_cell(), invresolsq(),
        invresolsq_range(), num_obs(), first(), first_data(), next_data().  

    C++ includes: hkl_data.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        [CLIPPER2] constructor: from another HKL_data object  

            Construct the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        this = _clipper_python_core.new_HKL_data_I_sigI_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        [CLIPPER2] initialiser: from another HKL_data object  

            Initialise the object using a given HKL_data object. The
         properties of the object (spacegroup, cell, sampling) are the copied, but the
        actual data is not.  

        Parameters
        ----------
        * `hkl_data` :  
            The HKL_data object to provide the data.  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_init(self, *args)


    def update(self) -> "void":
        """


        update: synchornize info with parent HKL_info  

        The datalist is resized if necessary to match the parent.  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_update(self)


    def type(self) -> "clipper::String":
        """


        get data type (a list of names corresponding to the im/export values)  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_type(self)


    def missing(self, index: 'int const &') -> "bool":
        """


        check if a data entry in the list is marked as 'missing'  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_missing(self, index)


    def set_null(self, index: 'int const &') -> "void":
        """


        set data entry in the list to its null value  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_set_null(self, index)


    def data_size(self) -> "int":
        """


        return number of data elements in this type  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_data_size(self)


    def data_names(self) -> "clipper::String":
        """


        return names of data elements in this type  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_data_names(self)


    def data_export(self, hkl: 'HKL', array: 'clipper::xtype []') -> "void":
        """


        conversion to array (for I/O)  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_data_export(self, hkl, array)


    def data_import(self, hkl: 'HKL', array: 'clipper::xtype const []') -> "void":
        """


        conversion from array (for I/O)  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_data_import(self, hkl, array)


    def mask(self, mask: 'HKL_data_base') -> "void":
        """


        For each data element, if the corresponding element in `mask` is missing, then
        that element in this list is also set to missing.  

        Parameters
        ----------
        * `mask` :  
            The list to provide the mask.  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_mask(self, mask)


    def get_data(self, *args) -> "bool":
        """


        get data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and the supplied datatype is set, otherwise
        the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Returned with the value of the data.  

        Returns
        -------
        true if the data was returned.  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_get_data(self, *args)


    def set_data(self, *args) -> "bool":
        """


        set data by hkl (returns false if no equivalent hkl)  

        If a symmetry mate of the requested HKL exists in the list, then the correct
        symmetry transformations are applied and data is set to the supplied values,
        otherwise the function returns false.  

        Parameters
        ----------
        * `hkl` :  
            The reflection HKL.  
        * `data` :  
            Value of the data to set.  

        Returns
        -------
        true if the data was set.  

        """
        return _clipper_python_core.HKL_data_I_sigI_double_set_data(self, *args)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.HKL_data_I_sigI_double_debug(self)


    def compute_scale_u_iso_isigi(self, scale: 'double const &', u_value: 'double const &', isigi: 'HKL_data_I_sigI_double') -> "void":
        return _clipper_python_core.HKL_data_I_sigI_double_compute_scale_u_iso_isigi(self, scale, u_value, isigi)

    def compute_scale_u_aniso_isigi(self, scale: 'double const &', u_value: 'U_aniso_orth', isigi: 'HKL_data_I_sigI_double') -> "void":
        return _clipper_python_core.HKL_data_I_sigI_double_compute_scale_u_aniso_isigi(self, scale, u_value, isigi)

    def copy(self) -> "clipper::HKL_data< clipper::datatypes::I_sigI< double > >":
        return _clipper_python_core.HKL_data_I_sigI_double_copy(self)

    def _getDataNumpy(self, numpy_array: 'double *') -> "void":
        return _clipper_python_core.HKL_data_I_sigI_double__getDataNumpy(self, numpy_array)

    def as_numpy(self, target = None):
      if target is None:
        import numpy
        dtype = 'double'
        if dtype == 'float':
          arr_type = numpy.float32
        else:
          arr_type = numpy.double
        target = numpy.empty((len(self), self.data_size()), arr_type)
      self._getDataNumpy(target)
      return target


    def getData(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _clipper_python_core.HKL_data_I_sigI_double_getData(self)

    def __getitem__(self, i: 'int') -> "clipper::data64::I_sigI &":
        return _clipper_python_core.HKL_data_I_sigI_double___getitem__(self, i)

    def __len__(self) -> "size_t":
        return _clipper_python_core.HKL_data_I_sigI_double___len__(self)
    __swig_destroy__ = _clipper_python_core.delete_HKL_data_I_sigI_double
    __del__ = lambda self: None
HKL_data_I_sigI_double_swigregister = _clipper_python_core.HKL_data_I_sigI_double_swigregister
HKL_data_I_sigI_double_swigregister(HKL_data_I_sigI_double)

class Prob_phi_2d(object):
    """


    2-d angular probability distibution class  

    Base for Ramachandran class (and other similar classes, such as a pseudo-
    ramachandran plot or the JPD of two phases ).  

    C++ includes: ramachandran.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init(self, size: 'int const &') -> "void":
        """


        initialise: with sampling  

        """
        return _clipper_python_core.Prob_phi_2d_init(self, size)


    def accumulate(self, *args) -> "void":
        """


        accumulate new sample to probability  

        linear interpolation onto grid  

        """
        return _clipper_python_core.Prob_phi_2d_accumulate(self, *args)


    def normalise(self) -> "void":
        """


        normalise to integrate to 1/(2pi)^2  

        normalise mean value to 1/(2pi)^2  

        """
        return _clipper_python_core.Prob_phi_2d_normalise(self)


    def probability(self, phi1: 'clipper::ftype const &', phi2: 'clipper::ftype const &') -> "clipper::ftype":
        """


        get probability for a particular pair of angles  

        linear interpolation off of grid  

        """
        return _clipper_python_core.Prob_phi_2d_probability(self, phi1, phi2)


    def format(self) -> "clipper::String":
        """


        formatted string representation (as C++ code)  

        """
        return _clipper_python_core.Prob_phi_2d_format(self)


    def data(self, *args) -> "clipper::ftype &":
        """


        2d write access  

        """
        return _clipper_python_core.Prob_phi_2d_data(self, *args)


    def __init__(self):
        this = _clipper_python_core.new_Prob_phi_2d()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Prob_phi_2d
    __del__ = lambda self: None
Prob_phi_2d_swigregister = _clipper_python_core.Prob_phi_2d_swigregister
Prob_phi_2d_swigregister(Prob_phi_2d)

class Ramachandran(object):
    """


    Ramachandran plot class.  

    This class provides a reference Ramachandran plot for Gly, Pro, other, and
    combinations of those types of residues. The source data comes from the best
    residues from the 'top500' best-determined structures list of D. C. and J. S.
    Richardson, http://kinemage.biochem.duke.edu/index.html  

    The Ramachandran plot is normalised in inverse radians squared, so the mean
    value of a probability is 1/(2 pi)2.  

    C++ includes: ramachandran.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Gly = _clipper_python_core.Ramachandran_Gly
    Pro = _clipper_python_core.Ramachandran_Pro
    NonGlyPro = _clipper_python_core.Ramachandran_NonGlyPro
    NonGly = _clipper_python_core.Ramachandran_NonGly
    All = _clipper_python_core.Ramachandran_All
    Gly5 = _clipper_python_core.Ramachandran_Gly5
    Pro5 = _clipper_python_core.Ramachandran_Pro5
    NonGlyPro5 = _clipper_python_core.Ramachandran_NonGlyPro5
    NonGly5 = _clipper_python_core.Ramachandran_NonGly5
    All5 = _clipper_python_core.Ramachandran_All5

    def __init__(self, *args):
        """


        constructor: from standard plot  

        Construct a Ramachandran plot of a given type.  

        Parameters
        ----------
        * `type` :  
            The residue type of the plot. Options include: Ramachandran::Gly,
            Ramachandran::Pro, Ramachandran::NonGlyPro, Ramachandran::NonGly,
            Ramachandran::All  

        """
        this = _clipper_python_core.new_Ramachandran(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, type: 'clipper::Ramachandran::TYPE') -> "void":
        """


        initialise: from standard plot  

        Construct a Ramachandran plot of a given type.  

        Parameters
        ----------
        * `type` :  
            The residue type of the plot. Options include: Ramachandran::Gly,
            Ramachandran::Pro, Ramachandran::NonGlyPro, Ramachandran::NonGly,
            Ramachandran::All  

        """
        return _clipper_python_core.Ramachandran_init(self, type)


    def set_thresholds(self, prob_favored: 'clipper::ftype'=0.01, prob_allowed: 'clipper::ftype'=0.0005) -> "void":
        """


        change threshholds to different values  

        Set thresholds for favorable and allowed regions of the Ramachandran plot. The
        US spelling is used because it is the same length as 'allowed'. I should get out
        more. Sorry.  

        Parameters
        ----------
        * `prob_favored` :  
            The probability threshold for the favored region.  
        * `prob_allowed` :  
            The probability threshold for the allowed region.  

        """
        return _clipper_python_core.Ramachandran_set_thresholds(self, prob_favored, prob_allowed)


    def probability(self, phi: 'clipper::ftype const &', psi: 'clipper::ftype const &') -> "clipper::ftype":
        """


        get probability for a particular pair of angles  

        """
        return _clipper_python_core.Ramachandran_probability(self, phi, psi)


    def favored(self, phi: 'clipper::ftype const &', psi: 'clipper::ftype const &') -> "bool":
        """


        test if a pair of angles are in the favored region  

        """
        return _clipper_python_core.Ramachandran_favored(self, phi, psi)


    def allowed(self, phi: 'clipper::ftype const &', psi: 'clipper::ftype const &') -> "bool":
        """


        test if a pair of angles are in the allowed region  

        """
        return _clipper_python_core.Ramachandran_allowed(self, phi, psi)

    __swig_destroy__ = _clipper_python_core.delete_Ramachandran
    __del__ = lambda self: None
Ramachandran_swigregister = _clipper_python_core.Ramachandran_swigregister
Ramachandran_swigregister(Ramachandran)

class CIFfile(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_CIFfile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_CIFfile
    __del__ = lambda self: None

    def open_read(self, filename_in: 'String') -> "void":
        return _clipper_python_core.CIFfile_open_read(self, filename_in)

    def close_read(self) -> "void":
        return _clipper_python_core.CIFfile_close_read(self)

    def spacegroup(self) -> "clipper::Spacegroup const &":
        return _clipper_python_core.CIFfile_spacegroup(self)

    def cell(self) -> "clipper::Cell const &":
        return _clipper_python_core.CIFfile_cell(self)

    def hkl_sampling(self) -> "clipper::HKL_sampling const &":
        return _clipper_python_core.CIFfile_hkl_sampling(self)

    def resolution(self, *args) -> "clipper::Resolution":
        return _clipper_python_core.CIFfile_resolution(self, *args)

    def import_hkl_info(self, target: 'HKL_info') -> "void":
        return _clipper_python_core.CIFfile_import_hkl_info(self, target)

    def import_hkl_data(self, cdata: 'HKL_data_base') -> "void":
        return _clipper_python_core.CIFfile_import_hkl_data(self, cdata)

    def contains_phases_p(self) -> "bool":
        return _clipper_python_core.CIFfile_contains_phases_p(self)

    open_read = log_clipper(open_read)

CIFfile_swigregister = _clipper_python_core.CIFfile_swigregister
CIFfile_swigregister(CIFfile)

class SFcalc_obs_bulk_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_SFcalc_obs_bulk_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, fphi: 'HKL_data_F_phi_float', fsig: 'HKL_data_F_sigF_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_obs_bulk_float___call__(self, fphi, fsig, atoms)

    def bulk_frac(self) -> "clipper::ftype const &":
        return _clipper_python_core.SFcalc_obs_bulk_float_bulk_frac(self)

    def bulk_scale(self) -> "clipper::ftype const &":
        return _clipper_python_core.SFcalc_obs_bulk_float_bulk_scale(self)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_obs_bulk_float
    __del__ = lambda self: None
SFcalc_obs_bulk_float_swigregister = _clipper_python_core.SFcalc_obs_bulk_float_swigregister
SFcalc_obs_bulk_float_swigregister(SFcalc_obs_bulk_float)

class SFweight_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NONE = _clipper_python_core.SFweight_base_float_NONE
    SIGMAA = _clipper_python_core.SFweight_base_float_SIGMAA
    SCALE = _clipper_python_core.SFweight_base_float_SCALE
    BOTH = _clipper_python_core.SFweight_base_float_BOTH

    def __call__(self, fb: 'HKL_data_F_phi_float', fd: 'HKL_data_F_phi_float', phiw: 'HKL_data_Phi_fom_float', fo: 'HKL_data_F_sigF_float', fc: 'HKL_data_F_phi_float', usage: 'HKL_data_Flag') -> "bool":
        return _clipper_python_core.SFweight_base_float___call__(self, fb, fd, phiw, fo, fc, usage)
    __swig_destroy__ = _clipper_python_core.delete_SFweight_base_float
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == SFweight_base_float:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_SFweight_base_float(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_SFweight_base_float(self)
        return weakref_proxy(self)
SFweight_base_float_swigregister = _clipper_python_core.SFweight_base_float_swigregister
SFweight_base_float_swigregister(SFweight_base_float)

class SFcalc_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, fphidata: 'HKL_data_F_phi_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_base_float___call__(self, fphidata, atoms)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_base_float
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == SFcalc_base_float:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_SFcalc_base_float(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_SFcalc_base_float(self)
        return weakref_proxy(self)
SFcalc_base_float_swigregister = _clipper_python_core.SFcalc_base_float_swigregister
SFcalc_base_float_swigregister(SFcalc_base_float)

class EDcalc_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_base_float___call__(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_EDcalc_base_float
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == EDcalc_base_float:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_EDcalc_base_float(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_EDcalc_base_float(self)
        return weakref_proxy(self)
EDcalc_base_float_swigregister = _clipper_python_core.EDcalc_base_float_swigregister
EDcalc_base_float_swigregister(EDcalc_base_float)

class SFcalc_obs_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, fphi: 'HKL_data_F_phi_float', fsig: 'HKL_data_F_sigF_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_obs_base_float___call__(self, fphi, fsig, atoms)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_obs_base_float
    __del__ = lambda self: None
SFcalc_obs_base_float_swigregister = _clipper_python_core.SFcalc_obs_base_float_swigregister
SFcalc_obs_base_float_swigregister(SFcalc_obs_base_float)

class SFscale_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.SFscale_base_float___call__(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_SFscale_base_float
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == SFscale_base_float:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_SFscale_base_float(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_SFscale_base_float(self)
        return weakref_proxy(self)
SFscale_base_float_swigregister = _clipper_python_core.SFscale_base_float_swigregister
SFscale_base_float_swigregister(SFscale_base_float)

class MapFilter_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, result: 'Xmap_float', xmap: 'Xmap_float') -> "bool":
        return _clipper_python_core.MapFilter_base_float___call__(self, result, xmap)
    __swig_destroy__ = _clipper_python_core.delete_MapFilter_base_float
    __del__ = lambda self: None
MapFilter_base_float_swigregister = _clipper_python_core.MapFilter_base_float_swigregister
MapFilter_base_float_swigregister(MapFilter_base_float)

class Convolution_search_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, result: 'Xmap_float', srchval: 'NXmap_float', nxop: 'NX_operator const &') -> "bool":
        return _clipper_python_core.Convolution_search_base_float___call__(self, result, srchval, nxop)
    __swig_destroy__ = _clipper_python_core.delete_Convolution_search_base_float
    __del__ = lambda self: None
Convolution_search_base_float_swigregister = _clipper_python_core.Convolution_search_base_float_swigregister
Convolution_search_base_float_swigregister(Convolution_search_base_float)

class FFFear_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, result: 'Xmap_float', srchval: 'NXmap_float', srchwgt: 'NXmap_float', nxop: 'NX_operator const &') -> "bool":
        return _clipper_python_core.FFFear_base_float___call__(self, result, srchval, srchwgt, nxop)
    __swig_destroy__ = _clipper_python_core.delete_FFFear_base_float
    __del__ = lambda self: None
FFFear_base_float_swigregister = _clipper_python_core.FFFear_base_float_swigregister
FFFear_base_float_swigregister(FFFear_base_float)

class Skeleton_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, xskl: 'Xmap_float', xmap: 'Xmap_float') -> "bool":
        return _clipper_python_core.Skeleton_base_float___call__(self, xskl, xmap)
    __swig_destroy__ = _clipper_python_core.delete_Skeleton_base_float
    __del__ = lambda self: None
Skeleton_base_float_swigregister = _clipper_python_core.Skeleton_base_float_swigregister
Skeleton_base_float_swigregister(Skeleton_base_float)

class OriginMatch_base_float(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, invert: 'bool &', shift: 'Coord_frac', fphi1: 'HKL_data_F_phi_float', fphi2: 'HKL_data_F_phi_float') -> "bool":
        return _clipper_python_core.OriginMatch_base_float___call__(self, invert, shift, fphi1, fphi2)
    __swig_destroy__ = _clipper_python_core.delete_OriginMatch_base_float
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == OriginMatch_base_float:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_OriginMatch_base_float(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_OriginMatch_base_float(self)
        return weakref_proxy(self)
OriginMatch_base_float_swigregister = _clipper_python_core.OriginMatch_base_float_swigregister
OriginMatch_base_float_swigregister(OriginMatch_base_float)

class SFscale_aniso_float(SFscale_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SFscale_aniso_F_float = _clipper_python_core.SFscale_aniso_float_SFscale_aniso_F_float
    SFscale_aniso_I_float = _clipper_python_core.SFscale_aniso_float_SFscale_aniso_I_float
    SFscale_aniso_NORMAL_float = _clipper_python_core.SFscale_aniso_float_SFscale_aniso_NORMAL_float
    SFscale_aniso_SHARPEN_float = _clipper_python_core.SFscale_aniso_float_SFscale_aniso_SHARPEN_float
    SFscale_aniso_UNSHARPEN_float = _clipper_python_core.SFscale_aniso_float_SFscale_aniso_UNSHARPEN_float

    def __init__(self, *args):
        this = _clipper_python_core.new_SFscale_aniso_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.SFscale_aniso_float___call__(self, *args)

    def u_aniso_orth(self, *args) -> "clipper::U_aniso_orth const &":
        return _clipper_python_core.SFscale_aniso_float_u_aniso_orth(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_SFscale_aniso_float
    __del__ = lambda self: None
SFscale_aniso_float_swigregister = _clipper_python_core.SFscale_aniso_float_swigregister
SFscale_aniso_float_swigregister(SFscale_aniso_float)

class SFweight_spline_float(SFweight_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_SFweight_spline_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, n_reflns: 'int const'=1000, n_params: 'int const'=20, n_phases: 'int const'=24) -> "void":
        return _clipper_python_core.SFweight_spline_float_init(self, n_reflns, n_params, n_phases)

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.SFweight_spline_float___call__(self, *args)

    def params_scale(self) -> "std::vector< clipper::ftype,std::allocator< clipper::ftype > > const &":
        return _clipper_python_core.SFweight_spline_float_params_scale(self)

    def params_error(self) -> "std::vector< clipper::ftype,std::allocator< clipper::ftype > > const &":
        return _clipper_python_core.SFweight_spline_float_params_error(self)

    def log_likelihood_work(self) -> "double const &":
        return _clipper_python_core.SFweight_spline_float_log_likelihood_work(self)

    def log_likelihood_free(self) -> "double const &":
        return _clipper_python_core.SFweight_spline_float_log_likelihood_free(self)

    def debug(self) -> "void":
        return _clipper_python_core.SFweight_spline_float_debug(self)

    def targetfn(self, cls: 'HKL_class', fo0: 'F_sigF_float', fc0: 'F_phi_float', s: 'clipper::ftype const &', w: 'clipper::ftype const &') -> "clipper::SFweight_spline< float >::TargetResult":
        return _clipper_python_core.SFweight_spline_float_targetfn(self, cls, fo0, fc0, s, w)

    def targethl(self, cls: 'HKL_class', fo0: 'F_sigF_float', hl0: 'ABCD_float', fc0: 'F_phi_float', s: 'clipper::ftype const &', w: 'clipper::ftype const &') -> "clipper::SFweight_spline< float >::TargetResult":
        return _clipper_python_core.SFweight_spline_float_targethl(self, cls, fo0, hl0, fc0, s, w)
    __swig_destroy__ = _clipper_python_core.delete_SFweight_spline_float
    __del__ = lambda self: None
SFweight_spline_float_swigregister = _clipper_python_core.SFweight_spline_float_swigregister
SFweight_spline_float_swigregister(SFweight_spline_float)

class SFcalc_iso_sum_float(SFcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_SFcalc_iso_sum_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, fphidata: 'HKL_data_F_phi_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_iso_sum_float___call__(self, fphidata, atoms)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_iso_sum_float
    __del__ = lambda self: None
SFcalc_iso_sum_float_swigregister = _clipper_python_core.SFcalc_iso_sum_float_swigregister
SFcalc_iso_sum_float_swigregister(SFcalc_iso_sum_float)

class SFcalc_aniso_sum_float(SFcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_SFcalc_aniso_sum_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, fphidata: 'HKL_data_F_phi_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_aniso_sum_float___call__(self, fphidata, atoms)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_aniso_sum_float
    __del__ = lambda self: None
SFcalc_aniso_sum_float_swigregister = _clipper_python_core.SFcalc_aniso_sum_float_swigregister
SFcalc_aniso_sum_float_swigregister(SFcalc_aniso_sum_float)

class SFcalc_iso_fft_float(SFcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_SFcalc_iso_fft_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, fphidata: 'HKL_data_F_phi_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_iso_fft_float___call__(self, fphidata, atoms)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_iso_fft_float
    __del__ = lambda self: None
SFcalc_iso_fft_float_swigregister = _clipper_python_core.SFcalc_iso_fft_float_swigregister
SFcalc_iso_fft_float_swigregister(SFcalc_iso_fft_float)

class SFcalc_aniso_fft_float(SFcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_SFcalc_aniso_fft_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, fphidata: 'HKL_data_F_phi_float', atoms: 'Atom_list') -> "bool":
        return _clipper_python_core.SFcalc_aniso_fft_float___call__(self, fphidata, atoms)
    __swig_destroy__ = _clipper_python_core.delete_SFcalc_aniso_fft_float
    __del__ = lambda self: None
SFcalc_aniso_fft_float_swigregister = _clipper_python_core.SFcalc_aniso_fft_float_swigregister
SFcalc_aniso_fft_float_swigregister(SFcalc_aniso_fft_float)


def CopyOverHKLInfo(*args) -> "void":
    return _clipper_python_core.CopyOverHKLInfo(*args)
CopyOverHKLInfo = _clipper_python_core.CopyOverHKLInfo

def CopyIfF_sigFRefNotMissingF_sigF_float(d_in: 'HKL_data_F_sigF_float', d_out: 'HKL_data_F_sigF_float', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingF_sigF_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingF_sigF_float = _clipper_python_core.CopyIfF_sigFRefNotMissingF_sigF_float

def CopyIfF_sigFRefNotMissingF_sigF_ano_float(d_in: 'HKL_data_F_sigF_ano_float', d_out: 'HKL_data_F_sigF_ano_float', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingF_sigF_ano_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingF_sigF_ano_float = _clipper_python_core.CopyIfF_sigFRefNotMissingF_sigF_ano_float

def CopyIfF_sigFRefNotMissingE_sigE_float(d_in: 'HKL_data_E_sigE_float', d_out: 'HKL_data_E_sigE_float', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingE_sigE_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingE_sigE_float = _clipper_python_core.CopyIfF_sigFRefNotMissingE_sigE_float

def CopyIfF_sigFRefNotMissingABCD_float(d_in: 'HKL_data_ABCD_float', d_out: 'HKL_data_ABCD_float', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingABCD_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingABCD_float = _clipper_python_core.CopyIfF_sigFRefNotMissingABCD_float

def CopyIfF_sigFRefNotMissingPhi_fom_float(d_in: 'HKL_data_Phi_fom_float', d_out: 'HKL_data_Phi_fom_float', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingPhi_fom_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingPhi_fom_float = _clipper_python_core.CopyIfF_sigFRefNotMissingPhi_fom_float

def CopyIfF_sigFRefNotMissingF_phi_float(d_in: 'HKL_data_F_phi_float', d_out: 'HKL_data_F_phi_float', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingF_phi_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingF_phi_float = _clipper_python_core.CopyIfF_sigFRefNotMissingF_phi_float

def CopyIfF_sigFRefNotMissingFlag_float(d_in: 'HKL_data_Flag', d_out: 'HKL_data_Flag', d_ref: 'HKL_data_F_sigF_float') -> "void":
    return _clipper_python_core.CopyIfF_sigFRefNotMissingFlag_float(d_in, d_out, d_ref)
CopyIfF_sigFRefNotMissingFlag_float = _clipper_python_core.CopyIfF_sigFRefNotMissingFlag_float

def PopulateMatchesF_sigF_float(d_ref: 'HKL_data_F_sigF_float', d: 'HKL_data_F_sigF_float', matched: 'HKLVector') -> "void":
    return _clipper_python_core.PopulateMatchesF_sigF_float(d_ref, d, matched)
PopulateMatchesF_sigF_float = _clipper_python_core.PopulateMatchesF_sigF_float

def PopulateMatchesE_sigE_float(d_ref: 'HKL_data_E_sigE_float', d: 'HKL_data_E_sigE_float', matched: 'HKLVector') -> "void":
    return _clipper_python_core.PopulateMatchesE_sigE_float(d_ref, d, matched)
PopulateMatchesE_sigE_float = _clipper_python_core.PopulateMatchesE_sigE_float

def PopulateMatchesABCD_float(d_ref: 'HKL_data_ABCD_float', d: 'HKL_data_ABCD_float', matched: 'HKLVector') -> "void":
    return _clipper_python_core.PopulateMatchesABCD_float(d_ref, d, matched)
PopulateMatchesABCD_float = _clipper_python_core.PopulateMatchesABCD_float

def PopulateMatchesPhi_fom_float(d_ref: 'HKL_data_Phi_fom_float', d: 'HKL_data_Phi_fom_float', matched: 'HKLVector') -> "void":
    return _clipper_python_core.PopulateMatchesPhi_fom_float(d_ref, d, matched)
PopulateMatchesPhi_fom_float = _clipper_python_core.PopulateMatchesPhi_fom_float

def PopulateMatchesF_phi_float(d_ref: 'HKL_data_F_phi_float', d: 'HKL_data_F_phi_float', matched: 'HKLVector') -> "void":
    return _clipper_python_core.PopulateMatchesF_phi_float(d_ref, d, matched)
PopulateMatchesF_phi_float = _clipper_python_core.PopulateMatchesF_phi_float

def PopulateMatchesFlag_float(d_ref: 'HKL_data_Flag', d: 'HKL_data_Flag', matched: 'HKLVector') -> "void":
    return _clipper_python_core.PopulateMatchesFlag_float(d_ref, d, matched)
PopulateMatchesFlag_float = _clipper_python_core.PopulateMatchesFlag_float

def SetFlagBoth(flag: 'HKL_data_Flag') -> "void":
    return _clipper_python_core.SetFlagBoth(flag)
SetFlagBoth = _clipper_python_core.SetFlagBoth

def SetFlagBothIfMissing(flag: 'HKL_data_Flag', myfsigf: 'HKL_data_F_sigF_float', status: 'HKL_data_Flag', freeflag: 'int') -> "void":
    return _clipper_python_core.SetFlagBothIfMissing(flag, myfsigf, status, freeflag)
SetFlagBothIfMissing = _clipper_python_core.SetFlagBothIfMissing

def SetData(F1: 'HKL_data_F_sigF_float', F2: 'HKL_data_F_sigF_float', CHECK: 'String', OPS: 'String', ELSE_OPS: 'String') -> "void":
    return _clipper_python_core.SetData(F1, F2, CHECK, OPS, ELSE_OPS)
SetData = _clipper_python_core.SetData
class EDcalc_mask_float(EDcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, radius: 'clipper::ftype const'=2.5):
        this = _clipper_python_core.new_EDcalc_mask_float(radius)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_mask_float___call__(self, *args)

    def compute(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_mask_float_compute(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_EDcalc_mask_float
    __del__ = lambda self: None
EDcalc_mask_float_swigregister = _clipper_python_core.EDcalc_mask_float_swigregister
EDcalc_mask_float_swigregister(EDcalc_mask_float)

class EDcalc_iso_float(EDcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, radius: 'clipper::ftype const'=2.5):
        this = _clipper_python_core.new_EDcalc_iso_float(radius)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_iso_float___call__(self, *args)

    def compute(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_iso_float_compute(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_EDcalc_iso_float
    __del__ = lambda self: None
EDcalc_iso_float_swigregister = _clipper_python_core.EDcalc_iso_float_swigregister
EDcalc_iso_float_swigregister(EDcalc_iso_float)

class EDcalc_aniso_float(EDcalc_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, radius: 'clipper::ftype const'=2.5):
        this = _clipper_python_core.new_EDcalc_aniso_float(radius)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_aniso_float___call__(self, *args)

    def compute(self, *args) -> "bool":
        return _clipper_python_core.EDcalc_aniso_float_compute(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_EDcalc_aniso_float
    __del__ = lambda self: None
EDcalc_aniso_float_swigregister = _clipper_python_core.EDcalc_aniso_float_swigregister
EDcalc_aniso_float_swigregister(EDcalc_aniso_float)

class BasisFn_base(object):
    """


    abstract base class for resolution function basis functions  

    A basis function must be able to return its value and derivatives for any given
    HKL.  

    Optionally, performance can be improved by returning a flag to indicate if the
    value of the basis function for a given reflection is linearly dependent on the
    values of the parameter, and a value indicating whether the curvature matrix
    takes an N-diagonal form.  

    **NOTE:** for performance reasons the derivatives are returned as a reference to
    an internal object, so if you store a reference to the result (which is also
    good for performance, it will be overwritten on the next call. If this matters,
    store a copy rather than a reference.  

    C++ includes: resol_fn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    GENERAL = _clipper_python_core.BasisFn_base_GENERAL
    LINEAR = _clipper_python_core.BasisFn_base_LINEAR

    def __init__(self, *args):
        """


        constructor: takes number of parameters  

        """
        if self.__class__ == BasisFn_base:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_BasisFn_base(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def num_params(self) -> "int const &":
        """


        the number of parameters of this basis function  

        """
        return _clipper_python_core.BasisFn_base_num_params(self)


    def f(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function  

        """
        return _clipper_python_core.BasisFn_base_f(self, hkl, cell, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function and its first two derivatives  

        """
        return _clipper_python_core.BasisFn_base_fderiv(self, hkl, cell, params)


    def type(self) -> "clipper::BasisFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        Defaults to GENERAL, which will always work. If the basis function is linearly
        dependent on the parameters, override this with a function returning LINEAR for
        improved performance. See the provided basis functions for examples.  

        Returns
        -------
        The function type enumeration.  

        """
        return _clipper_python_core.BasisFn_base_type(self)


    def num_diagonals(self) -> "int":
        """


        number of non-zero diagonals in the upper triangle of the curvatures  

        Defaults to 0, which will always work. If the basis function has compact support
        among the parameters, i.e. the value for any HKL depends only on a few
        parameters, then set this to the number of non-zero diagonals in the upper
        triangle of the matrix, i.e. 1 for a diagonal matrix, 2 for a tri-diagonal
        matrix etc.  

        Returns
        -------
        The number of non-zero upper diagonals, or zero for full-matrix.  

        """
        return _clipper_python_core.BasisFn_base_num_diagonals(self)

    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_BasisFn_base(self)
        return weakref_proxy(self)
BasisFn_base_swigregister = _clipper_python_core.BasisFn_base_swigregister
BasisFn_base_swigregister(BasisFn_base)

class TargetFn_base(object):
    """


    abstract base class for least-squares resolution function target functions  

    A target function must be able to return its value given the value of the basis
    function for all HKL, and its derivative with respect the values of the basis
    function for all HKL.  

    Optionally, performance can be improved by returning a flag to indicate if the
    target function is quadratic.  

    C++ includes: resol_fn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    GENERAL = _clipper_python_core.TargetFn_base_GENERAL
    QUADRATIC = _clipper_python_core.TargetFn_base_QUADRATIC

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        If the value of f(h) is invalid, rderiv.r should be set to NaN  

        """
        return _clipper_python_core.TargetFn_base_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_base_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_base
    __del__ = lambda self: None

    def __init__(self):
        if self.__class__ == TargetFn_base:
            _self = None
        else:
            _self = self
        this = _clipper_python_core.new_TargetFn_base(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _clipper_python_core.disown_TargetFn_base(self)
        return weakref_proxy(self)
TargetFn_base_swigregister = _clipper_python_core.TargetFn_base_swigregister
TargetFn_base_swigregister(TargetFn_base)

class ResolutionFn(object):
    """


    2nd order resolution function evaluator  

    This is an automatic evaluator for arbitrary functions of HKL, most commonly
    used for evaluating a function of resolution (such a mean F^2 or sigmaa),
    although more general tasks including local scaling of reflections and
    anisotropic functions can also be handled. This form is for target functions
    which approach zero quadratically, e.g. least-squares targets.  

    This version implements a naive Newton-Raphson minimiser, which only uses the
    gradient and curvature of the target function, ignoring its value. It is ideal
    for quadratic targets with linear basis functions.  

    To evaluate a resolution function, this class must be provided with two objects:  

    *   The basis function (and gradients), which describes the value of the
        function for any reflection given a set of paramters.  
    *   The target function (and derivatives), which is used to determine the values
        of the basis function parameters.  

    For example, the following code may be used to calculate a smooth scaling
    function to scale one set of data to another using an anisotropic Gaussian
    scaling function:  

    The most useful isotropic resolution function is the BasisFn_spline, since it is
    linear and provides a good fit to most data.  

    C++ includes: resol_fn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_info: 'HKL_info', basisfn: 'BasisFn_base', targetfn: 'TargetFn_base', params: 'DoubleVector', damp: 'clipper::ftype const'=0.0, debug: 'bool const'=False):
        """


        constructor: need reflections, basis fn and target fn.  

        The constructor performs the full minimisation calculation.  

        Parameters
        ----------
        * `hkl_info` :  
            HKL_info object which provides the reflection list.  
        * `basisfn` :  
            The basis function used to describe the desired property.  
        * `targetfn` :  
            The target function to be minimised.  
        * `params` :  
            Initial values for the function parameters.  
        * `damp_` :  
            If > 0.0, shifts are fdamped during early cycles to help convergence with
            difficult bases/target conbinations.  

        """
        this = _clipper_python_core.new_ResolutionFn(hkl_info, basisfn, targetfn, params, damp, debug)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def f(self, ih: 'clipper::HKL_info::HKL_reference_index const &') -> "clipper::ftype":
        """


        return the value of the basis function with the current paramters  

        """
        return _clipper_python_core.ResolutionFn_f(self, ih)


    def params(self) -> "std::vector< clipper::ftype,std::allocator< clipper::ftype > > const &":
        """


        return the values of the parameters  

        Returns
        -------
        The refined basis function parameters  

        """
        return _clipper_python_core.ResolutionFn_params(self)

    __swig_destroy__ = _clipper_python_core.delete_ResolutionFn
    __del__ = lambda self: None
ResolutionFn_swigregister = _clipper_python_core.ResolutionFn_swigregister
ResolutionFn_swigregister(ResolutionFn)

class ResolutionFn_nonlinear(ResolutionFn):
    """


    2nd order resolution function evaluator  

    This is an automatic evaluator for arbitrary functions of HKL, most commonly
    used for evaluating a function of resolution (such a mean F^2 or sigmaa),
    although more general tasks including local scaling of reflections and
    anisotropic functions can also be handled. This form is for target functions
    which approach zero quadratically, e.g. least-squares targets.  

    note: This version implements a minimiser which uses both Newton-Raphson and
        gradient steps depending on the situation. It can be used for non-quadratic
        targets or non-linear basis functions.  

    To evaluate a resolution function, this class must be provided with two objects:  

    *   The basis function (and gradients), which describes the value of the
        function for any reflection given a set of paramters.  
    *   The target function (and derivatives), which is used to determine the values
        of the basis function parameters.  

    C++ includes: resol_fn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_info: 'HKL_info', basisfn: 'BasisFn_base', targetfn: 'TargetFn_base', params: 'DoubleVector', damp: 'clipper::ftype const'=0.0, debug: 'bool const'=False):
        """


        constructor: need reflections, basis fn and target fn.  

        The constructor performs the full minimisation calculation.  

        Parameters
        ----------
        * `hkl_info` :  
            HKL_info object which provides the reflection list.  
        * `basisfn` :  
            The basis function used to describe the desired property.  
        * `targetfn` :  
            The target function to be minimised.  
        * `damp_` :  
            If > 0.0, shifts are fdamped during early cycles to help convergence with
            difficult bases/target conbinations  

        """
        this = _clipper_python_core.new_ResolutionFn_nonlinear(hkl_info, basisfn, targetfn, params, damp, debug)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_ResolutionFn_nonlinear
    __del__ = lambda self: None
ResolutionFn_nonlinear_swigregister = _clipper_python_core.ResolutionFn_nonlinear_swigregister
ResolutionFn_nonlinear_swigregister(ResolutionFn_nonlinear)

class Resolution_ordinal(Generic_ordinal):
    """


    Resolution ordinal gernerator.  

    This class is a helper class for functions which need to divide reflections up
    by resolution whilst guaranteeing a certain distribution of number of
    reflections per range. It takes a list of reflections, one at a time, and
    calculates a function to get the approximate ordinal number of a reflection in a
    list sorted by resolution.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def init(self, *args) -> "void":
        """


        initialiser: takes an HKL_data + Cell & uses non-missing reflections.  

        """
        return _clipper_python_core.Resolution_ordinal_init(self, *args)


    def __init__(self):
        this = _clipper_python_core.new_Resolution_ordinal()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_Resolution_ordinal
    __del__ = lambda self: None
Resolution_ordinal_swigregister = _clipper_python_core.Resolution_ordinal_swigregister
Resolution_ordinal_swigregister(Resolution_ordinal)

class BasisFn_binner(BasisFn_base):
    """


    simple binning basis function  

    This class bins reflections on the basis of resolution, i.e. it generates a
    resolution function from spherical shells.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: include only non-missing reflections in histogram  

        """
        this = _clipper_python_core.new_BasisFn_binner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def f_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function (override for speed)  

        """
        return _clipper_python_core.BasisFn_binner_f_s(self, s, params)


    def fderiv_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivative of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_binner_fderiv_s(self, s, params)


    def type(self) -> "clipper::BasisFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.BasisFn_binner_type(self)


    def num_diagonals(self) -> "int":
        """


        number of non-zero diagonals in the upper triangle of the curvatures  

        """
        return _clipper_python_core.BasisFn_binner_num_diagonals(self)


    def f(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function (override for speed)  

        """
        return _clipper_python_core.BasisFn_binner_f(self, hkl, cell, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_binner_fderiv(self, hkl, cell, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_binner
    __del__ = lambda self: None
BasisFn_binner_swigregister = _clipper_python_core.BasisFn_binner_swigregister
BasisFn_binner_swigregister(BasisFn_binner)

class BasisFn_linear(BasisFn_base):
    """


    simple linear basis function  

    This class fits a piecewise linear function through reflections on the basis of
    resolution.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: include only non-missing reflections in histogram  

        """
        this = _clipper_python_core.new_BasisFn_linear(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def f_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function (override for speed)  

        """
        return _clipper_python_core.BasisFn_linear_f_s(self, s, params)


    def fderiv_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivative of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_linear_fderiv_s(self, s, params)


    def type(self) -> "clipper::BasisFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.BasisFn_linear_type(self)


    def num_diagonals(self) -> "int":
        """


        number of non-zero diagonals in the upper triangle of the curvatures  

        """
        return _clipper_python_core.BasisFn_linear_num_diagonals(self)


    def f(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function (override for speed)  

        """
        return _clipper_python_core.BasisFn_linear_f(self, hkl, cell, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_linear_fderiv(self, hkl, cell, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_linear
    __del__ = lambda self: None
BasisFn_linear_swigregister = _clipper_python_core.BasisFn_linear_swigregister
BasisFn_linear_swigregister(BasisFn_linear)

class BasisFn_spline(BasisFn_base):
    """


    simple smooth basis function  

    This class fits a Bspline through reflections on the basis of resolution.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: include only non-missing reflections in histogram  

        """
        this = _clipper_python_core.new_BasisFn_spline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def f_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function (override for speed)  

        """
        return _clipper_python_core.BasisFn_spline_f_s(self, s, params)


    def fderiv_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivative of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_spline_fderiv_s(self, s, params)


    def type(self) -> "clipper::BasisFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.BasisFn_spline_type(self)


    def num_diagonals(self) -> "int":
        """


        number of non-zero diagonals in the upper triangle of the curvatures  

        """
        return _clipper_python_core.BasisFn_spline_num_diagonals(self)


    def f(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::ftype":
        """


        the value of the resolution function (override for speed)  

        """
        return _clipper_python_core.BasisFn_spline_f(self, hkl, cell, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_spline_fderiv(self, hkl, cell, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_spline
    __del__ = lambda self: None
BasisFn_spline_swigregister = _clipper_python_core.BasisFn_spline_swigregister
BasisFn_spline_swigregister(BasisFn_spline)

class BasisFn_gaussian(BasisFn_base):
    """


    simple Gaussian basis function  

    This class provides a Gaussian basis function.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        constructor:  

        """
        this = _clipper_python_core.new_BasisFn_gaussian()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fderiv_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_gaussian_fderiv_s(self, s, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function (override for speed)  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_gaussian_fderiv(self, hkl, cell, params)


    def scale(self, params: 'DoubleVector') -> "clipper::ftype":
        """


        return the scale factor corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_gaussian_scale(self, params)


    def u_iso(self, params: 'DoubleVector') -> "clipper::ftype":
        """


        return the isotropic U corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_gaussian_u_iso(self, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_gaussian
    __del__ = lambda self: None
BasisFn_gaussian_swigregister = _clipper_python_core.BasisFn_gaussian_swigregister
BasisFn_gaussian_swigregister(BasisFn_gaussian)

class BasisFn_aniso_gaussian(BasisFn_base):
    """


    simple anisotropic Gaussian basis function  

    This class provides a anisotropic Gaussian basis function.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        constructor:  

        """
        this = _clipper_python_core.new_BasisFn_aniso_gaussian()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fderiv_coord(self, xs: 'Coord_reci_orth', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_aniso_gaussian_fderiv_coord(self, xs, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function (override for speed)  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_aniso_gaussian_fderiv(self, hkl, cell, params)


    def scale(self, params: 'DoubleVector') -> "clipper::ftype":
        """


        return the scale factor corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_aniso_gaussian_scale(self, params)


    def u_aniso_orth(self, params: 'DoubleVector') -> "clipper::U_aniso_orth":
        """


        return the anisotropic U corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_aniso_gaussian_u_aniso_orth(self, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_aniso_gaussian
    __del__ = lambda self: None
BasisFn_aniso_gaussian_swigregister = _clipper_python_core.BasisFn_aniso_gaussian_swigregister
BasisFn_aniso_gaussian_swigregister(BasisFn_aniso_gaussian)

class BasisFn_log_gaussian(BasisFn_base):
    """


    simple log Gaussian basis function  

    This class provides a Log Gaussian basis function. i.e. a quadratic function of
    resolution. Use this in conjunction with a Log-target function to get a fast
    estimate to a Gaussian fit.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        constructor:  

        """
        this = _clipper_python_core.new_BasisFn_log_gaussian()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fderiv_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_log_gaussian_fderiv_s(self, s, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function (override for speed)  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_log_gaussian_fderiv(self, hkl, cell, params)


    def type(self) -> "clipper::BasisFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.BasisFn_log_gaussian_type(self)


    def scale(self, params: 'DoubleVector') -> "clipper::ftype":
        """


        return the scale factor corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_log_gaussian_scale(self, params)


    def u_iso(self, params: 'DoubleVector') -> "clipper::ftype":
        """


        return the isotropic U corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_log_gaussian_u_iso(self, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_log_gaussian
    __del__ = lambda self: None
BasisFn_log_gaussian_swigregister = _clipper_python_core.BasisFn_log_gaussian_swigregister
BasisFn_log_gaussian_swigregister(BasisFn_log_gaussian)

class BasisFn_log_aniso_gaussian(BasisFn_base):
    """


    simple anisotropic Gaussian basis function  

    This class provides a anisotropic Gaussian basis function. i.e. a general
    quadratic function of resolution. Use this in conjunction with a Log-target
    function to get a fast estimate to a Gaussian fit.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        constructor:  

        """
        this = _clipper_python_core.new_BasisFn_log_aniso_gaussian()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fderiv_coord(self, xs: 'Coord_reci_orth', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_log_aniso_gaussian_fderiv_coord(self, xs, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function (override for speed)  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_log_aniso_gaussian_fderiv(self, hkl, cell, params)


    def type(self) -> "clipper::BasisFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.BasisFn_log_aniso_gaussian_type(self)


    def scale(self, params: 'DoubleVector') -> "clipper::ftype":
        """


        return the scale factor corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_log_aniso_gaussian_scale(self, params)


    def u_aniso_orth(self, params: 'DoubleVector') -> "clipper::U_aniso_orth":
        """


        return the anisotropic U corresponding to the Gaussian parameters  

        """
        return _clipper_python_core.BasisFn_log_aniso_gaussian_u_aniso_orth(self, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_log_aniso_gaussian
    __del__ = lambda self: None
BasisFn_log_aniso_gaussian_swigregister = _clipper_python_core.BasisFn_log_aniso_gaussian_swigregister
BasisFn_log_aniso_gaussian_swigregister(BasisFn_log_aniso_gaussian)

class BasisFn_expcubic(BasisFn_base):
    """


    simple Expcubic basis function  

    This class provides a Expcubic basis function.  

    C++ includes: resol_basisfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """


        constructor  

        """
        this = _clipper_python_core.new_BasisFn_expcubic()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fderiv_s(self, s: 'clipper::ftype const &', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_expcubic_fderiv_s(self, s, params)


    def fderiv(self, hkl: 'HKL', cell: 'Cell', params: 'DoubleVector') -> "clipper::BasisFn_base::Fderiv const &":
        """


        the value of the resolution function (override for speed)  

        the derivatives of the resolution function w.r.t. the parameters  

        """
        return _clipper_python_core.BasisFn_expcubic_fderiv(self, hkl, cell, params)

    __swig_destroy__ = _clipper_python_core.delete_BasisFn_expcubic
    __del__ = lambda self: None
BasisFn_expcubic_swigregister = _clipper_python_core.BasisFn_expcubic_swigregister
BasisFn_expcubic_swigregister(BasisFn_expcubic)

class TargetFn_scaleEsq_E_sigE_T(TargetFn_base):
    """


    |E|2 scaling target  

    This class implements the target function for calculating the scale factor to
    normalise to <|E|2> = 1. Note that this is not the same as dividing by <|E|2>,
    except in a few special cases, e.g. a simple resolution bins calculation. The
    resulting targen function is the square of the value by which |E| should be
    multiplied to acheive the correct normalisation.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data_: 'HKL_data_E_sigE_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_scaleEsq_E_sigE_T(hkl_data_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_scaleEsq_E_sigE_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_scaleEsq_E_sigE_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_scaleEsq_E_sigE_T
    __del__ = lambda self: None
TargetFn_scaleEsq_E_sigE_T_swigregister = _clipper_python_core.TargetFn_scaleEsq_E_sigE_T_swigregister
TargetFn_scaleEsq_E_sigE_T_swigregister(TargetFn_scaleEsq_E_sigE_T)

class TargetFn_meanFnth_F_phi_T(TargetFn_base):
    """


    simple mean |F|n target  

    This class implements the target function for calculating mean |F|n as a
    function of position in reciprocal space. It includes the appropriate
    multiplicity correction, and so can be applied to any type with an 'f' member
    with the same dimensions as an |F| or |U| (or an uncorrected |E|).  

    This function should not be used to scale F's to E's. See TargetFn_scaleEsq.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data_: 'HKL_data_F_phi_float', n: 'clipper::ftype const &'):
        """


        constructor: takes the datalist against which to calc target, and power  

        """
        this = _clipper_python_core.new_TargetFn_meanFnth_F_phi_T(hkl_data_, n)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_meanFnth_F_phi_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_meanFnth_F_phi_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_meanFnth_F_phi_T
    __del__ = lambda self: None
TargetFn_meanFnth_F_phi_T_swigregister = _clipper_python_core.TargetFn_meanFnth_F_phi_T_swigregister
TargetFn_meanFnth_F_phi_T_swigregister(TargetFn_meanFnth_F_phi_T)

class TargetFn_scaleF1F2_F_sigF_2_T(TargetFn_base):
    """


    |F|2 scaling target  

    This class implements the target function for calculating the scale factor to
    scale one set of F's to another. The resulting scale is the square of the factor
    that scales the first set of data to match the second.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data1_: 'HKL_data_F_sigF_float', hkl_data2_: 'HKL_data_F_sigF_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_scaleF1F2_F_sigF_2_T(hkl_data1_, hkl_data2_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_scaleF1F2_F_sigF_2_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_scaleF1F2_F_sigF_2_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_scaleF1F2_F_sigF_2_T
    __del__ = lambda self: None
TargetFn_scaleF1F2_F_sigF_2_T_swigregister = _clipper_python_core.TargetFn_scaleF1F2_F_sigF_2_T_swigregister
TargetFn_scaleF1F2_F_sigF_2_T_swigregister(TargetFn_scaleF1F2_F_sigF_2_T)

class TargetFn_scaleLogF1F2_F_sigF_2_T(TargetFn_base):
    """


    log |F|2 scaling target  

    This class implements the target function for calculating the scale factor to
    scale the weighted log of one set of F's to another. The resulting scale is the
    square of the factor that scales the first set of data to match the second. The
    log scaling target is used in conjunction with the log-Gaussian basis functions
    for a fast and robust approximation to iso/aniso Gaussian scaling.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data1_: 'HKL_data_F_sigF_float', hkl_data2_: 'HKL_data_F_sigF_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_scaleLogF1F2_F_sigF_2_T(hkl_data1_, hkl_data2_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_scaleLogF1F2_F_sigF_2_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_scaleLogF1F2_F_sigF_2_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_scaleLogF1F2_F_sigF_2_T
    __del__ = lambda self: None
TargetFn_scaleLogF1F2_F_sigF_2_T_swigregister = _clipper_python_core.TargetFn_scaleLogF1F2_F_sigF_2_T_swigregister
TargetFn_scaleLogF1F2_F_sigF_2_T_swigregister(TargetFn_scaleLogF1F2_F_sigF_2_T)

class TargetFn_scaleI1I2_I_sigI_2_T(TargetFn_base):
    """


    This class implements the target function for calculating the scale factor to
    scale one set of I's to another. The resulting scale is the square of the factor
    that scales the first set of data to match the second.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data1_: 'HKL_data_I_sigI_float', hkl_data2_: 'HKL_data_I_sigI_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_scaleI1I2_I_sigI_2_T(hkl_data1_, hkl_data2_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_scaleI1I2_I_sigI_2_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_scaleI1I2_I_sigI_2_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_scaleI1I2_I_sigI_2_T
    __del__ = lambda self: None
TargetFn_scaleI1I2_I_sigI_2_T_swigregister = _clipper_python_core.TargetFn_scaleI1I2_I_sigI_2_T_swigregister
TargetFn_scaleI1I2_I_sigI_2_T_swigregister(TargetFn_scaleI1I2_I_sigI_2_T)

class TargetFn_scaleLogI1I2_I_sigI_2_T(TargetFn_base):
    """


    log |I| scaling target  

    This class implements the target function for calculating the scale factor to
    scale the weighted log of one set of I's to another. The resulting scale is the
    square of the factor that scales the first set of data to match the second. The
    log scaling target is used in conjunction with the log-Gaussian basis functions
    for a fast and robust approximation to iso/aniso Gaussian scaling.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data1_: 'HKL_data_I_sigI_float', hkl_data2_: 'HKL_data_I_sigI_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_scaleLogI1I2_I_sigI_2_T(hkl_data1_, hkl_data2_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_scaleLogI1I2_I_sigI_2_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_scaleLogI1I2_I_sigI_2_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_scaleLogI1I2_I_sigI_2_T
    __del__ = lambda self: None
TargetFn_scaleLogI1I2_I_sigI_2_T_swigregister = _clipper_python_core.TargetFn_scaleLogI1I2_I_sigI_2_T_swigregister
TargetFn_scaleLogI1I2_I_sigI_2_T_swigregister(TargetFn_scaleLogI1I2_I_sigI_2_T)

class TargetFn_meanEnth_E_sigE_T(TargetFn_base):
    """


    simple mean |E|n target  

    This class implements the target function for calculating mean |E|n as a
    function of position in reciprocal space. It includes the appropriate
    multiplicity correction, and so can be applied to any type with an 'E' member
    with the same dimensions as an |E| (or corrected |F| or |U|).  

    This function should not be used to scale F's to E's. See TargetFn_scaleEsq.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, hkl_data_: 'HKL_data_E_sigE_float', n: 'clipper::ftype const &'):
        """


        constructor: takes the datalist against which to calc target, and power  

        """
        this = _clipper_python_core.new_TargetFn_meanEnth_E_sigE_T(hkl_data_, n)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', fh: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_meanEnth_E_sigE_T_rderiv(self, ih, fh)


    def type(self) -> "clipper::TargetFn_base::FNtype":
        """


        the type of the function: optionally used to improve convergence  

        """
        return _clipper_python_core.TargetFn_meanEnth_E_sigE_T_type(self)

    __swig_destroy__ = _clipper_python_core.delete_TargetFn_meanEnth_E_sigE_T
    __del__ = lambda self: None
TargetFn_meanEnth_E_sigE_T_swigregister = _clipper_python_core.TargetFn_meanEnth_E_sigE_T_swigregister
TargetFn_meanEnth_E_sigE_T_swigregister(TargetFn_meanEnth_E_sigE_T)

class TargetFn_sigmaa_omegaa_E_sigE_T(TargetFn_base):
    """


    Deprecated
    simple sigma_a target function  

    This class implements the target function for calculating sigma_a. Required is a
    datalist containing Eo, Ec.  

    It actually refines omegaa = sigmaa/(1-sigmaa^2). This has better proerties for
    refinement. To get sigmaa use  This is available as a static function:  

    This version simplifies terms in |Eo|^2 and |Ec|^2 which should average out to 1
    if the normalisation scheme is consistent with the sigmaa calc.  

    Convergence is good for calculations using the 'binner' basis function, however
    the smooth basis function have convergence problems. This is still under
    investigation.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, eo: 'HKL_data_E_sigE_float', ec: 'HKL_data_E_sigE_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_sigmaa_omegaa_E_sigE_T(eo, ec)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', omegaa: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_sigmaa_omegaa_E_sigE_T_rderiv(self, ih, omegaa)


    def sigmaa(omegaa: 'clipper::ftype const &') -> "clipper::ftype":
        """


        convert omegaa to sigmaa  

        """
        return _clipper_python_core.TargetFn_sigmaa_omegaa_E_sigE_T_sigmaa(omegaa)

    sigmaa = staticmethod(sigmaa)
    __swig_destroy__ = _clipper_python_core.delete_TargetFn_sigmaa_omegaa_E_sigE_T
    __del__ = lambda self: None
TargetFn_sigmaa_omegaa_E_sigE_T_swigregister = _clipper_python_core.TargetFn_sigmaa_omegaa_E_sigE_T_swigregister
TargetFn_sigmaa_omegaa_E_sigE_T_swigregister(TargetFn_sigmaa_omegaa_E_sigE_T)

def TargetFn_sigmaa_omegaa_E_sigE_T_sigmaa(omegaa: 'clipper::ftype const &') -> "clipper::ftype":
    """


    convert omegaa to sigmaa  

    """
    return _clipper_python_core.TargetFn_sigmaa_omegaa_E_sigE_T_sigmaa(omegaa)

class TargetFn_sigmaa_E_sigE_T(TargetFn_base):
    """


    Deprecated
    simple sigma_a target function  

    par: Warning: Convergence of this basis-function can be
        unreliable under some circumstances. Use clipper::TargetFn_sigmaa_omegaa
        instead, except for development purposes.  

    This class implements the target function for calculating sigma_a. Required is a
    datalist containing Eo, Ec.  

    This version simplifies terms in |Eo|^2 and |Ec|^2 which should average out to 1
    if the normalisation scheme is consistent with the sigmaa calc.  

    C++ includes: resol_targetfn.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, eo: 'HKL_data_E_sigE_float', ec: 'HKL_data_E_sigE_float'):
        """


        constructor: takes the datalist against which to calc target  

        """
        this = _clipper_python_core.new_TargetFn_sigmaa_E_sigE_T(eo, ec)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def rderiv(self, ih: 'clipper::HKL_info::HKL_reference_index const &', sigmaa0: 'clipper::ftype const &') -> "clipper::TargetFn_base::Rderiv":
        """


        return the value and derivatives of the target function  

        """
        return _clipper_python_core.TargetFn_sigmaa_E_sigE_T_rderiv(self, ih, sigmaa0)


    def sigmaa(sigm: 'clipper::ftype const &') -> "clipper::ftype":
        """


        convert function to sigmaa  

        """
        return _clipper_python_core.TargetFn_sigmaa_E_sigE_T_sigmaa(sigm)

    sigmaa = staticmethod(sigmaa)
    __swig_destroy__ = _clipper_python_core.delete_TargetFn_sigmaa_E_sigE_T
    __del__ = lambda self: None
TargetFn_sigmaa_E_sigE_T_swigregister = _clipper_python_core.TargetFn_sigmaa_E_sigE_T_swigregister
TargetFn_sigmaa_E_sigE_T_swigregister(TargetFn_sigmaa_E_sigE_T)

def TargetFn_sigmaa_E_sigE_T_sigmaa(sigm: 'clipper::ftype const &') -> "clipper::ftype":
    """


    convert function to sigmaa  

    """
    return _clipper_python_core.TargetFn_sigmaa_E_sigE_T_sigmaa(sigm)


def TargetFn_scaleEsq_E_sigE(hkl_data_: 'HKL_data_E_sigE_float') -> "clipper::TargetFn_scaleEsq< clipper::data32::E_sigE >":
    return _clipper_python_core.TargetFn_scaleEsq_E_sigE(hkl_data_)
TargetFn_scaleEsq_E_sigE = _clipper_python_core.TargetFn_scaleEsq_E_sigE

def TargetFn_meanFnth_F_phi(hkl_data_: 'HKL_data_F_phi_float', val: 'float') -> "clipper::TargetFn_meanFnth< clipper::data32::F_phi >":
    return _clipper_python_core.TargetFn_meanFnth_F_phi(hkl_data_, val)
TargetFn_meanFnth_F_phi = _clipper_python_core.TargetFn_meanFnth_F_phi

def TargetFn_scaleF1F2_F_sigF_2(F1: 'HKL_data_F_sigF_float', F2: 'HKL_data_F_sigF_float') -> "clipper::TargetFn_scaleF1F2< clipper::data32::F_sigF,clipper::data32::F_sigF >":
    return _clipper_python_core.TargetFn_scaleF1F2_F_sigF_2(F1, F2)
TargetFn_scaleF1F2_F_sigF_2 = _clipper_python_core.TargetFn_scaleF1F2_F_sigF_2

def TargetFn_scaleLogF1F2_F_sigF_2(hkl_data1_: 'HKL_data_F_sigF_float', hkl_data2_: 'HKL_data_F_sigF_float') -> "clipper::TargetFn_scaleLogF1F2< clipper::data32::F_sigF,clipper::data32::F_sigF >":
    return _clipper_python_core.TargetFn_scaleLogF1F2_F_sigF_2(hkl_data1_, hkl_data2_)
TargetFn_scaleLogF1F2_F_sigF_2 = _clipper_python_core.TargetFn_scaleLogF1F2_F_sigF_2

def TargetFn_scaleI1I2_I_sigI_2(hkl_data1_: 'HKL_data_I_sigI_float', hkl_data2_: 'HKL_data_I_sigI_float') -> "clipper::TargetFn_scaleI1I2< clipper::data32::I_sigI,clipper::data32::I_sigI >":
    return _clipper_python_core.TargetFn_scaleI1I2_I_sigI_2(hkl_data1_, hkl_data2_)
TargetFn_scaleI1I2_I_sigI_2 = _clipper_python_core.TargetFn_scaleI1I2_I_sigI_2

def TargetFn_scaleLogI1I2_I_sigI_2(hkl_data1_: 'HKL_data_I_sigI_float', hkl_data2_: 'HKL_data_I_sigI_float') -> "clipper::TargetFn_scaleLogI1I2< clipper::data32::I_sigI,clipper::data32::I_sigI >":
    return _clipper_python_core.TargetFn_scaleLogI1I2_I_sigI_2(hkl_data1_, hkl_data2_)
TargetFn_scaleLogI1I2_I_sigI_2 = _clipper_python_core.TargetFn_scaleLogI1I2_I_sigI_2

def TargetFn_meanEnth_E_sigE(hkl_data_: 'HKL_data_E_sigE_float', n: 'clipper::ftype const &') -> "clipper::TargetFn_meanEnth< clipper::data32::E_sigE >":
    return _clipper_python_core.TargetFn_meanEnth_E_sigE(hkl_data_, n)
TargetFn_meanEnth_E_sigE = _clipper_python_core.TargetFn_meanEnth_E_sigE

def TargetFn_sigmaa_omegaa_E_sigE_2(eo: 'HKL_data_E_sigE_float', ec: 'HKL_data_E_sigE_float') -> "clipper::TargetFn_sigmaa_omegaa< clipper::data32::E_sigE >":
    return _clipper_python_core.TargetFn_sigmaa_omegaa_E_sigE_2(eo, ec)
TargetFn_sigmaa_omegaa_E_sigE_2 = _clipper_python_core.TargetFn_sigmaa_omegaa_E_sigE_2

def TargetFn_sigmaa_E_sigE_2(eo: 'HKL_data_E_sigE_float', ec: 'HKL_data_E_sigE_float') -> "clipper::TargetFn_sigmaa< clipper::data32::E_sigE >":
    return _clipper_python_core.TargetFn_sigmaa_E_sigE_2(eo, ec)
TargetFn_sigmaa_E_sigE_2 = _clipper_python_core.TargetFn_sigmaa_E_sigE_2
class NX_operator(object):
    """


    NX_operator: non-crystal map operator.  

    This class holds a reference to a non-crystal map frame from somewhere within a
    crystallographic map frame. In the general case, an orthogonal rotation-
    translation operator is provided which maps the orthogonal frame of the crystal
    space onto the orthogonal frame of the NXmap space.  

    The object calculates and stores optimised transformations between the
    crystallgoraphic frame (described either in fractional or grid coordinates), and
    the NXmap grid. Fast paths are generated automatically if the grids are related.  

    C++ includes: nxmap_operator.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from cell, grid sampling, NXmap, and operator  

        The operator and inverse operator, together with any possible optimisations, are
        constructed to relate the give crystallographic and non-crystallographic grid
        frames, using the supplied orthogonal operator.  

        Parameters
        ----------
        * `cell` :  
            The cell defining the crystal grid frame.  
        * `grid` :  
            The grid defining the crystal grid frame.  
        * `nxmap` :  
            An NXmap defining the non-crystal grid frame.  
        * `rtop` :  
            The operator relating the orthogonal frame of the NXmap onto the orthogonal
            frame of the Xmap.  

        """
        this = _clipper_python_core.new_NX_operator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        initialiser:: from cell, grid sampling, NXmap, and operator  

        The operator and inverse operator, together with any possible optimisations, are
        constructed to relate the give crystallographic and non-crystallographic grid
        frames, using the supplied orthogonal operator.  

        Parameters
        ----------
        * `cell` :  
            The cell defining the crystal grid frame.  
        * `grid` :  
            The grid defining the crystal grid frame.  
        * `nxmap` :  
            An NXmap defining the non-crystal grid frame.  
        * `rtop` :  
            The operator relating the orthogonal frame of the NXmap onto the orthogonal
            frame of the Xmap.  

        """
        return _clipper_python_core.NX_operator_init(self, *args)


    def coord_map(self, c: 'Coord_frac') -> "clipper::Coord_map":
        """


        convert xtal frac coord to nxmap map coord  

        """
        return _clipper_python_core.NX_operator_coord_map(self, c)


    def coord_frac(self, c: 'Coord_map') -> "clipper::Coord_frac":
        """


        convert nxmap map coord to xtal frac coord  

        """
        return _clipper_python_core.NX_operator_coord_frac(self, c)


    def is_null(self) -> "bool":
        """


        test if object has been initialised  

        """
        return _clipper_python_core.NX_operator_is_null(self)


    def debug(self) -> "void":
        """


        """
        return _clipper_python_core.NX_operator_debug(self)

    __swig_destroy__ = _clipper_python_core.delete_NX_operator
    __del__ = lambda self: None
NX_operator_swigregister = _clipper_python_core.NX_operator_swigregister
NX_operator_swigregister(NX_operator)

class NXmap_operator_float(NX_operator):
    """


    NXmap_operator: non-crystal map operator referencing a particular NXmap.  

    This class holds a reference to a non-crystal map object from somewhere within a
    crystallographic map frame. In the general case, an orthogonal rotation-
    translation operator is provided which maps the orthogonal frame of the crystal
    space onto the orthogonal frame of the NXmap space.  

    The object calculates and stores optimised transformations between the
    crystallgoraphic frame (described either in fractional or grid coordinates), and
    the NXmap grid. Fast paths are generated automatically if the grids are related.  

    note: This object differes from NX_operator in that it keeps a reference to an
        individual NXmap, which may be used to access that object directly.  

    C++ includes: nxmap_operator.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from cell, grid sampling, NXmap, and operator  

        """
        this = _clipper_python_core.new_NXmap_operator_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        initialiser:: from cell, grid sampling, NXmap, and operator  

        """
        return _clipper_python_core.NXmap_operator_float_init(self, *args)


    def nxmap(self) -> "clipper::NXmap< float > const &":
        """


        get the target NXmap of this operator  

        """
        return _clipper_python_core.NXmap_operator_float_nxmap(self)

    __swig_destroy__ = _clipper_python_core.delete_NXmap_operator_float
    __del__ = lambda self: None
NXmap_operator_float_swigregister = _clipper_python_core.NXmap_operator_float_swigregister
NXmap_operator_float_swigregister(NXmap_operator_float)

class Convolution_search_slow_float_T(Convolution_search_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def init(self, xmap: 'Xmap_float') -> "void":
        return _clipper_python_core.Convolution_search_slow_float_T_init(self, xmap)

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.Convolution_search_slow_float_T___call__(self, *args)

    def compute(self, res: 'Xmap_float', srchval: 'NXmap_float', nxop: 'NX_operator') -> "bool":
        return _clipper_python_core.Convolution_search_slow_float_T_compute(self, res, srchval, nxop)
    __swig_destroy__ = _clipper_python_core.delete_Convolution_search_slow_float_T
    __del__ = lambda self: None
Convolution_search_slow_float_T_swigregister = _clipper_python_core.Convolution_search_slow_float_T_swigregister
Convolution_search_slow_float_T_swigregister(Convolution_search_slow_float_T)

class Convolution_search_fft_float_T(Convolution_search_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def init(self, xmap: 'Xmap_float') -> "void":
        return _clipper_python_core.Convolution_search_fft_float_T_init(self, xmap)

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.Convolution_search_fft_float_T___call__(self, *args)

    def compute(self, res: 'Xmap_float', srchval: 'NXmap_float', nxop: 'NX_operator') -> "bool":
        return _clipper_python_core.Convolution_search_fft_float_T_compute(self, res, srchval, nxop)
    __swig_destroy__ = _clipper_python_core.delete_Convolution_search_fft_float_T
    __del__ = lambda self: None
Convolution_search_fft_float_T_swigregister = _clipper_python_core.Convolution_search_fft_float_T_swigregister
Convolution_search_fft_float_T_swigregister(Convolution_search_fft_float_T)


def Convolution_search_slow_float(*args) -> "clipper::Convolution_search_slow< float >":
    return _clipper_python_core.Convolution_search_slow_float(*args)
Convolution_search_slow_float = _clipper_python_core.Convolution_search_slow_float

def Convolution_search_fft_float(*args) -> "clipper::Convolution_search_fft< float >":
    return _clipper_python_core.Convolution_search_fft_float(*args)
Convolution_search_fft_float = _clipper_python_core.Convolution_search_fft_float
class MapFilterFn_base(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _clipper_python_core.delete_MapFilterFn_base
    __del__ = lambda self: None

    def __call__(self, radius: 'clipper::ftype const &') -> "clipper::ftype":
        return _clipper_python_core.MapFilterFn_base___call__(self, radius)
MapFilterFn_base_swigregister = _clipper_python_core.MapFilterFn_base_swigregister
MapFilterFn_base_swigregister(MapFilterFn_base)

class MapFilterFn_step(MapFilterFn_base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MapFilterFn_step(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, radius: 'clipper::ftype const &') -> "clipper::ftype":
        return _clipper_python_core.MapFilterFn_step___call__(self, radius)
    __swig_destroy__ = _clipper_python_core.delete_MapFilterFn_step
    __del__ = lambda self: None
MapFilterFn_step_swigregister = _clipper_python_core.MapFilterFn_step_swigregister
MapFilterFn_step_swigregister(MapFilterFn_step)

class MapFilterFn_linear(MapFilterFn_base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MapFilterFn_linear(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, radius: 'clipper::ftype const &') -> "clipper::ftype":
        return _clipper_python_core.MapFilterFn_linear___call__(self, radius)
    __swig_destroy__ = _clipper_python_core.delete_MapFilterFn_linear
    __del__ = lambda self: None
MapFilterFn_linear_swigregister = _clipper_python_core.MapFilterFn_linear_swigregister
MapFilterFn_linear_swigregister(MapFilterFn_linear)

class MapFilterFn_quadratic(MapFilterFn_base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_MapFilterFn_quadratic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, radius: 'clipper::ftype const &') -> "clipper::ftype":
        return _clipper_python_core.MapFilterFn_quadratic___call__(self, radius)
    __swig_destroy__ = _clipper_python_core.delete_MapFilterFn_quadratic
    __del__ = lambda self: None
MapFilterFn_quadratic_swigregister = _clipper_python_core.MapFilterFn_quadratic_swigregister
MapFilterFn_quadratic_swigregister(MapFilterFn_quadratic)

class MapFilter_slow_float(MapFilter_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NONE = _clipper_python_core.MapFilter_slow_float_NONE
    Absolute = _clipper_python_core.MapFilter_slow_float_Absolute
    Relative = _clipper_python_core.MapFilter_slow_float_Relative

    def __init__(self, *args):
        this = _clipper_python_core.new_MapFilter_slow_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, result: 'Xmap_float', xmap: 'Xmap_float') -> "bool":
        return _clipper_python_core.MapFilter_slow_float___call__(self, result, xmap)
    __swig_destroy__ = _clipper_python_core.delete_MapFilter_slow_float
    __del__ = lambda self: None
MapFilter_slow_float_swigregister = _clipper_python_core.MapFilter_slow_float_swigregister
MapFilter_slow_float_swigregister(MapFilter_slow_float)

class MapFilter_fft_float(MapFilter_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NONE = _clipper_python_core.MapFilter_fft_float_NONE
    Absolute = _clipper_python_core.MapFilter_fft_float_Absolute
    Relative = _clipper_python_core.MapFilter_fft_float_Relative

    def __init__(self, *args):
        this = _clipper_python_core.new_MapFilter_fft_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "bool":
        return _clipper_python_core.MapFilter_fft_float___call__(self, *args)
    __swig_destroy__ = _clipper_python_core.delete_MapFilter_fft_float
    __del__ = lambda self: None
MapFilter_fft_float_swigregister = _clipper_python_core.MapFilter_fft_float_swigregister
MapFilter_fft_float_swigregister(MapFilter_fft_float)

class OriginMatch_float(OriginMatch_base_float):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _clipper_python_core.new_OriginMatch_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, shift: 'Coord_frac', fphi1: 'HKL_data_F_phi_float', fphi2: 'HKL_data_F_phi_float') -> "bool":
        return _clipper_python_core.OriginMatch_float___call__(self, shift, fphi1, fphi2)
    __swig_destroy__ = _clipper_python_core.delete_OriginMatch_float
    __del__ = lambda self: None
OriginMatch_float_swigregister = _clipper_python_core.OriginMatch_float_swigregister
OriginMatch_float_swigregister(OriginMatch_float)

class AtomShapeFn(object):
    """


    Atomic shape function object.  

    The atomic scattering factor object is instantiated for each atom in turn,
    giving the atom parameters: position, element, occupancy and the isotropic or
    anisotropic U-value. (See clipper::Util for conversion from B-factors.). The
    methods of the class may then be called to return the scattering in reciprocal
    space or density in real space using either isotropic or anistropic models as
    required.  

    If the atom only has an isotropic U, the faster isotropic methods will be used
    where available.  

    This implementation uses the coefficients from Waasmaier & Kirfel (1995), Acta
    Cryst. A51, 416-431. The source data can be found at: ftp://wrzx02.rz.uni-
    wuerzburg.de/pub/local/Crystallography/sfac.dat  

    C++ includes: atomsf.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    X = _clipper_python_core.AtomShapeFn_X
    Y = _clipper_python_core.AtomShapeFn_Y
    Z = _clipper_python_core.AtomShapeFn_Z
    Uiso = _clipper_python_core.AtomShapeFn_Uiso
    Occ = _clipper_python_core.AtomShapeFn_Occ
    U11 = _clipper_python_core.AtomShapeFn_U11
    U22 = _clipper_python_core.AtomShapeFn_U22
    U33 = _clipper_python_core.AtomShapeFn_U33
    U12 = _clipper_python_core.AtomShapeFn_U12
    U13 = _clipper_python_core.AtomShapeFn_U13
    U23 = _clipper_python_core.AtomShapeFn_U23

    def __init__(self, *args):
        """


        constructor: from coord, element, anisotropic U, occupancy  

        The atom is initialised as anisotropic.  

        Parameters
        ----------
        * `xyz` :  
            The atom coordinate.  
        * `element` :  
            The atom element.  
        * `u_aniso` :  
            The anisotropic U-value.  
        * `occ` :  
            The occupancy.  

        """
        this = _clipper_python_core.new_AtomShapeFn(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        initialiser: from coord, element, anisotropic U, occupancy  

        The atom is initialised as anisotropic.  

        Parameters
        ----------
        * `xyz` :  
            The atom coordinate.  
        * `element` :  
            The atom element.  
        * `u_aniso` :  
            The anisotropic U-value.  
        * `occ` :  
            The occupancy.  

        """
        return _clipper_python_core.AtomShapeFn_init(self, *args)


    def rho_curv(self, xyz: 'Coord_orth', rho: 'clipper::ftype &', grad: 'DoubleVector', curv: 'clipper::Matrix< clipper::ftype > &') -> "bool":
        """


        return Agarwal density gradient/curvature as a function of coordinate  

        Return the Agarwal gradients of the density with respect to tha atomic
        parameters as a function of position in real space in electrons. The parameter
        list is defined by assignment to agarwal_params().  

        Parameters
        ----------
        * `xyz` :  
            Position in real space.  rho The density in electrons.  
        * `grad` :  
            Vector gradient in electrons (pre-size for best performance).  
        * `curv` :  
            Matrix curvature in electrons (pre-size for best performance).  

        """
        return _clipper_python_core.AtomShapeFn_rho_curv(self, xyz, rho, grad, curv)


    def rho_grad(self, *args) -> "bool":
        """


        Deprecated
        return Agarwal density gradients as a function of coordinate  

        """
        return _clipper_python_core.AtomShapeFn_rho_grad(self, *args)


    def f(self, *args) -> "clipper::ftype":
        """


        return (isotropic) scattering factor as a function of resolution  

        Return the scattering factor as a function of position in reciprocal space in
        electrons.  

        Parameters
        ----------
        * `invresolsq` :  
            Inverse resolution squared in inverse Angstroms squared.  

        Returns
        -------
        The scattering factor in electrons.  

        """
        return _clipper_python_core.AtomShapeFn_f(self, *args)


    def rho(self, *args) -> "clipper::ftype":
        """


        return (isotropic) electron density as a function of radius  

        Return the density as a function of position in real space in electrons.  

        Parameters
        ----------
        * `invresolsq` :  
            Radius squared in Angstroms squared.  
        * `The` :  
            density in electrons.  

        """
        return _clipper_python_core.AtomShapeFn_rho(self, *args)


    def agarwal_params(self) -> "std::vector< clipper::AtomShapeFn::TYPE,std::allocator< clipper::AtomShapeFn::TYPE > > &":
        """


        define parameters for Agarwal gradient/curvature calcs  

        """
        return _clipper_python_core.AtomShapeFn_agarwal_params(self)

    __swig_destroy__ = _clipper_python_core.delete_AtomShapeFn
    __del__ = lambda self: None
AtomShapeFn_swigregister = _clipper_python_core.AtomShapeFn_swigregister
AtomShapeFn_swigregister(AtomShapeFn)

class AtomSF(object):
    """


    Atomic scattering factor object.  

    Deprecated
    This class has been replaced by AtomShapeFn, which is smaller, faster, and more
    capable. This class is now a wrapper for that class.  

    C++ includes: atomsf.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        """
        this = _clipper_python_core.new_AtomSF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args) -> "void":
        """


        """
        return _clipper_python_core.AtomSF_init(self, *args)


    def f_iso(self, s: 'clipper::ftype const &') -> "clipper::ftype":
        """


        """
        return _clipper_python_core.AtomSF_f_iso(self, s)


    def f_aniso(self, rfl: 'Coord_reci_orth') -> "clipper::ftype":
        """


        """
        return _clipper_python_core.AtomSF_f_aniso(self, rfl)


    def rho_iso(self, d2: 'clipper::ftype const &') -> "clipper::ftype":
        """


        """
        return _clipper_python_core.AtomSF_rho_iso(self, d2)


    def rho_aniso(self, uvw: 'Coord_orth') -> "clipper::ftype":
        """


        """
        return _clipper_python_core.AtomSF_rho_aniso(self, uvw)

    __swig_destroy__ = _clipper_python_core.delete_AtomSF
    __del__ = lambda self: None
AtomSF_swigregister = _clipper_python_core.AtomSF_swigregister
AtomSF_swigregister(AtomSF)

class Euler_ccp4(object):
    """


    Euler_ccp4 angle class.  

    C++ includes: rotation.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from specified angles  

        """
        this = _clipper_python_core.new_Euler_ccp4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def alpha(self) -> "clipper::ftype const &":
        """


        return alpha  

        """
        return _clipper_python_core.Euler_ccp4_alpha(self)


    def beta(self) -> "clipper::ftype const &":
        """


        return beta  

        """
        return _clipper_python_core.Euler_ccp4_beta(self)


    def gamma(self) -> "clipper::ftype const &":
        """


        return gamma  

        """
        return _clipper_python_core.Euler_ccp4_gamma(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.Euler_ccp4_format(self)

    __swig_destroy__ = _clipper_python_core.delete_Euler_ccp4
    __del__ = lambda self: None
Euler_ccp4_swigregister = _clipper_python_core.Euler_ccp4_swigregister
Euler_ccp4_swigregister(Euler_ccp4)

class Polar_ccp4(object):
    """


    Polar_ccp4 angle class.  

    C++ includes: rotation.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from specified angles  

        """
        this = _clipper_python_core.new_Polar_ccp4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def psi(self) -> "clipper::ftype const &":
        """


        return omega  

        """
        return _clipper_python_core.Polar_ccp4_psi(self)


    def omega(self) -> "clipper::ftype const &":
        """


        return omega  

        """
        return _clipper_python_core.Polar_ccp4_omega(self)


    def phi(self) -> "clipper::ftype const &":
        """


        return phi  

        """
        return _clipper_python_core.Polar_ccp4_phi(self)


    def kappa(self) -> "clipper::ftype const &":
        """


        return kappa  

        """
        return _clipper_python_core.Polar_ccp4_kappa(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.Polar_ccp4_format(self)

    __swig_destroy__ = _clipper_python_core.delete_Polar_ccp4
    __del__ = lambda self: None
Polar_ccp4_swigregister = _clipper_python_core.Polar_ccp4_swigregister
Polar_ccp4_swigregister(Polar_ccp4)

class Rotation(object):
    """


    Rotation class.  

    This class represents a rotation. The internal representation is as a unit
    quaternion, which is easily combined, inverted, or converted to or from other
    commonly used forms.  

    C++ includes: rotation.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """


        constructor: from components  

        """
        this = _clipper_python_core.new_Rotation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def w(self) -> "clipper::ftype const &":
        """


        return w component  

        """
        return _clipper_python_core.Rotation_w(self)


    def x(self) -> "clipper::ftype const &":
        """


        return x component  

        """
        return _clipper_python_core.Rotation_x(self)


    def y(self) -> "clipper::ftype const &":
        """


        return y component  

        """
        return _clipper_python_core.Rotation_y(self)


    def z(self) -> "clipper::ftype const &":
        """


        return z component  

        """
        return _clipper_python_core.Rotation_z(self)


    def euler_ccp4(self) -> "clipper::Euler_ccp4":
        """


        return Euler_ccp4 angles  

        If beta ~= 0, then alpha is set to zero.  

        Returns
        -------
        The Euler_ccp4 angles.  

        """
        return _clipper_python_core.Rotation_euler_ccp4(self)


    def polar_ccp4(self) -> "clipper::Polar_ccp4":
        """


        return Polar_ccp4 angles  

        If omega ~= 0, then phi is set to zero.  

        Returns
        -------
        The Polar_ccp4 angles.  

        """
        return _clipper_python_core.Rotation_polar_ccp4(self)


    def matrix(self) -> "clipper::Mat33< >":
        """


        return 3x3 matrix  

        The resulting rotation matrix would commonly be used to construct a
        clipper::RTop_orth.  

        Returns
        -------
        The rotation matrix.  

        """
        return _clipper_python_core.Rotation_matrix(self)


    def norm(self) -> "clipper::Rotation const &":
        """


        normalise this quaternion  

        The normalisation is performed in-place. If a rotation becomes significantly
        denormalised, the conversion methods will fail. Therefore it may be safer to
        call this before a conversion.  

        """
        return _clipper_python_core.Rotation_norm(self)


    def abs_angle(self) -> "clipper::ftype":
        """


        return absolute rotation angle  

        Positive magnitude of the angle of rotation.  

        Returns
        -------
        The angle in radians.  

        """
        return _clipper_python_core.Rotation_abs_angle(self)


    def inverse(self) -> "clipper::Rotation":
        """


        return inverse rotation  

        """
        return _clipper_python_core.Rotation_inverse(self)


    def zero() -> "clipper::Rotation":
        """


        return zero rotation  

        """
        return _clipper_python_core.Rotation_zero()

    zero = staticmethod(zero)

    def null() -> "clipper::Rotation":
        """


        return null rotation  

        """
        return _clipper_python_core.Rotation_null()

    null = staticmethod(null)

    def is_null(self) -> "bool":
        """


        test for null (uninitialised) rotation  

        """
        return _clipper_python_core.Rotation_is_null(self)


    def format(self) -> "clipper::String":
        """


        return formatted String representation  

        """
        return _clipper_python_core.Rotation_format(self)

    EulerXYZr = _clipper_python_core.Rotation_EulerXYZr
    EulerXYZs = _clipper_python_core.Rotation_EulerXYZs
    EulerXYXr = _clipper_python_core.Rotation_EulerXYXr
    EulerXYXs = _clipper_python_core.Rotation_EulerXYXs
    EulerXZXr = _clipper_python_core.Rotation_EulerXZXr
    EulerXZXs = _clipper_python_core.Rotation_EulerXZXs
    EulerXZYr = _clipper_python_core.Rotation_EulerXZYr
    EulerXZYs = _clipper_python_core.Rotation_EulerXZYs
    EulerYZXr = _clipper_python_core.Rotation_EulerYZXr
    EulerYZXs = _clipper_python_core.Rotation_EulerYZXs
    EulerYZYr = _clipper_python_core.Rotation_EulerYZYr
    EulerYZYs = _clipper_python_core.Rotation_EulerYZYs
    EulerYXYr = _clipper_python_core.Rotation_EulerYXYr
    EulerYXYs = _clipper_python_core.Rotation_EulerYXYs
    EulerYXZr = _clipper_python_core.Rotation_EulerYXZr
    EulerYXZs = _clipper_python_core.Rotation_EulerYXZs
    EulerZXYr = _clipper_python_core.Rotation_EulerZXYr
    EulerZXYs = _clipper_python_core.Rotation_EulerZXYs
    EulerZXZr = _clipper_python_core.Rotation_EulerZXZr
    EulerZXZs = _clipper_python_core.Rotation_EulerZXZs
    EulerZYZr = _clipper_python_core.Rotation_EulerZYZr
    EulerZYZs = _clipper_python_core.Rotation_EulerZYZs
    EulerZYXr = _clipper_python_core.Rotation_EulerZYXr
    EulerZYXs = _clipper_python_core.Rotation_EulerZYXs
    __swig_destroy__ = _clipper_python_core.delete_Rotation
    __del__ = lambda self: None
Rotation_swigregister = _clipper_python_core.Rotation_swigregister
Rotation_swigregister(Rotation)

def Rotation_zero() -> "clipper::Rotation":
    """


    return zero rotation  

    """
    return _clipper_python_core.Rotation_zero()

def Rotation_null() -> "clipper::Rotation":
    """


    return null rotation  

    """
    return _clipper_python_core.Rotation_null()

class PHSfile(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _clipper_python_core.new_PHSfile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clipper_python_core.delete_PHSfile
    __del__ = lambda self: None

    def open_read(self, filename_in: 'String') -> "void":
        return _clipper_python_core.PHSfile_open_read(self, filename_in)

    def close_read(self) -> "void":
        return _clipper_python_core.PHSfile_close_read(self)

    def open_write(self, filename_out: 'String') -> "void":
        return _clipper_python_core.PHSfile_open_write(self, filename_out)

    def close_write(self) -> "void":
        return _clipper_python_core.PHSfile_close_write(self)

    def resolution(self, cell: 'Cell') -> "clipper::Resolution":
        return _clipper_python_core.PHSfile_resolution(self, cell)

    def import_hkl_info(self, target: 'HKL_info') -> "void":
        return _clipper_python_core.PHSfile_import_hkl_info(self, target)

    def import_hkl_data(self, cdata: 'HKL_data_base') -> "void":
        return _clipper_python_core.PHSfile_import_hkl_data(self, cdata)

    def export_hkl_info(self, target: 'HKL_info') -> "void":
        return _clipper_python_core.PHSfile_export_hkl_info(self, target)

    def export_hkl_data(self, cdata: 'HKL_data_base') -> "void":
        return _clipper_python_core.PHSfile_export_hkl_data(self, cdata)
PHSfile_swigregister = _clipper_python_core.PHSfile_swigregister
PHSfile_swigregister(PHSfile)



