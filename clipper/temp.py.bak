  def isolate_and_cover_selection(self, atoms, include_surrounding_residues = 5, 
                      show_context = 5, mask_radius = 3, hide_surrounds = True, focus = True):
    '''
    Expand the map to cover a given atomic selection, then mask it to
    within a given distance of said atoms to reduce visual clutter. Adjust
    the atomic visualisation to show only the selected atoms, plus an
    optional surrounding buffer zone.
    Args:
      atoms (ChimeraX Atoms object):
        The main selection we're interested in. The existing selection will
        be expanded to include the whole residue for every selected atom.
      include_surrounding_residues (float):
        Any residue with an atom coming within this radius of the primary
        selection will be added to the selection covered by the map. To
        cover only the primary selection, set this value to zero.
      show_context (float):
        Any residue within an atom coming within this radius of the previous
        two selections will be displayed as a thinner stick representation,
        but will not be considered for the map masking calculation.
      mask_radius (float):
        Components of the map more than this distance from any atom will
        be hidden. 
      hide_surrounds (bool):
        If true, all residues outside the selection region will be hidden
      focus (bool):
        If true, the camera will be moved to focus on the selection
    '''
    # If we're in live mode, turn it off
    self.live_atomic_symmetry = False
    self.xmaps.live_scrolling = False
    orig_atoms = atoms
    atoms = atoms.residues.atoms
    coords = atoms.coords
    if include_surrounding_residues > 0:
      atoms = concatenate(
        self.sym_select_within(
            coords, include_surrounding_residues)).residues.atoms
      coords = atoms.coords
    context_atoms = None
    if show_context > 0:
      context_atoms = concatenate(
        self.sym_select_within(
            coords, show_context)).residues.atoms.subtract(atoms)
    pad = calculate_grid_padding(mask_radius, self.grid, self.cell)
    box_bounds_grid = clipper.Util.get_minmax_grid(coords, self.cell, self.grid) \
                            + numpy.array((-pad, pad))
    self.xmaps.set_box_limits(box_bounds_grid)
    
    self.xmaps._surface_zone.update(mask_radius, atoms, None)
    self.xmaps._reapply_zone()
    if context_atoms is None:
      found_models = atoms.unique_structures
    else:
      found_models = concatenate((context_atoms, atoms)).unique_structures
    self.atomic_model.bonds.radii = 0.05
    for key, m in self.sym_container.items():
      if m not in found_models:
        m.display = False
      else:
        m.display = True
        m.atoms.displays = False
        m.residues.ribbon_displays = False
    self.master_model.atoms[numpy.in1d(
        self.master_model.atoms.names, numpy.array(
            ['N','C','CA']))].displays = True 
    if not self.show_nonpolar_H:
      atoms = atoms.filter(atoms.idatm_types != 'HC')   
    atoms.displays = True
    atoms.inter_bonds.radii = 0.2
    atoms.residues.ribbon_displays = True
    if context_atoms is not None:
      if not self.periodic_model.show_nonpolar_H:
        context_atoms = context_atoms.filter(context_atoms.idatm_types != 'HC')   
      context_atoms.displays = True
      context_atoms.inter_bonds.radii = 0.1
    if focus:
      self.session.view.view_all(atoms.scene_bounds, 0.2)
    # return the original selection in case we want to re-run with modified settings
    return orig_atoms
